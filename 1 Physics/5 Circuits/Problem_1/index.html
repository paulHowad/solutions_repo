<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Problem 1 - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Problem 1";
        var mkdocs_page_input_path = "1 Physics/5 Circuits/Problem_1.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Investigating the Dynamics of a Forced Damped Pendulum</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">5 Circuits</a>
<ul class="current">
<li class="toctree-l2 current"><a class="reference internal current" href="#">Problem 1</a>
<ul class="current">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">6 Statistics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">5 Circuits</li>
<li class="breadcrumb-item active">Problem 1</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="problem-1">Problem 1</h1>
<h1 id="equivalent-resistance-calculation-using-graph-theory">Equivalent Resistance Calculation Using Graph Theory</h1>
<h2 id="1-introduction">1. Introduction</h2>
<p>Calculating the equivalent resistance of electrical circuits is a fundamental problem in electrical engineering. Traditional methods involve iteratively applying series and parallel rules, which becomes increasingly complex for circuits with multiple cycles and complex topologies.</p>
<p>By representing circuits as graphs, we can leverage graph theory to systematically reduce and analyze any circuit configuration:
- <strong>Nodes</strong> represent junctions in the circuit
- <strong>Edges</strong> represent resistors with weights equal to resistance values
- <strong>Source and sink</strong> nodes represent the terminals across which we measure equivalent resistance</p>
<h2 id="2-algorithm-description">2. Algorithm Description</h2>
<p>Our algorithm combines multiple techniques to handle circuits of any complexity:</p>
<h3 id="21-basic-reduction-rules">2.1 Basic Reduction Rules</h3>
<ol>
<li>
<p><strong>Series Reduction</strong>:                           </p>
<ul>
<li><strong>Condition</strong>: A node has exactly 2 connections and is neither source nor sink</li>
<li><strong>Action</strong>: Replace the node and its two adjacent resistors with a single resistor equal to their sum</li>
<li><strong>Formula</strong>: <span class="arithmatex">\(R_{eq} = R_1 + R_2\)</span></li>
</ul>
</li>
<li>
<p><strong>Parallel Reduction</strong>:                        </p>
<ul>
<li><strong>Condition</strong>: Multiple resistors directly connect the same pair of nodes</li>
<li><strong>Action</strong>: Replace them with a single equivalent resistor</li>
<li><strong>Formula</strong>: <span class="arithmatex">\(\frac{1}{R_{eq}} = \frac{1}{R_1} + \frac{1}{R_2} + ... + \frac{1}{R_n}\)</span></li>
</ul>
</li>
</ol>
<h3 id="22-advanced-techniques">2.2 Advanced Techniques</h3>
<p>For circuits that cannot be fully reduced using only series and parallel reductions:</p>
<h3 id="1-y-wye-delta-transformation">1. <strong>Y-Δ (Wye-Delta) Transformation</strong>:</h3>
<ul>
<li>
<p>Transforms three resistors in Y configuration to three resistors in Δ configuration or vice versa.</p>
</li>
<li>
<p><strong>Y to Δ conversion</strong>:
  $$
  R_{AB} = \frac{R_A R_B + R_B R_C + R_C R_A}{R_C}
  $$
  $$
  R_{BC} = \frac{R_A R_B + R_B R_C + R_C R_A}{R_A}
  $$
  $$
  R_{CA} = \frac{R_A R_B + R_B R_C + R_C R_A}{R_B}
  $$</p>
</li>
<li>
<p><strong>Δ to Y conversion</strong>:
  $$
  R_A = \frac{R_{AB} R_{CA}}{R_{AB} + R_{BC} + R_{CA}}
  $$
  $$
  R_B = \frac{R_{AB} R_{BC}}{R_{AB} + R_{BC} + R_{CA}}
  $$
  $$
  R_C = \frac{R_{BC} R_{CA}}{R_{AB} + R_{BC} + R_{CA}}
  $$</p>
</li>
</ul>
<hr/>
<h3 id="2-node-elimination-method">2. <strong>Node Elimination Method</strong>:</h3>
<ul>
<li>Based on Kirchhoff’s laws and nodal analysis.</li>
<li>Uses matrix operations to systematically eliminate nodes.</li>
</ul>
<hr/>
<h3 id="23-algorithm-flow">2.3 Algorithm Flow</h3>
<pre><code>ALGORITHM CalculateEquivalentResistance(G, source, sink):
    Initialize graph G with resistors as weighted edges
    Store original graph for visualization

    WHILE circuit not fully reduced:
        Apply all possible parallel reductions
        Apply all possible series reductions

        IF no reductions possible:
            IF Y-Delta transformations applicable:
                Apply Y-Delta transformation
            ELSE:
                Use node elimination method
                BREAK

    RETURN resistance between source and sink
</code></pre>
<h2 id="3-implementation">3. Implementation</h2>
<p>Here's a complete Python implementation using NetworkX:</p>
<pre><code class="language-python">import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, Dict, Optional


class CircuitAnalyzer:
    def __init__(self, graph: nx.Graph, source: int, sink: int):
        """
        Initialize circuit analyzer with a graph representation of the circuit.

        Args:
            graph: NetworkX Graph where edges have 'weight' attribute representing resistance
            source: Source node (input terminal)
            sink: Sink node (output terminal)
        """
        self.original_graph = graph.copy()
        self.source = source
        self.sink = sink
        self.reduction_steps = []  # Store reduction steps for visualization

    def calculate_equivalent_resistance(self, debug: bool = False) -&gt; float:
        """Calculate the equivalent resistance between source and sink nodes."""
        g = self.original_graph.copy()
        self.reduction_steps = [("Original Circuit", g.copy())]

        # Basic series/parallel reductions
        while True:
            parallel_count = self._reduce_all_parallel(g, debug)
            series_count = self._reduce_all_series(g, debug)
            if parallel_count == 0 and series_count == 0:
                break

        # Direct connection check
        if g.number_of_edges() == 1 and g.has_edge(self.source, self.sink):
            r_eq = g[self.source][self.sink]['weight']
            self.reduction_steps.append(("Final Reduced Circuit", g.copy()))
            if debug:
                print(f"Circuit fully reduced to {r_eq} ohms")
            return r_eq

        # Y-Delta transformations
        if debug:
            print("Basic reductions insufficient. Attempting Y-Delta transformations...")
        delta_reductions = self._apply_y_delta_transformations(g, debug)
        if delta_reductions &gt; 0:
            while True:
                parallel_count = self._reduce_all_parallel(g, debug)
                series_count = self._reduce_all_series(g, debug)
                if parallel_count == 0 and series_count == 0:
                    break

        if g.number_of_edges() == 1 and g.has_edge(self.source, self.sink):
            r_eq = g[self.source][self.sink]['weight']
            self.reduction_steps.append(("Final Reduced Circuit", g.copy()))
            return r_eq

        # Node elimination method as fallback
        if debug:
            print("Using node elimination method...")
        r_eq = self._node_elimination_method(g, debug)
        self.reduction_steps.append(("Final Result (Node Elimination)",
                                   nx.Graph([(self.source, self.sink, {'weight': r_eq})])))
        return r_eq

    def _reduce_all_parallel(self, g: nx.Graph, debug: bool = False) -&gt; int:
        reduction_count = 0
        parallel_edges = self._find_parallel_edges(g)
        for (n1, n2), edges in parallel_edges.items():
            if len(edges) &gt; 1:
                total_conductance = sum(1.0 / g[n1][n2]['weight'] for _ in range(len(edges)))
                r_eq = 1.0 / total_conductance
                for _ in range(len(edges) - 1):
                    g.remove_edge(n1, n2)
                g[n1][n2]['weight'] = r_eq
                if debug:
                    print(f"Parallel reduction: {len(edges)} resistors between nodes {n1}-{n2} → {r_eq:.2f}Ω")
                reduction_count += 1
                self.reduction_steps.append((f"Parallel Reduction: {n1}-{n2}", g.copy()))
        return reduction_count

    def _find_parallel_edges(self, g: nx.Graph) -&gt; Dict[Tuple[int, int], list]:
        parallel_edges = {}
        for edge in g.edges():
            n1, n2 = min(edge), max(edge)
            key = (n1, n2)
            parallel_edges.setdefault(key, []).append(edge)
        return parallel_edges

    def _reduce_all_series(self, g: nx.Graph, debug: bool = False) -&gt; int:
        reduction_count = 0
        series_nodes = [node for node in g.nodes()
                        if g.degree(node) == 2 and node not in (self.source, self.sink)]
        for node in series_nodes:
            n1, n2 = list(g.neighbors(node))
            r1 = g[node][n1]['weight']
            r2 = g[node][n2]['weight']
            r_eq = r1 + r2
            g.remove_node(node)
            g.add_edge(n1, n2, weight=r_eq)
            if debug:
                print(f"Series reduction: Node {node} between {n1}-{n2} → {r_eq:.2f}Ω")
            reduction_count += 1
            self.reduction_steps.append((f"Series Reduction: Node {node}", g.copy()))
        return reduction_count

    def _apply_y_delta_transformations(self, g: nx.Graph, debug: bool = False) -&gt; int:
        transformation_count = 0
        # Y to Δ
        for node in list(g.nodes()):
            if node in (self.source, self.sink) or g.degree(node) != 3:
                continue
            neighbors = list(g.neighbors(node))
            r_a, r_b, r_c = (g[node][n]['weight'] for n in neighbors)
            r_ab = (r_a*r_b + r_b*r_c + r_c*r_a) / r_c
            r_bc = (r_a*r_b + r_b*r_c + r_c*r_a) / r_a
            r_ca = (r_a*r_b + r_b*r_c + r_c*r_a) / r_b
            g.remove_node(node)
            g.add_edge(neighbors[0], neighbors[1], weight=r_ab)
            g.add_edge(neighbors[1], neighbors[2], weight=r_bc)
            g.add_edge(neighbors[2], neighbors[0], weight=r_ca)
            if debug:
                print(f"Y-Delta transformation: Center node {node} → Delta")
            transformation_count += 1
            self.reduction_steps.append((f"Y-Delta: Node {node}", g.copy()))
            break
        if transformation_count &gt; 0:
            return transformation_count
        # Δ to Y
        triangles = []
        for n1 in g.nodes():
            for n2 in g.neighbors(n1):
                for n3 in g.neighbors(n2):
                    if n3 in g.neighbors(n1) and n1 &lt; n2 &lt; n3:
                        triangles.append((n1, n2, n3))
        for tri in triangles:
            r_ab = g[tri[0]][tri[1]]['weight']
            r_bc = g[tri[1]][tri[2]]['weight']
            r_ca = g[tri[2]][tri[0]]['weight']
            denom = r_ab + r_bc + r_ca
            r_a = r_ab*r_ca/denom
            r_b = r_ab*r_bc/denom
            r_c = r_bc*r_ca/denom
            new_node = max(g.nodes()) + 1
            g.add_node(new_node)
            g.remove_edge(tri[0], tri[1])
            g.remove_edge(tri[1], tri[2])
            g.remove_edge(tri[2], tri[0])
            g.add_edge(new_node, tri[0], weight=r_a)
            g.add_edge(new_node, tri[1], weight=r_b)
            g.add_edge(new_node, tri[2], weight=r_c)
            if debug:
                print(f"Delta-Y transformation: Triangle {tri} → Star node {new_node}")
            transformation_count += 1
            self.reduction_steps.append((f"Delta-Y: Triangle {tri}", g.copy()))
            break
        return transformation_count

    def _node_elimination_method(self, g: nx.Graph, debug: bool = False) -&gt; float:
        nodes = list(g.nodes())
        nodes.remove(self.source)
        if self.sink not in nodes:
            return float('inf')
        n = len(nodes)
        G = np.zeros((n, n))
        idx = {node: i for i, node in enumerate(nodes)}
        for i, ni in enumerate(nodes):
            for j, nj in enumerate(nodes):
                if i == j:
                    for nbr in g.neighbors(ni):
                        G[i, i] += 1.0/g[ni][nbr]['weight']
                elif g.has_edge(ni, nj):
                    G[i, j] = -1.0/g[ni][nj]['weight']
        try:
            G_inv = np.linalg.inv(G)
            r_eq = 1.0/G[idx[self.sink], idx[self.sink]]
        except np.linalg.LinAlgError:
            r_eq = g[self.source][self.sink]['weight'] if g.has_edge(self.source, self.sink) else float('inf')
        if debug:
            print(f"Node elimination result: {r_eq:.4f}Ω")
        return r_eq

    def draw_circuit(self, title="Circuit"):
        g = self.original_graph.copy()
        plt.figure(figsize=(8, 6))
        pos = nx.spring_layout(g, seed=42)
        nx.draw_networkx_nodes(g, pos, node_size=500, node_color='lightblue')
        nx.draw_networkx_nodes(g, pos, nodelist=[self.source, self.sink], node_color='red', node_size=700)
        nx.draw_networkx_edges(g, pos, width=1.5)
        edge_labels = {(u, v): f"{d['weight']}Ω" for u, v, d in g.edges(data=True)}
        nx.draw_networkx_edge_labels(g, pos, edge_labels=edge_labels)
        nx.draw_networkx_labels(g, pos)
        plt.title(title)
        plt.axis('off')
        plt.tight_layout()
        plt.show()

    def visualize_reduction_steps(self):
        steps = self.reduction_steps
        n = len(steps)
        cols = min(3, n)
        rows = (n + cols - 1) // cols
        plt.figure(figsize=(6*cols, 4*rows))
        for i, (title, g) in enumerate(steps):
            plt.subplot(rows, cols, i+1)
            pos = nx.spring_layout(g, seed=42)
            nx.draw_networkx_nodes(g, pos, node_size=400, node_color='lightblue')
            if self.source in g.nodes() and self.sink in g.nodes():
                nx.draw_networkx_nodes(g, pos, nodelist=[self.source, self.sink], node_color='red', node_size=600)
            nx.draw_networkx_edges(g, pos, width=1.5)
            edge_labels = {(u, v): f"{d['weight']}Ω" for u, v, d in g.edges(data=True)}
            nx.draw_networkx_edge_labels(g, pos, edge_labels=edge_labels, font_size=8)
            nx.draw_networkx_labels(g, pos)
            plt.title(f"Step {i+1}: {title}")
            plt.axis('off')
        plt.tight_layout()
        plt.show()


if __name__ == "__main__":
    # Example usage
    # Create a circuit with series, parallel, and a triangle (for Y-Δ)
    G = nx.Graph()
    # Series: 4Ω and 6Ω between 0-1-2
    G.add_edge(0, 1, weight=4)
    G.add_edge(1, 2, weight=6)
    # Parallel: two 8Ω resistors between 2-3
    G.add_edge(2, 3, weight=8)
    G.add_edge(2, 3, weight=8)
    # Delta: triangle between 3-4-5
    G.add_edge(3, 4, weight=3)
    G.add_edge(4, 5, weight=5)
    G.add_edge(5, 3, weight=7)

    analyzer = CircuitAnalyzer(G, source=0, sink=5)
    eq_resistance = analyzer.calculate_equivalent_resistance(debug=True)
    print(f"Equivalent Resistance between 0 and 5: {eq_resistance:.2f} Ω")

    # Visualize original circuit and reduction steps
    analyzer.draw_circuit("Original Circuit")
    analyzer.visualize_reduction_steps()

</code></pre>
<h2 id="outputs">Outputs</h2>
<p><img alt="alt text" src="../image.png"/></p>
<p><strong>Explanation:</strong> <br/>
The <strong>Original Circuit</strong> diagram displays the starting   network:     </p>
<ul>
<li><strong>Red nodes</strong> (0 and 5) are the source (input) and sink (output).                        </li>
<li><strong>Light-blue nodes</strong> (1, 2, 3, 4) are intermediate junctions.                  </li>
<li>Edges are labeled with resistor values: a series chain (4 Ω–6 Ω), a parallel pair (8 Ω &amp; 8 Ω), and a Δ-triangle (3 Ω, 5 Ω, 7 Ω).</li>
</ul>
<hr/>
<p><img alt="alt text" src="../image-1.png"/></p>
<p><strong>Explanation:</strong> <br/>
The <strong>Reduction Steps</strong> grid shows six panels:                                                                 <br/>
   1. <strong>Original Circuit</strong> – same as above.                               <br/>
   2. <strong>Series Reduction: Node 1</strong> – combines 4 Ω + 6 Ω → 10 Ω.           <br/>
   3. <strong>Series Reduction: Node 2</strong> – next series step (10 Ω + parallel result) → 18 Ω.                      <br/>
   4. <strong>Series Reduction: Node 3</strong> – merges 18 Ω + 30 Ω → 48 Ω.            <br/>
   5. <strong>Y-Δ / Δ-Y Transformations</strong> – converts the remaining triangle into a star (or vice versa) to enable further reductions.                  <br/>
   6. <strong>Final Reduced Circuit</strong> – a single 26 Ω resistor between source and sink, the net equivalent resistance.</p>
<h2 id="4-example-circuits-and-visual-representations">4. Example Circuits and Visual Representations</h2>
<h3 id="41-example-1-simple-series-parallel-circuit">4.1 Example 1: Simple Series-Parallel Circuit</h3>
<pre><code>    A---[10Ω]---B---[20Ω]---C
    |                       |
   [30Ω]                   [40Ω]
    |                       |
    D-------------------E
</code></pre>
<p>ASCII representation:</p>
<pre><code>A---10Ω---B---20Ω---C
|                   |
30Ω                40Ω
|                   |
D---------E---------+
</code></pre>
<p>This circuit combines series and parallel elements:                        </p>
<ul>
<li>Path A-B-C: <span class="arithmatex">\(10Ω + 20Ω = 30Ω\)</span> (series)</li>
<li>Path A-D-E-C: <span class="arithmatex">\(30Ω + 40Ω = 70Ω\)</span> (series)</li>
<li>Paths are in parallel: <span class="arithmatex">\(\frac{1}{R_{eq}} = \frac{1}{30} + \frac{1}{70} = \frac{7}{210}\)</span></li>
<li><span class="arithmatex">\(R_{eq} = \frac{210}{7} = 30Ω\)</span></li>
</ul>
<h3 id="42-example-2-wheatstone-bridge-circuit">4.2 Example 2: Wheatstone Bridge Circuit</h3>
<pre><code>    A---[10Ω]---B
    |           |
   [20Ω]       [30Ω]
    |     [50Ω]  |
    C---[40Ω]---D
</code></pre>
<p>ASCII representation:</p>
<pre><code>    A---10Ω---B
    |         |
   20Ω       30Ω
    |    50Ω  |
    C----     |
    |    \    |
    |     \   |
   40Ω      \ |
    |        \|
    D---------+
</code></pre>
<p>This circuit has a bridge element (50Ω between B and C), which cannot be reduced using only series and parallel rules. We need Y-Δ transformation:</p>
<ol>
<li>Apply Y-Δ transformation to convert the bridge into a reducible form</li>
<li>Then apply series-parallel reductions</li>
<li>If needed, use node elimination method</li>
</ol>
<h3 id="43-example-3-complex-mesh-circuit">4.3 Example 3: Complex Mesh Circuit</h3>
<pre><code>    A---[2Ω]---B---[5Ω]---C
    |         |           |
   [4Ω]      [7Ω]        [3Ω]
    |         |           |
    D---[8Ω]--E---[6Ω]---F
</code></pre>
<p>ASCII representation:</p>
<pre><code>A---2Ω---B---5Ω---C
|        |        |
4Ω      7Ω       3Ω
|        |        |
D---8Ω---E---6Ω---F
</code></pre>
<p>This complex mesh circuit requires multiple reduction steps:</p>
<ol>
<li>Cannot be directly reduced with series-parallel only</li>
<li>Need Y-Δ transformations for certain configurations</li>
<li>Final solution may require node elimination method</li>
</ol>
<h2 id="5-algorithm-analysis">5. Algorithm Analysis</h2>
<h3 id="51-time-complexity">5.1 Time Complexity</h3>
<ul>
<li><strong>Series and Parallel Reductions</strong>: <span class="arithmatex">\(O(|V| + |E|)\)</span> per iteration</li>
<li><strong>Y-Δ Transformations</strong>: <span class="arithmatex">\(O(|V|^3)\)</span> in worst case</li>
<li><strong>Node Elimination Method</strong>: <span class="arithmatex">\(O(|V|^3)\)</span> for matrix operations</li>
<li><strong>Overall</strong>: <span class="arithmatex">\(O(|V|^3)\)</span> dominated by the more complex operations</li>
</ul>
<h3 id="52-space-complexity">5.2 Space Complexity</h3>
<ul>
<li><span class="arithmatex">\(O(|V|^2 + |E|)\)</span> for graph representation and matrices</li>
</ul>
<h3 id="53-strengths">5.3 Strengths</h3>
<ol>
<li><strong>Handles Any Circuit Topology</strong>: Works with any valid resistor configuration</li>
<li><strong>Automated Analysis</strong>: Systematically reduces complex circuits</li>
<li><strong>Visual Insights</strong>: Provides step-by-step visualization of circuit reduction</li>
<li><strong>Multiple Methods</strong>: Combines different techniques for comprehensive analysis</li>
</ol>
<h3 id="54-potential-improvements">5.4 Potential Improvements</h3>
<ol>
<li><strong>Optimization for Sparse Circuits</strong>: Use sparse matrix techniques for large circuits</li>
<li><strong>Heuristic Selection</strong>: Develop heuristics to choose optimal reduction sequences</li>
<li><strong>Parallel Processing</strong>: Identify independent subcircuits for parallel calculation</li>
<li><strong>Extension to AC Circuits</strong>: Add support for complex impedances in AC circuit analysis</li>
</ol>
<h2 id="6-example-python-usage">6. Example Python Usage</h2>
<pre><code class="language-python">import networkx as nx

# Create a circuit graph
g = nx.Graph()

# Example: Create a bridge circuit (Wheatstone bridge)
g.add_edge('A', 'B', weight=10)  # 10Ω
g.add_edge('A', 'C', weight=20)  # 20Ω
g.add_edge('B', 'D', weight=30)  # 30Ω
g.add_edge('C', 'D', weight=40)  # 40Ω
g.add_edge('B', 'C', weight=50)  # 50Ω (bridge element)

# Create analyzer and calculate equivalent resistance
analyzer = CircuitAnalyzer(g, 'A', 'D')
r_eq = analyzer.calculate_equivalent_resistance(debug=True)

print(f"Equivalent resistance: {r_eq} Ω")

# Draw original circuit and visualization of reduction steps
analyzer.draw_circuit("Wheatstone Bridge Circuit")
analyzer.visualize_reduction_steps()
</code></pre>
<h2 id="outputs_1">Outputs</h2>
<p><img alt="alt text" src="../image-2.png"/></p>
<p><strong>Explanation:</strong>
The <strong>Wheatstone Bridge Circuit</strong> diagram shows the original network:                                 </p>
<ul>
<li><strong>Red nodes</strong> (A and D) are the source and sink.                         </li>
<li><strong>Light-blue nodes</strong> (B and C) are intermediate junctions.                  </li>
<li>Edges are labeled with resistor values:  <ul>
<li>A–B: 10 Ω  </li>
<li>A–C: 20 Ω  </li>
<li>B–D: 30 Ω  </li>
<li>C–D: 40 Ω  </li>
<li>B–C (bridge): 50 Ω  </li>
</ul>
</li>
</ul>
<hr/>
<p><img alt="alt text" src="../image-3.png"/></p>
<p><strong>Explanation:</strong>
The <strong>Reduction Steps</strong> figure is laid out in four panels:</p>
<ol>
<li><strong>Original Circuit</strong> – same as above.                               </li>
<li><strong>Y-Δ: Node B</strong> – the star at B (10 Ω, 30 Ω, 50 Ω) is converted into a Δ, producing new resistances:  <ul>
<li>A–C ≈ 76.67 Ω  </li>
<li>B–D ≈ 46 Ω  </li>
<li>C–D ≈ 230 Ω  </li>
</ul>
</li>
<li><strong>Series Reduction: Node C</strong> – combines 76.67 Ω + 230 Ω into a single 306.67 Ω resistor on the A–D path.  </li>
<li><strong>Final Reduced Circuit</strong> – a single 306.67 Ω resistor between A and D, the net equivalent resistance.</li>
</ol>
<h2 id="7-conclusion">7. Conclusion</h2>
<p>Graph theory provides a powerful framework for calculating equivalent resistance in electrical circuits. By representing circuits as graphs and applying systematic reduction techniques, we can handle circuits of arbitrary complexity. The combination of series-parallel reductions, Y-Δ transformations, and node elimination methods ensures that we can solve any valid resistor network.</p>
<p>This approach not only automates circuit analysis but also provides insights into the mathematical structure of electrical networks, demonstrating the elegant intersection of graph theory and electrical engineering principles.</p>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../../4%20Electromagnetism/Problem_1/" title="Problem 1"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../6%20Statistics/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../../4%20Electromagnetism/Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../6%20Statistics/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
