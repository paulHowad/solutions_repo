<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Estimating π using Monte Carlo Methods - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Estimating \u03c0 using Monte Carlo Methods";
        var mkdocs_page_input_path = "1 Physics/6 Statistics/Problem_2.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Investigating the Dynamics of a Forced Damped Pendulum</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Circuits</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../5%20Circuits/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">6 Statistics</a>
<ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../Problem_1/">Exploring the Central Limit Theorem through Simulations</a>
</li>
<li class="toctree-l2 current"><a class="reference internal current" href="#">Estimating π using Monte Carlo Methods</a>
<ul class="current">
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#part-1-estimating-using-a-circle">Part 1: Estimating π Using a Circle</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#11-theoretical-foundation">1.1 Theoretical Foundation</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#12-simulation-implementation">1.2 Simulation Implementation</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#13-visualization-and-analysis">1.3 Visualization and Analysis</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#output-circlebased-monte-carlo-method">Output: Circle‐Based Monte Carlo Method</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#terminal-output">Terminal Output</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#part-2-estimating-using-buffons-needle">Part 2: Estimating π Using Buffon's Needle</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#21-theoretical-foundation">2.1 Theoretical Foundation</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#22-simulation-implementation">2.2 Simulation Implementation</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#23-visualization-and-analysis">2.3 Visualization and Analysis</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#output-buffons-needle-experiment">Output: Buffon’s Needle Experiment</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#terminal-output-buffons-needle-method-results">Terminal Output: Buffon’s Needle Method Results</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#part-3-comparison-of-methods">Part 3: Comparison of Methods</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#31-implementation">3.1 Implementation</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#32-comparative-analysis">3.2 Comparative Analysis</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#output">Output</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#circlebased-monte-carlo-method">Circle‐Based Monte Carlo Method</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#buffons-needle-experiment">Buffon’s Needle Experiment</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#comparison-of-methods">Comparison of Methods</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#terminal-output-comparison-of-methods">Terminal Output: Comparison of Methods</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#conclusion">Conclusion</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">6 Statistics</li>
<li class="breadcrumb-item active">Estimating π using Monte Carlo Methods</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="estimating-using-monte-carlo-methods">Estimating π using Monte Carlo Methods</h1>
<h2 id="introduction">Introduction</h2>
<p>Monte Carlo methods represent a class of computational algorithms that utilize random sampling to obtain numerical results. One of the most elegant and intuitive applications of these methods is estimating the value of π. This document explores two different Monte Carlo approaches to approximating π: the circle-based method and Buffon's Needle experiment.</p>
<h2 id="part-1-estimating-using-a-circle">Part 1: Estimating π Using a Circle</h2>
<h3 id="11-theoretical-foundation">1.1 Theoretical Foundation</h3>
<p>The circle-based Monte Carlo method for estimating π relies on the relationship between the area of a circle and the area of its bounding square. Consider a unit circle (radius = 1) centered at the origin, enclosed by a 2×2 square:</p>
<ul>
<li>Area of the unit circle: <span class="arithmatex">\(A_{circle} = \pi r^2 = \pi \cdot 1^2 = \pi\)</span></li>
<li>Area of the bounding square: <span class="arithmatex">\(A_{square} = (2r)^2 = 4\)</span></li>
</ul>
<p>The ratio of these areas is:</p>
<div class="arithmatex">\[\frac{A_{circle}}{A_{square}} = \frac{\pi}{4}\]</div>
<p>If we randomly generate points within the square, the probability of a point falling inside the circle equals the ratio of the areas:</p>
<div class="arithmatex">\[P(\text{point inside circle}) = \frac{A_{circle}}{A_{square}} = \frac{\pi}{4}\]</div>
<p>By rearranging, we get:</p>
<div class="arithmatex">\[\pi \approx 4 \times \frac{\text{points inside circle}}{\text{total points}}\]</div>
<p>This provides us with a method to estimate π: generate random points within the square, count how many fall inside the circle, and apply the formula.</p>
<h3 id="12-simulation-implementation">1.2 Simulation Implementation</h3>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
import time
from matplotlib.patches import Circle

def estimate_pi_circle(num_points):
    """
    Estimate π using the circle-based Monte Carlo method.

    Parameters:
    -----------
    num_points : int
        Number of random points to generate

    Returns:
    --------
    float
        Estimated value of π
    ndarray
        Array of points inside the circle
    ndarray
        Array of points outside the circle
    """
    # Generate random points in the square [-1, 1] × [-1, 1]
    x = np.random.uniform(-1, 1, num_points)
    y = np.random.uniform(-1, 1, num_points)

    # Compute distances from origin
    distances = x**2 + y**2

    # Determine which points are inside the circle (distance &lt; 1)
    inside_circle = distances &lt;= 1

    # Count points inside the circle
    count_inside = np.sum(inside_circle)

    # Estimate π
    pi_estimate = 4 * count_inside / num_points

    # Return the estimate and points for visualization
    return pi_estimate, np.column_stack((x[inside_circle], y[inside_circle])), np.column_stack((x[~inside_circle], y[~inside_circle]))

def visualize_circle_method(points_inside, points_outside, pi_estimate, num_points):
    """
    Create a visualization of the circle-based Monte Carlo method.

    Parameters:
    -----------
    points_inside : ndarray
        Points inside the circle
    points_outside : ndarray
        Points outside the circle
    pi_estimate : float
        Estimated value of π
    num_points : int
        Total number of points used in the simulation
    """
    plt.figure(figsize=(10, 10))

    # Plot the unit circle
    circle = Circle((0, 0), 1, fill=False, color='r', linewidth=2)
    plt.gca().add_patch(circle)

    # Plot the square
    plt.plot([-1, 1, 1, -1, -1], [-1, -1, 1, 1, -1], 'b-', linewidth=2)

    # Plot points
    if len(points_inside) &gt; 0:
        plt.scatter(points_inside[:, 0], points_inside[:, 1], color='green', alpha=0.5, s=5, label='Inside Circle')
    if len(points_outside) &gt; 0:
        plt.scatter(points_outside[:, 0], points_outside[:, 1], color='red', alpha=0.5, s=5, label='Outside Circle')

    plt.axis('equal')
    plt.grid(True)
    plt.xlim(-1.1, 1.1)
    plt.ylim(-1.1, 1.1)
    plt.title(f'Estimating π using Monte Carlo Method (Circle)\n'
              f'Points: {num_points}, π ≈ {pi_estimate:.6f}, Error: {abs(pi_estimate - np.pi):.6f}')
    plt.legend()
    plt.savefig('circle_monte_carlo.png')
    plt.show()

def analyze_convergence_circle(max_points=1000000, steps=20):
    """
    Analyze how the estimation of π converges as the number of points increases.

    Parameters:
    -----------
    max_points : int
        Maximum number of points to use
    steps : int
        Number of steps to take between 1000 and max_points

    Returns:
    --------
    ndarray
        Array of numbers of points used
    ndarray
        Array of π estimates
    ndarray
        Array of execution times
    """
    # Use logarithmic spacing for better visualization
    points_range = np.logspace(3, np.log10(max_points), steps).astype(int)
    pi_estimates = np.zeros(steps)
    exec_times = np.zeros(steps)

    for i, n in enumerate(points_range):
        start_time = time.time()
        pi_estimates[i], _, _ = estimate_pi_circle(n)
        exec_times[i] = time.time() - start_time

    return points_range, pi_estimates, exec_times

# Example usage
if __name__ == "__main__":
    # Estimate π using different numbers of points
    num_points_visualization = 5000  # For visualization
    pi_estimate, points_inside, points_outside = estimate_pi_circle(num_points_visualization)
    visualize_circle_method(points_inside, points_outside, pi_estimate, num_points_visualization)

    # Analyze convergence
    points_range, pi_estimates, exec_times = analyze_convergence_circle(max_points=1000000)

    # Plot convergence
    plt.figure(figsize=(12, 6))

    # Plot the estimates
    plt.subplot(1, 2, 1)
    plt.semilogx(points_range, pi_estimates, 'b-o')
    plt.axhline(y=np.pi, color='r', linestyle='--', label='True π')
    plt.xlabel('Number of Points')
    plt.ylabel('Estimated π')
    plt.title('Convergence of π Estimate (Circle Method)')
    plt.grid(True)
    plt.legend()

    # Plot the errors
    plt.subplot(1, 2, 2)
    plt.loglog(points_range, np.abs(pi_estimates - np.pi), 'g-o')
    plt.xlabel('Number of Points (log scale)')
    plt.ylabel('Absolute Error (log scale)')
    plt.title('Error vs. Number of Points')
    plt.grid(True)

    plt.tight_layout()
    plt.savefig('circle_convergence.png')
    plt.show()

    # Print results
    print("Circle-based Monte Carlo Method Results:")
    print(f"{'Points':&lt;12} {'π Estimate':&lt;15} {'Error':&lt;15} {'Time (s)':&lt;10}")
    print("-" * 52)
    for n, pi_est, t in zip(points_range, pi_estimates, exec_times):
        print(f"{n:&lt;12} {pi_est:&lt;15.8f} {abs(pi_est - np.pi):&lt;15.8f} {t:&lt;10.6f}")
</code></pre>
<h3 id="13-visualization-and-analysis">1.3 Visualization and Analysis</h3>
<p>The circle-based Monte Carlo method provides a straightforward and intuitive way to estimate π. As the number of points increases, the estimate converges to the true value of π. The method's error decreases proportionally to <span class="arithmatex">\(1/\sqrt{n}\)</span>, where <span class="arithmatex">\(n\)</span> is the number of points.</p>
<p>The visualization shows random points distributed within a square, with points colored based on whether they fall inside or outside the unit circle. As more points are generated, the ratio of points inside the circle to the total number of points converges to <span class="arithmatex">\(\pi/4\)</span>.</p>
<hr/>
<h2 id="output-circlebased-monte-carlo-method">Output: Circle‐Based Monte Carlo Method</h2>
<p><img alt="alt text" src="../image-8.png"/></p>
<p><em>Figure 1: Scatter plot of 5 000 random points in the square <span class="arithmatex">\([-1,1]^2\)</span>.<br/>
Green points lie inside the unit circle, red points lie outside.<br/>
Estimated <span class="arithmatex">\(π ≈ 3.155200\)</span> (error ≈ 0.013607).</em></p>
<p><img alt="alt text" src="../image-9.png"/></p>
<p><em>Figure 2 (left): <span class="arithmatex">\(π\)</span> estimates as a function of the number of random points (log scale). The dashed red line is the true <span class="arithmatex">\(π\)</span>.</em><br/>
<em>Figure 2 (right): Absolute error vs. number of points (both axes log scale), showing the expected <span class="arithmatex">\(O(1/\sqrt{n})\)</span> decline in error.</em> </p>
<hr/>
<h3 id="terminal-output">Terminal Output</h3>
<p>Below is the summary table printed in console, showing how the π estimate, absolute error, and execution time evolve with increasing sample size:</p>
<pre><code>Circle-based Monte Carlo Method Results:
Points       π Estimate      Error           Time (s)
----------------------------------------------------
1000         3.19600000      0.05440735      0.000221
1438         3.10152990      0.04006275      0.000155
2069         3.19961334      0.05802069      0.000187
2976         3.11290323      0.02868943      0.000252
4281         3.14505957      0.00346691      0.000348
6158         3.16791166      0.02631901      0.000488
8858         3.15646873      0.01487608      0.000663
12742        3.13043478      0.01115787      0.000798
18329        3.13339517      0.00819749      0.000611
26366        3.14238034      0.00078768      0.000865
37926        3.12323999      0.01835266      0.003066
54555        3.13276510      0.00882755      0.001783
78475        3.14347244      0.00187979      0.002468
112883       3.13921494      0.00237771      0.003477
162377       3.13891746      0.00267520      0.005109
233572       3.13809874      0.00349391      0.008827
335981       3.14570169      0.00410904      0.013826
483293       3.14529695      0.00370430      0.015773
695192       3.14389118      0.00229853      0.022047
1000000      3.14342000      0.00182735      0.029863
</code></pre>
<p><em>Explanation:</em></p>
<ul>
<li><strong>Points:</strong> Number of random samples drawn.</li>
<li><strong>π Estimate:</strong> Estimated value of π from that many points.</li>
<li><strong>Error:</strong> Absolute difference from the true π.</li>
<li><strong>Time (s):</strong> Computation time for each simulation, showing that runtimes grow moderately with sample size.</li>
</ul>
<h2 id="part-2-estimating-using-buffons-needle">Part 2: Estimating π Using Buffon's Needle</h2>
<h3 id="21-theoretical-foundation">2.1 Theoretical Foundation</h3>
<p>Buffon's Needle is a classic probability problem formulated by Georges-Louis Leclerc, Comte de Buffon, in the 18th century. The problem involves dropping a needle randomly on a surface with parallel lines and calculating the probability of the needle crossing a line.</p>
<p>Consider a plane with parallel lines spaced at a distance <span class="arithmatex">\(d\)</span> apart. A needle of length <span class="arithmatex">\(L\)</span> (where <span class="arithmatex">\(L \leq d\)</span>) is dropped randomly on this plane. The probability that the needle crosses a line is:</p>
<div class="arithmatex">\[P(\text{needle crosses a line}) = \frac{2L}{\pi d}\]</div>
<p>Rearranging this formula to solve for π:</p>
<div class="arithmatex">\[\pi \approx \frac{2L \times \text{number of throws}}{d \times \text{number of crossings}}\]</div>
<p>When <span class="arithmatex">\(L = d\)</span>, the formula simplifies to:</p>
<div class="arithmatex">\[\pi \approx \frac{2 \times \text{number of throws}}{\text{number of crossings}}\]</div>
<p>This provides another method to estimate π: randomly drop needles, count how many cross lines, and apply the formula.</p>
<h3 id="22-simulation-implementation">2.2 Simulation Implementation</h3>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
import time

def estimate_pi_buffon(num_needles, needle_length=1.0, line_distance=1.0):
    """
    Estimate π using Buffon's Needle experiment.

    Parameters:
    -----------
    num_needles : int
        Number of needles to drop
    needle_length : float
        Length of the needle
    line_distance : float
        Distance between parallel lines

    Returns:
    --------
    float
        Estimated value of π
    ndarray
        Array of needle positions (y-coordinate of center)
    ndarray
        Array of needle angles
    ndarray
        Boolean array indicating whether each needle crosses a line
    """
    # Generate random needle positions (y-coordinate of needle center)
    y_positions = np.random.uniform(0, line_distance, num_needles)

    # Generate random needle angles (with horizontal)
    angles = np.random.uniform(0, np.pi, num_needles)

    # Distance from each needle's center to nearest line
    distances_to_nearest_line = np.minimum(y_positions, line_distance - y_positions)

    # y-projection of each needle's half-length
    y_projections = (needle_length / 2) * np.sin(angles)

    # Determine which needles cross a line
    crosses_line = y_projections &gt;= distances_to_nearest_line

    # Count needles crossing lines
    count_crosses = np.sum(crosses_line)

    # Estimate π
    if count_crosses &gt; 0:
        pi_estimate = (2 * needle_length * num_needles) / (line_distance * count_crosses)
    else:
        pi_estimate = float('inf')

    return pi_estimate, y_positions, angles, crosses_line

def visualize_buffon_needle(y_positions, angles, crosses_line, pi_estimate, num_needles):
    """
    Visualize Buffon's Needle experiment.
    """
    plt.figure(figsize=(12, 8))

    # Draw parallel horizontal lines
    num_lines = 5
    for i in range(num_lines + 1):
        plt.axhline(y=i, color='black', linewidth=1)

    # Arbitrary x-positions for display
    x_positions = np.random.uniform(0.5, num_lines - 0.5, len(y_positions))
    needle_length = 1.0

    # Plot each needle
    for x0, y0, theta, cross in zip(x_positions, y_positions, angles, crosses_line):
        dy = (needle_length / 2) * np.sin(theta)
        dx = (needle_length / 2) * np.cos(theta)
        x1, y1 = x0 - dx, (y0 % 1) + int(x0) - dy
        x2, y2 = x0 + dx, (y0 % 1) + int(x0) + dy
        color = 'red' if cross else 'blue'
        plt.plot([x1, x2], [y1, y2], color=color, linewidth=1.5)

    plt.xlim(0, num_lines)
    plt.ylim(0, num_lines)
    plt.gca().set_aspect('equal')
    plt.title(f"Buffon's Needle Experiment\nNeedles: {num_needles}, "
              f"Crossings: {np.sum(crosses_line)}, π ≈ {pi_estimate:.6f}")
    plt.plot([], [], 'b-', label='No Crossing')
    plt.plot([], [], 'r-', label='Crossing Line')
    plt.legend()

    plt.savefig('buffon_needle.png')
    plt.show()

def analyze_convergence_buffon(max_needles=1000000, steps=20):
    """
    Analyze convergence of π estimate by Buffon's Needle.
    """
    needles_range = np.logspace(3, np.log10(max_needles), steps).astype(int)
    pi_estimates = np.zeros(steps)
    exec_times = np.zeros(steps)

    for i, n in enumerate(needles_range):
        start = time.time()
        pi_estimates[i], _, _, _ = estimate_pi_buffon(n)
        exec_times[i] = time.time() - start

    return needles_range, pi_estimates, exec_times

if __name__ == "__main__":
    # 1) Visualization for a small number of needles
    num_needles_visualization = 100
    pi_est, y_pos, ang, crosses = estimate_pi_buffon(num_needles_visualization)
    visualize_buffon_needle(y_pos, ang, crosses, pi_est, num_needles_visualization)

    # 2) Convergence analysis
    needles_range, pi_estimates, exec_times = analyze_convergence_buffon(max_needles=1000000)

    # Plot and save convergence figure
    plt.figure(figsize=(12, 6))

    plt.subplot(1, 2, 1)
    plt.semilogx(needles_range, pi_estimates, 'b-o', label='Estimate')
    plt.axhline(y=np.pi, color='r', linestyle='--', label='True π')
    plt.xlabel('Number of Needles')
    plt.ylabel('Estimated π')
    plt.title('Convergence of π Estimate (Buffon’s Needle)')
    plt.grid(True)
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.loglog(needles_range, np.abs(pi_estimates - np.pi), 'g-o')
    plt.xlabel('Number of Needles (log scale)')
    plt.ylabel('Absolute Error (log scale)')
    plt.title('Error vs. Number of Needles')
    plt.grid(True)

    plt.tight_layout()
    plt.savefig('buffon_convergence.png')
    plt.show()

    # 3) Print tabular results
    print("\nBuffon's Needle Method Results:")
    print(f"{'Needles':&lt;12}{'π Estimate':&lt;15}{'Error':&lt;15}{'Time (s)':&lt;10}")
    print("-" * 52)
    for n, est, t in zip(needles_range, pi_estimates, exec_times):
        print(f"{n:&lt;12}{est:&lt;15.8f}{abs(est - np.pi):&lt;15.8f}{t:&lt;10.6f}")
</code></pre>
<h3 id="23-visualization-and-analysis">2.3 Visualization and Analysis</h3>
<p>Buffon's Needle experiment offers a fascinating geometric approach to estimating π. The visualization shows needles dropped randomly on a surface with parallel lines, with red needles indicating those that cross lines and blue needles indicating those that do not.</p>
<p>While conceptually elegant, Buffon's Needle typically converges more slowly than the circle-based method. This is because the probability of a needle crossing a line is relatively small, leading to higher variance in the estimate. The error also decreases proportionally to <span class="arithmatex">\(1/\sqrt{n}\)</span>, but with a larger constant factor compared to the circle-based method.</p>
<hr/>
<h2 id="output-buffons-needle-experiment">Output: Buffon’s Needle Experiment</h2>
<p><img alt="alt text" src="../image-10.png"/></p>
<p><em>Figure 1: Buffon’s Needle experiment with 100 needles dropped on parallel lines spaced 1 unit apart.
Red segments cross a line, blue segments do not.<br/>
Estimated <span class="arithmatex">\(π ≈ 3.174603\)</span> (63 crossings out of 100 needles).</em></p>
<p><img alt="alt text" src="../image-11.png"/>
<em>Figure 2 (left): Estimated <span class="arithmatex">\(π\)</span> vs. number of needles (log scale). The dashed red line shows true <span class="arithmatex">\(π\)</span>.</em><br/>
<em>Figure 2 (right): Absolute error vs. number of needles (both axes log scale), demonstrating roughly <span class="arithmatex">\(O(1/\sqrt{n})\)</span> error decay.</em> </p>
<hr/>
<h2 id="terminal-output-buffons-needle-method-results">Terminal Output: Buffon’s Needle Method Results</h2>
<pre><code>Buffon's Needle Method Results:
Needles     π Estimate     Error          Time (s)
----------------------------------------------------
1000        3.13971743     0.00187523     0.000123
1438        3.16391639     0.02232374     0.000079
2069        3.25826772     0.11667506     0.000097
2976        3.13593256     0.00566009     0.000127
4281        3.13282108     0.00877158     0.000183
6158        3.24617818     0.10458552     0.000323
8858        3.16470168     0.02310903     0.000403
12742       3.13071253     0.01088012     0.000496
18329       3.17715375     0.03556110     0.000638
26366       3.13619603     0.00539663     0.000872
37926       3.15721124     0.01561858     0.002770
54555       3.14347450     0.00188185     0.001754
78475       3.13398562     0.00760703     0.002509
112883      3.13825410     0.00333855     0.003378
162377      3.15362505     0.01203239     0.004511
233572      3.14177338     0.00018072     0.006737
335981      3.14290258     0.00130992     0.008787
483293      3.14567082     0.00407816     0.011356
695192      3.13842264     0.00317001     0.014808
1000000     3.14327026     0.00167760     0.020506
</code></pre>
<p><em>Explanation:</em></p>
<ul>
<li><strong>Needles:</strong> Number of needle drops simulated.</li>
<li><strong>π Estimate:</strong> Monte Carlo estimate of π from those drops.</li>
<li><strong>Error:</strong> Absolute difference from the true value of π.</li>
<li><strong>Time (s):</strong> Computation time for each simulation, illustrating how runtime increases with sample size.</li>
</ul>
<h2 id="part-3-comparison-of-methods">Part 3: Comparison of Methods</h2>
<h3 id="31-implementation">3.1 Implementation</h3>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import time
from matplotlib.patches import Circle

# ——————————————————————————————————————
# Part 1: Circle-based Monte Carlo for π
# ——————————————————————————————————————

def estimate_pi_circle(num_points):
    x = np.random.uniform(-1, 1, num_points)
    y = np.random.uniform(-1, 1, num_points)
    inside = x**2 + y**2 &lt;= 1
    count_inside = inside.sum()
    pi_estimate = 4 * count_inside / num_points
    pts_in = np.column_stack((x[inside], y[inside]))
    pts_out = np.column_stack((x[~inside], y[~inside]))
    return pi_estimate, pts_in, pts_out

def visualize_circle_method(pts_in, pts_out, pi_est, num_points):
    plt.figure(figsize=(8,8))
    circle = Circle((0,0),1,fill=False,color='r',linewidth=2)
    plt.gca().add_patch(circle)
    plt.scatter(pts_in[:,0], pts_in[:,1], c='green', s=5, alpha=0.5, label='Inside')
    plt.scatter(pts_out[:,0], pts_out[:,1], c='red',   s=5, alpha=0.5, label='Outside')
    plt.plot([-1,1,1,-1,-1],[-1,-1,1,1,-1],'b-',linewidth=2)
    plt.axis('equal'); plt.grid(True)
    plt.title(f'Circle MC: {num_points} pts → π≈{pi_est:.6f} (err {abs(pi_est-np.pi):.6f})')
    plt.legend()
    plt.savefig('circle_monte_carlo.png')
    plt.show()

def analyze_convergence_circle(max_points=1_000_000, steps=20):
    ns = np.logspace(3, np.log10(max_points), steps).astype(int)
    pis = np.zeros(steps); times = np.zeros(steps)
    for i,n in enumerate(ns):
        t0 = time.time()
        pis[i],_,_ = estimate_pi_circle(n)
        times[i] = time.time() - t0
    return ns, pis, times

# ——————————————————————————————————————
# Part 2: Buffon’s Needle for π
# ——————————————————————————————————————

def estimate_pi_buffon(num_needles, needle_length=1.0, line_dist=1.0):
    y = np.random.uniform(0, line_dist, num_needles)
    theta = np.random.uniform(0, np.pi, num_needles)
    d_min = np.minimum(y, line_dist - y)
    proj = (needle_length/2) * np.sin(theta)
    crosses = proj &gt;= d_min
    c = crosses.sum()
    pi_est = (2 * needle_length * num_needles) / (line_dist * c) if c&gt;0 else np.nan
    return pi_est, y, theta, crosses

def visualize_buffon_needle(y, theta, crosses, pi_est, num_needles):
    plt.figure(figsize=(8,6))
    # draw lines
    for k in range(6):
        plt.axhline(k, color='black', lw=1)
    x = np.random.uniform(0.5,4.5,len(y))
    for xi, yi, th, cr in zip(x, y, theta, crosses):
        dy = (0.5)*np.sin(th)
        dx = (0.5)*np.cos(th)
        y0 = (yi % 1) + int(xi)
        x1,y1 = xi-dx, y0-dy
        x2,y2 = xi+dx, y0+dy
        plt.plot([x1,x2],[y1,y2], c='red' if cr else 'blue', lw=1.5)
    plt.title(f"Buffon’s Needle: {num_needles} drops → π≈{pi_est:.6f}")
    plt.xlim(0,5); plt.ylim(0,5); plt.gca().set_aspect('equal')
    plt.savefig('buffon_needle.png')
    plt.show()

def analyze_convergence_buffon(max_needles=1_000_000, steps=20):
    ns = np.logspace(3, np.log10(max_needles), steps).astype(int)
    pis = np.zeros(steps); times = np.zeros(steps)
    for i,n in enumerate(ns):
        t0 = time.time()
        pis[i],_,_,_ = estimate_pi_buffon(n)
        times[i] = time.time() - t0
    return ns, pis, times

# ——————————————————————————————————————
# Part 3: Comparison
# ——————————————————————————————————————

def compare_methods(max_samples=500_000, steps=15):
    ns = np.logspace(3, np.log10(max_samples), steps).astype(int)
    c_pi = np.zeros(steps); c_err = np.zeros(steps); c_t = np.zeros(steps)
    b_pi = np.zeros(steps); b_err = np.zeros(steps); b_t = np.zeros(steps)

    for i,n in enumerate(ns):
        t0=time.time(); c_pi[i],_,_ = estimate_pi_circle(n); c_t[i]=time.time()-t0
        c_err[i]=abs(c_pi[i]-np.pi)
        t0=time.time(); b_pi[i],_,_,_= estimate_pi_buffon(n); b_t[i]=time.time()-t0
        b_err[i]=abs(b_pi[i]-np.pi)

    # Plot
    plt.figure(figsize=(12,10))
    plt.subplot(2,2,1)
    plt.semilogx(ns,c_pi,'b-o',label='Circle')
    plt.semilogx(ns,b_pi,'g-o',label='Buffon')
    plt.axhline(np.pi,color='r',ls='--',label='True π')
    plt.title("π Estimate"); plt.legend(); plt.grid(True)

    plt.subplot(2,2,2)
    plt.loglog(ns,c_err,'b-o',label='Circle')
    plt.loglog(ns,b_err,'g-o',label='Buffon')
    ref=c_err[0]*np.sqrt(ns[0]/ns)
    plt.loglog(ns,ref,'k--',label='1/√n')
    plt.title("Error vs n"); plt.legend(); plt.grid(True)

    plt.subplot(2,2,3)
    plt.loglog(ns,c_t,'b-o',label='Circle')
    plt.loglog(ns,b_t,'g-o',label='Buffon')
    plt.title("Time vs n"); plt.legend(); plt.grid(True)

    plt.subplot(2,2,4)
    plt.loglog(c_t,c_err,'b-o',label='Circle')
    plt.loglog(b_t,b_err,'g-o',label='Buffon')
    plt.title("Error vs Time"); plt.legend(); plt.grid(True)

    plt.tight_layout()
    plt.savefig('method_comparison.png')
    plt.show()

    # Print table
    print("\nSample   Circle π     Err       Time(s)    Buffon π    Err")
    print("----------------------------------------------------------------")
    for n,cp,ce,ct,bp,be in zip(ns,c_pi,c_err,c_t,b_pi,b_err):
        print(f"{n:&lt;8}{cp:&gt;8.6f}{ce:&gt;10.6f}{ct:&gt;10.4f}{bp:&gt;10.6f}{be:&gt;10.6f}")

# ——————————————————————————————————————
# Main
# ——————————————————————————————————————

if __name__ == "__main__":
    sns.set()
    # 1. Circle
    pi_v, pin, pout = estimate_pi_circle(5_000)
    visualize_circle_method(pin, pout, pi_v, 5_000)
    nc, pc, tc = analyze_convergence_circle()
    plt.figure(figsize=(10,4))
    plt.subplot(1,2,1)
    plt.semilogx(nc,pc,'b-o'); plt.axhline(np.pi,color='r',ls='--'); plt.title("Circle Convergence"); plt.grid(True)
    plt.subplot(1,2,2)
    plt.loglog(nc,abs(pc-np.pi),'g-o'); plt.title("Error vs pts"); plt.grid(True)
    plt.tight_layout()
    plt.savefig('circle_convergence.png')
    plt.show()

    # 2. Buffon
    pi_b, yb, thb, crb = estimate_pi_buffon(100)
    visualize_buffon_needle(yb, thb, crb, pi_b, 100)
    nb, pb, tb = analyze_convergence_buffon()
    plt.figure(figsize=(10,4))
    plt.subplot(1,2,1)
    plt.semilogx(nb,pb,'b-o'); plt.axhline(np.pi,color='r',ls='--'); plt.title("Buffon Convergence"); plt.grid(True)
    plt.subplot(1,2,2)
    plt.loglog(nb,abs(pb-np.pi),'g-o'); plt.title("Error vs needles"); plt.grid(True)
    plt.tight_layout()
    plt.savefig('buffon_convergence.png')
    plt.show()

    # 3. Comparison
    print("\nComparing methods:")
    compare_methods()
</code></pre>
<h3 id="32-comparative-analysis">3.2 Comparative Analysis</h3>
<p>Both Monte Carlo methods converge to π as the number of samples increases, but they differ in efficiency and convergence rate:</p>
<ol>
<li>
<p><strong>Accuracy and Convergence</strong>:                                                </p>
<ul>
<li>Both methods exhibit the expected <span class="arithmatex">\(O(1/\sqrt{n})\)</span> convergence rate, typical of Monte Carlo methods.                                          </li>
<li>The circle-based method generally provides more accurate estimates with fewer samples due to its lower variance.                             </li>
<li>Buffon's Needle shows higher variability, especially at lower sample counts.                                                                 </li>
</ul>
</li>
<li>
<p><strong>Computational Efficiency</strong>:                                                </p>
<ul>
<li>The circle-based method is computationally more efficient, requiring simpler calculations per sample.                                        </li>
<li>Buffon's Needle involves more complex geometry calculations, leading to slightly longer execution times.                                     </li>
</ul>
</li>
<li>
<p><strong>Practical Considerations</strong>:                                                </p>
<ul>
<li>The circle-based method is easier to implement and visualize, making it more suitable for educational purposes.                                                              </li>
<li>Buffon's Needle provides a fascinating historical connection and demonstrates how physical experiments can be used to estimate mathematical constants.                                                     </li>
</ul>
</li>
</ol>
<hr/>
<h2 id="output">Output</h2>
<h3 id="circlebased-monte-carlo-method">Circle‐Based Monte Carlo Method</h3>
<p><img alt="alt text" src="../image-12.png"/></p>
<p><em>Figure 1: Scatter plot of 5 000 random points in the square <span class="arithmatex">\([-1,1]^2\)</span>.
Green points lie inside the unit circle, red points lie outside.
Estimated <span class="arithmatex">\(π ≈ 3.126400\)</span> (error ≈ 0.015193).</em></p>
<p><img alt="alt text" src="../image-13.png"/></p>
<p><em>Figure 2 (left): <span class="arithmatex">\(π\)</span> estimates vs. number of points (log scale). The dashed red line marks true <span class="arithmatex">\(π\)</span>.</em>
<em>Figure 2 (right): Absolute error vs. number of points (both axes log–log), illustrating the <span class="arithmatex">\(O(1/\sqrt{n})\)</span> decline.</em></p>
<hr/>
<h3 id="buffons-needle-experiment">Buffon’s Needle Experiment</h3>
<p><img alt="alt text" src="../image-14.png"/></p>
<p><em>Figure 3: 100 needles dropped onto parallel lines.
Red needles cross a line; blue do not.
Estimated <span class="arithmatex">\(π ≈ 2.985075\)</span> <span class="arithmatex">\((error ≈ 0.156518)\)</span>.</em></p>
<p><img alt="alt text" src="../image-15.png"/>
<em>Figure 4 (left): π estimates vs. number of needles (log scale) converge slowly toward π.</em>
<em>Figure 4 (right): Absolute error vs. number of needles (log–log), again showing roughly <span class="arithmatex">\(O(1/\sqrt{n})\)</span> behavior.</em></p>
<hr/>
<h3 id="comparison-of-methods">Comparison of Methods</h3>
<p><img alt="alt text" src="../image-17.png"/> </p>
<p><em>Figure 5 (top‐left): Estimated π vs. sample size for both methods.</em>
<em>Figure 5 (top‐right): Error vs. sample size with a 1/√n reference (dashed).</em>
<em>Figure 5 (bottom‐left): Execution time vs. sample size.</em>
<em>Figure 5 (bottom‐right): Error vs. computation time—showing the circle method’s superior efficiency and accuracy.</em></p>
<hr/>
<h2 id="terminal-output-comparison-of-methods">Terminal Output: Comparison of Methods</h2>
<pre><code>Comparing methods:

Sample   Circle π     Err       Time(s)    Buffon π    Err
----------------------------------------------------------------
1000     3.176000     0.034407   0.0002     3.225806    0.084214
1558     3.160462     0.018869   0.0002     3.182840    0.041247
2429     3.170029     0.028436   0.0003     3.122108    0.019485
3787     3.082123     0.059470   0.0004     3.174350    0.032758
5903     3.127901     0.013692   0.0005     3.116684    0.024908
9202     3.153662     0.012070   0.0007     3.170917    0.029324
14345    3.154549     0.012956   0.0010     3.147214    0.005621
22360    3.132021     0.009571   0.0016     3.162659    0.021066
34855    3.140324     0.001268   0.0024     3.141081    0.000512
54331    3.141190     0.000403   0.0032     3.156669    0.015076
84690    3.140300     0.001293   0.0050     3.142719    0.001127
132013   3.141781     0.000189   0.0070     3.137899    0.003693
205779   3.140865     0.000728   0.0100     3.147816    0.006223
320764   3.143657     0.002064   0.0116     3.143589    0.001997
499999   3.142790     0.001198   0.0150     3.133307    0.008286
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><strong>Sample:</strong> Number of random samples used for each method (points for circle, needles for Buffon).</li>
<li><strong>Circle π:</strong> Estimated <span class="arithmatex">\(π\)</span> from the circle‐based Monte Carlo method.</li>
<li><strong>Err (Circle):</strong> Absolute error of the circle estimate relative to true <span class="arithmatex">\(π\)</span>.</li>
<li><strong>Time(s):</strong> Computation time for each simulation (in seconds).</li>
<li><strong>Buffon π:</strong> Estimated <span class="arithmatex">\(π\)</span> from Buffon’s Needle experiment.</li>
<li><strong>Err (Buffon):</strong> Absolute error of the Buffon estimate relative to true <span class="arithmatex">\(π\)</span>.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Monte Carlo methods offer elegant and intuitive approaches to estimating π, demonstrating the power of probabilistic techniques in numerical computation. The circle-based method provides a more efficient and accurate estimate with fewer samples, while Buffon's Needle offers historical and educational value despite its slower convergence.</p>
<p>These methods highlight the versatility of Monte Carlo simulation across various domains, from mathematics and physics to finance and computer science. They also provide insights into the trade-offs between different simulation approaches and the relationship between sample size and estimation accuracy.</p>
<p>While modern computational methods can calculate π to much higher precision, Monte Carlo approaches remain valuable for educational purposes and as foundational examples of probabilistic problem-solving.</p>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../Problem_1/" title="Exploring the Central Limit Theorem through Simulations"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../7%20Measurements/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../7%20Measurements/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
