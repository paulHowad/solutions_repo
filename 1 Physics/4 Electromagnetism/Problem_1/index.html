<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Problem 1 - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Problem 1";
        var mkdocs_page_input_path = "1 Physics/4 Electromagnetism/Problem_1.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Investigating the Dynamics of a Forced Damped Pendulum</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">4 Electromagnetism</a>
<ul class="current">
<li class="toctree-l2 current"><a class="reference internal current" href="#">Problem 1</a>
<ul class="current">
<li class="toctree-l3"><a class="reference internal" href="#1-applications-of-the-lorentz-force">1. Applications of the Lorentz Force</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#particle-accelerators">Particle Accelerators</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#mass-spectrometry">Mass Spectrometry</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#plasma-confinement">Plasma Confinement</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#other-applications">Other Applications</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#2-simulation-implementation">2. Simulation Implementation</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#3-simulation-scenarios">3. Simulation Scenarios</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#scenario-1-uniform-magnetic-field">Scenario 1: Uniform Magnetic Field</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#scenario-2-combined-electric-and-magnetic-fields">Scenario 2: Combined Electric and Magnetic Fields</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#scenario-3-crossed-electric-and-magnetic-fields">Scenario 3: Crossed Electric and Magnetic Fields</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#scenario-4-parameter-exploration">Scenario 4: Parameter Exploration</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#scenario-5-magnetic-mirror">Scenario 5: Magnetic Mirror</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#simulation-visualizations">Simulation Visualizations</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#4-applications-to-real-systems">4. Applications to Real Systems</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#cyclotron">Cyclotron</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#mass-spectrometer">Mass Spectrometer</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#hall-effect-thruster">Hall Effect Thruster</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#5-extensions-and-advanced-scenarios">5. Extensions and Advanced Scenarios</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#non-uniform-fields">Non-Uniform Fields</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#time-varying-fields">Time-Varying Fields</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#7-practical-applications-discussion">7. Practical Applications Discussion</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#particle-accelerators_1">Particle Accelerators</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#plasma-confinement_1">Plasma Confinement</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#mass-spectrometry_1">Mass Spectrometry</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#space-propulsion">Space Propulsion</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#8-extensions-for-future-work">8. Extensions for Future Work</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#9-conclusion">9. Conclusion</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Circuits</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../5%20Circuits/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">6 Statistics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">4 Electromagnetism</li>
<li class="breadcrumb-item active">Problem 1</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="problem-1">Problem 1</h1>
<p>Introduction</p>
<p>The Lorentz force is a fundamental concept in electromagnetism that describes the force experienced by a charged particle moving through electric and magnetic fields. Mathematically, it is expressed as:</p>
<div class="arithmatex">\[\vec{F} = q\vec{E} + q\vec{v} \times \vec{B}\]</div>
<p>Where:
- <span class="arithmatex">\(\vec{F}\)</span> is the force vector
- <span class="arithmatex">\(q\)</span> is the charge of the particle
- <span class="arithmatex">\(\vec{E}\)</span> is the electric field vector
- <span class="arithmatex">\(\vec{v}\)</span> is the velocity vector of the particle
- <span class="arithmatex">\(\vec{B}\)</span> is the magnetic field vector</p>
<p>This simulation explores the behavior of charged particles under various field configurations, demonstrating key physical phenomena and applications.</p>
<h2 id="1-applications-of-the-lorentz-force">1. Applications of the Lorentz Force</h2>
<p>The Lorentz force is foundational to many technological applications and natural phenomena:</p>
<h3 id="particle-accelerators">Particle Accelerators</h3>
<ul>
<li><strong>Cyclotrons</strong>: Use a combination of electric and magnetic fields to accelerate charged particles in a spiral path</li>
<li><strong>Synchrotrons</strong>: Employ time-varying magnetic fields to keep particles in a circular path while accelerating them</li>
<li><strong>Linear Accelerators</strong>: Use alternating electric fields to accelerate particles in a straight line</li>
</ul>
<h3 id="mass-spectrometry">Mass Spectrometry</h3>
<ul>
<li>Uses magnetic fields to separate ions based on their mass-to-charge ratio</li>
<li>The radius of curvature in a uniform magnetic field depends on particle mass, allowing for precise separation</li>
</ul>
<h3 id="plasma-confinement">Plasma Confinement</h3>
<ul>
<li><strong>Tokamaks</strong>: Use magnetic fields to confine plasma for nuclear fusion</li>
<li><strong>Magnetic Mirrors</strong>: Trap charged particles using magnetic field gradients</li>
</ul>
<h3 id="other-applications">Other Applications</h3>
<ul>
<li><strong>Hall Effect Thrusters</strong>: Use crossed electric and magnetic fields for spacecraft propulsion</li>
<li><strong>Magnetohydrodynamic Generators</strong>: Convert kinetic energy directly to electricity</li>
<li><strong>Electron Microscopes</strong>: Use magnetic fields to focus electron beams</li>
</ul>
<h2 id="2-simulation-implementation">2. Simulation Implementation</h2>
<p>We'll use Python to create a numerical simulation of charged particle motion under the influence of the Lorentz force.</p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from mpl_toolkits.mplot3d import Axes3D  # registers 3D projection
from scipy.integrate import solve_ivp

class LorentzForceSimulator:
    def __init__(self, q=1.0, m=1.0):
        self.q, self.m = q, m
        self.results = None

    def _lorentz_force(self, t, state, E_func, B_func):
        x, y, z, vx, vy, vz = state
        v = np.array([vx, vy, vz])
        E = E_func(np.array([x, y, z]), t)
        B = B_func(np.array([x, y, z]), t)
        a = (self.q / self.m) * (E + np.cross(v, B))
        return [vx, vy, vz, a[0], a[1], a[2]]

    def simulate(self, init, t_span, t_eval, E_func, B_func):
        sol = solve_ivp(
            lambda t, y: self._lorentz_force(t, y, E_func, B_func),
            t_span, init, t_eval=t_eval,
            method='RK45', rtol=1e-8, atol=1e-8
        )
        self.results = sol
        return sol

    def plot_3d(self, title="3D Trajectory"):
        if self.results is None:
            raise RuntimeError("No results—call simulate() first.")
        x, y, z = self.results.y[0], self.results.y[1], self.results.y[2]
        fig = plt.figure(figsize=(8, 6))
        ax = fig.add_subplot(111, projection='3d')
        # default blue line
        ax.plot(x, y, z, '-', lw=2, label='Path')
        ax.scatter(x[0], y[0], z[0], c='g', s=80, label='Start')
        ax.scatter(x[-1], y[-1], z[-1], c='r', s=80, label='End')
        ax.set_title(title)
        ax.set_xlabel('X'); ax.set_ylabel('Y'); ax.set_zlabel('Z')
        ax.legend(loc='upper left')
        plt.tight_layout()
        return fig, ax

    def plot_2d(self, plane='xy', title="2D Projection"):
        if self.results is None:
            raise RuntimeError("No results—call simulate() first.")
        x, y, z = self.results.y[0], self.results.y[1], self.results.y[2]
        fig, ax = plt.subplots(figsize=(6, 5))
        if plane == 'xy':
            ax.plot(x, y, '-', lw=2)  # default blue
            ax.scatter(x[0], y[0], c='g', s=80, label='Start')
            ax.scatter(x[-1], y[-1], c='r', s=80, label='End')
            ax.set_xlabel('X'); ax.set_ylabel('Y')
        elif plane == 'xz':
            ax.plot(x, z, '-', lw=2)
            ax.scatter(x[0], z[0], c='g', s=80, label='Start')
            ax.scatter(x[-1], z[-1], c='r', s=80, label='End')
            ax.set_xlabel('X'); ax.set_ylabel('Z')
        elif plane == 'yz':
            ax.plot(y, z, '-', lw=2)
            ax.scatter(y[0], z[0], c='g', s=80, label='Start')
            ax.scatter(y[-1], z[-1], c='r', s=80, label='End')
            ax.set_xlabel('Y'); ax.set_ylabel('Z')
        else:
            raise ValueError("plane must be 'xy','xz' or 'yz'")
        ax.set_title(f"{title} — {plane.upper()}")
        ax.legend()
        ax.grid(True, ls='--', alpha=0.5)
        plt.tight_layout()
        return fig, ax

    def animate_xy(self, interval=50):
        if self.results is None:
            raise RuntimeError("No results—call simulate() first.")
        x, y = self.results.y[0], self.results.y[1]
        fig, ax = plt.subplots(figsize=(6, 6))
        line, = ax.plot([], [], 'b-', lw=2)
        pt,   = ax.plot([], [], 'ro', ms=6)
        ax.set_xlim(x.min()*1.1, x.max()*1.1)
        ax.set_ylim(y.min()*1.1, y.max()*1.1)
        ax.set_xlabel('X'); ax.set_ylabel('Y')
        ax.set_title("Animation — XY Plane")

        def init():
            line.set_data([], []); pt.set_data([], [])
            return line, pt

        def anim(i):
            line.set_data(x[:i], y[:i])
            pt.set_data(x[i], y[i])
            return line, pt

        anim_obj = FuncAnimation(fig, anim, init_func=init,
                                 frames=len(x), interval=interval, blit=True)
        return anim_obj, fig, ax

def main():
    t_span = (0, 20)
    t_eval = np.linspace(0, 20, 1000)

    scenarios = [
        ("Scenario 1: Uniform B-Field",
         [0, 0, 0, 1, 1, 0],
         lambda pos, t: np.zeros(3),
         lambda pos, t: np.array([0, 0, 1]),
         'xy', "Circular Motion in Uniform B-Field"),
        ("Scenario 2: Combined E &amp; B",
         [0, 0, 0, 0, 0, 0],
         lambda pos, t: np.array([0.5, 0, 0]),
         lambda pos, t: np.array([0, 0, 1]),
         'xy', "Cycloid Drift in Combined Fields"),
        ("Scenario 3: Crossed E &amp; B",
         [0, 0, 0, 0, 0, 0],
         lambda pos, t: np.array([0, 1, 0]),
         lambda pos, t: np.array([0, 0, 1]),
         'xy', "E×B Drift Motion"),
        ("Scenario 4: Helical Motion",
         [0, 0, 0, 1, 0, 1],
         lambda pos, t: np.zeros(3),
         lambda pos, t: np.array([0, 0, 1]),
         'xy', "Helical Motion (XY)"),
        ("Scenario 5: Magnetic Mirror",
         [0, 0, 0, 0.5, 0.5, 0.5],
         lambda pos, t: np.zeros(3),
         lambda pos, t: np.array([0, 0, 1 + 0.1*pos[2]**2]),
         'xz', "Mirror Bounce (XZ)"),
    ]

    for title, init, Ef, Bf, plane, p2title in scenarios:
        print("\n" + title)
        sim = LorentzForceSimulator()
        sim.simulate(init, t_span, t_eval, Ef, Bf)
        sim.plot_3d(title)
        plt.show()      # close this window to continue
        sim.plot_2d(plane, p2title)
        plt.show()

    # Final animation
    print("\nFinal Animation (Uniform B-Field Cyclotron)")
    sim = LorentzForceSimulator()
    sim.simulate([0, 0, 0, 1, 1, 0], (0, 10), np.linspace(0, 10, 200),
                 lambda pos, t: np.zeros(3),
                 lambda pos, t: np.array([0, 0, 1]))
    anim, fig, ax = sim.animate_xy(interval=50)
    plt.show()       # runs until you close the animation window

    print("\nAll done — thanks for watching!")

if __name__ == "__main__":
    main()
</code></pre>
<h2 id="3-simulation-scenarios">3. Simulation Scenarios</h2>
<p>Let's explore different field configurations and their effects on particle motion.</p>
<h3 id="scenario-1-uniform-magnetic-field">Scenario 1: Uniform Magnetic Field</h3>
<p>In a uniform magnetic field with no electric field, a charged particle will move in a circular path perpendicular to the magnetic field. If the particle has a velocity component parallel to the field, it will follow a helical path.</p>
<pre><code class="language-python"># Scenario 1: Uniform Magnetic Field
simulator = LorentzForceSimulator(q=1.0, m=1.0)

# Initial conditions: position (0,0,0) and velocity (1,1,0)
initial_state = [0, 0, 0, 1, 1, 0]
t_span = (0, 20)
t_eval = np.linspace(*t_span, 1000)

# Magnetic field in z-direction
B_field = lambda pos, t: np.array([0, 0, 1])
E_field = lambda pos, t: np.array([0, 0, 0])  # No electric field

# Run simulation
result = simulator.simulate(initial_state, t_span, t_eval, E_field, B_field)

# Plot trajectory
fig_3d, ax_3d = simulator.plot_trajectory_3d(title="Particle in Uniform Magnetic Field")
plt.close(fig_3d)  # We'll save it but not display immediately

# Plot 2D projections
fig_xy, ax_xy = simulator.plot_trajectory_2d(plane='xy', title="Circular Motion in Uniform B-field")
plt.close(fig_xy)

# Calculate and display the Larmor radius
v_perp = np.sqrt(initial_state[3]**2 + initial_state[4]**2)  # perpendicular velocity component
B_magnitude = np.linalg.norm(B_field(np.zeros(3), 0))
larmor_radius = simulator.m * v_perp / (simulator.q * B_magnitude)
print(f"Larmor radius: {larmor_radius:.4f}")
</code></pre>
<p>In this scenario, we observe:
- The particle follows a circular path in the <span class="arithmatex">\(xy-plane\)</span>
- The Larmor radius (cyclotron radius) is given by <span class="arithmatex">\(r = mv⊥/(qB)\)</span>
- The frequency of rotation (cyclotron frequency) is <span class="arithmatex">\(ω = qB/m\)</span></p>
<h3 id="scenario-2-combined-electric-and-magnetic-fields">Scenario 2: Combined Electric and Magnetic Fields</h3>
<p>When both electric and magnetic fields are present, the particle motion becomes more complex.</p>
<pre><code class="language-python"># Scenario 2: Combined Electric and Magnetic Fields
simulator = LorentzForceSimulator(q=1.0, m=1.0)

# Initial conditions: position (0,0,0) and velocity (0,0,0)
initial_state = [0, 0, 0, 0, 0, 0]
t_span = (0, 20)
t_eval = np.linspace(*t_span, 1000)

# Fields: B in z-direction, E in x-direction
B_field = lambda pos, t: np.array([0, 0, 1])
E_field = lambda pos, t: np.array([0.5, 0, 0])

# Run simulation
result = simulator.simulate(initial_state, t_span, t_eval, E_field, B_field)

# Plot trajectory
fig_3d, ax_3d = simulator.plot_trajectory_3d(title="Particle in Combined E and B Fields")
plt.close(fig_3d)

fig_xy, ax_xy = simulator.plot_trajectory_2d(plane='xy', title="Motion in Combined Fields")
plt.close(fig_xy)
</code></pre>
<p>In combined fields, the particle exhibits:
- Initial acceleration due to the electric field
- Cycloid-like motion as the magnetic field curves the trajectory
- The combination creates a drift in the E×B direction</p>
<h3 id="scenario-3-crossed-electric-and-magnetic-fields">Scenario 3: Crossed Electric and Magnetic Fields</h3>
<p>When E and B fields are perpendicular to each other, we observe E×B drift.</p>
<pre><code class="language-python"># Scenario 3: Crossed E and B Fields
simulator = LorentzForceSimulator(q=1.0, m=1.0)

# Initial conditions: position (0,0,0) and velocity (0,0,0)
initial_state = [0, 0, 0, 0, 0, 0]
t_span = (0, 20)
t_eval = np.linspace(*t_span, 1000)

# Crossed fields: E in y-direction, B in z-direction
B_field = lambda pos, t: np.array([0, 0, 1])
E_field = lambda pos, t: np.array([0, 1, 0])

# Run simulation
result = simulator.simulate(initial_state, t_span, t_eval, E_field, B_field)

# Plot trajectory
fig_3d, ax_3d = simulator.plot_trajectory_3d(title="E×B Drift in Crossed Fields")
plt.close(fig_3d)

fig_xy, ax_xy = simulator.plot_trajectory_2d(plane='xy', title="E×B Drift Motion")
plt.close(fig_xy)

# Calculate the drift velocity
E = np.array([0, 1, 0])
B = np.array([0, 0, 1])
B_magnitude = np.linalg.norm(B)
drift_velocity = np.cross(E, B) / (B_magnitude**2)
print(f"E×B Drift velocity: {drift_velocity}")
</code></pre>
<p>In crossed fields, we observe:
- <span class="arithmatex">\(E×B\)</span> drift with velocity <span class="arithmatex">\(v_drift = E×B/|B|²\)</span>
- This drift is independent of particle charge and mass
- The particle moves perpendicular to both <span class="arithmatex">\(E\)</span> and <span class="arithmatex">\(B\)</span> fields</p>
<h3 id="scenario-4-parameter-exploration">Scenario 4: Parameter Exploration</h3>
<p>Let's explore how different parameters affect the particle's motion.</p>
<pre><code class="language-python"># Scenario 4: Parameter Exploration
# Varying B-field strength
B_strengths = [0.5, 1.0, 2.0]
results_B = []

for B_strength in B_strengths:
    simulator = LorentzForceSimulator(q=1.0, m=1.0)

    # Initial conditions: position (0,0,0) and velocity (1,0,0)
    initial_state = [0, 0, 0, 1, 0, 0]
    t_span = (0, 10)
    t_eval = np.linspace(*t_span, 500)

    # B-field with varying strength
    B_field = lambda pos, t, B=B_strength: np.array([0, 0, B])
    E_field = lambda pos, t: np.array([0, 0, 0])

    # Run simulation
    result = simulator.simulate(initial_state, t_span, t_eval, E_field, B_field)
    results_B.append((simulator, result))

# Varying charge-to-mass ratio
q_m_ratios = [0.5, 1.0, 2.0]
results_qm = []

for q_m in q_m_ratios:
    simulator = LorentzForceSimulator(q=q_m, m=1.0)

    # Initial conditions: position (0,0,0) and velocity (1,0,0)
    initial_state = [0, 0, 0, 1, 0, 0]
    t_span = (0, 10)
    t_eval = np.linspace(*t_span, 500)

    # Uniform magnetic field
    B_field = lambda pos, t: np.array([0, 0, 1])
    E_field = lambda pos, t: np.array([0, 0, 0])

    # Run simulation
    result = simulator.simulate(initial_state, t_span, t_eval, E_field, B_field)
    results_qm.append((simulator, result))

# Varying initial velocities
velocities = [(1, 0, 0), (0, 1, 0), (1, 1, 0)]
results_v = []

for vx, vy, vz in velocities:
    simulator = LorentzForceSimulator(q=1.0, m=1.0)

    # Initial conditions with varying velocity
    initial_state = [0, 0, 0, vx, vy, vz]
    t_span = (0, 10)
    t_eval = np.linspace(*t_span, 500)

    # Uniform magnetic field
    B_field = lambda pos, t: np.array([0, 0, 1])
    E_field = lambda pos, t: np.array([0, 0, 0])

    # Run simulation
    result = simulator.simulate(initial_state, t_span, t_eval, E_field, B_field)
    results_v.append((simulator, result))

# Plot comparative results
fig, axes = plt.subplots(1, 3, figsize=(18, 5))

# Plot for varying B-field
for i, (simulator, result) in enumerate(results_B):
    axes[0].plot(result.y[0], result.y[1], label=f"B = {B_strengths[i]}")
axes[0].set_xlabel('X')
axes[0].set_ylabel('Y')
axes[0].set_title('Effect of B-field Strength')
axes[0].grid(True)
axes[0].legend()

# Plot for varying q/m ratio
for i, (simulator, result) in enumerate(results_qm):
    axes[1].plot(result.y[0], result.y[1], label=f"q/m = {q_m_ratios[i]}")
axes[1].set_xlabel('X')
axes[1].set_ylabel('Y')
axes[1].set_title('Effect of Charge-to-Mass Ratio')
axes[1].grid(True)
axes[1].legend()

# Plot for varying initial velocity
for i, (simulator, result) in enumerate(results_v):
    axes[2].plot(result.y[0], result.y[1], label=f"v = {velocities[i]}")
axes[2].set_xlabel('X')
axes[2].set_ylabel('Y')
axes[2].set_title('Effect of Initial Velocity')
axes[2].grid(True)
axes[2].legend()

plt.tight_layout()
plt.close(fig)
</code></pre>
<h3 id="scenario-5-magnetic-mirror">Scenario 5: Magnetic Mirror</h3>
<p>In a non‐uniform magnetic field that increases along the <span class="arithmatex">\(z\)</span>–axis, particles can “mirror” — i.e.\ bounce back when they encounter regions of stronger <span class="arithmatex">\(B\)</span>.</p>
<pre><code class="language-python"># Scenario 5: Magnetic Mirror
simulator = LorentzForceSimulator(q=1.0, m=1.0)

# Initial conditions: position (0,0,0), velocity with both perpendicular and parallel components
initial_state = [0, 0, 0, 0.5, 0.5, 1.0]
t_span = (0, 30)
t_eval = np.linspace(*t_span, 2000)

# No electric field
E_field = lambda pos, t: np.zeros(3)

# Magnetic mirror: B increases as z^2
def B_mirror(pos, t, B0=1.0, k=0.1):
    z = pos[2]
    return np.array([0, 0, B0 * (1 + k*z**2)])

# Run simulation
result = simulator.simulate(initial_state, t_span, t_eval, E_field, B_mirror)

# Plot 3D trajectory
fig_3d, ax_3d = simulator.plot_3d(title="Magnetic Mirror: 3D Trajectory")
plt.show()

# Plot XZ projection to highlight bouncing
fig_xz, ax_xz = simulator.plot_2d(plane='xz', title="Magnetic Mirror: XZ Projection")
plt.show()
</code></pre>
<p><strong>What you’ll observe:</strong><br/>
- As the particle moves along <span class="arithmatex">\(+z\)</span>, the local field strength grows, converting parallel kinetic energy into gyration.<br/>
- Once the parallel velocity is reduced to zero, the particle reverses direction, “mirroring” back toward <span class="arithmatex">\(z=0\)</span>.<br/>
- The turning points occur where <span class="arithmatex">\(v_\parallel^2 / v_\perp^2 = B(z)/B(0)\)</span>, illustrating the mirror ratio effect.</p>
<h3 id="simulation-visualizations">Simulation Visualizations</h3>
<p>Here are the key visualizations from our simulations:</p>
<p><img alt="alt text" src="../image.png"/>
<em>Figure 1: 3D trajectory of a charged particle in a uniform magnetic field showing circular motion.</em>
<img alt="alt text" src="../image-1.png"/>
<em>Figure 2: 2D projection showing circular motion in the XY plane.</em></p>
<p>!
<em>Figure 3: 3D trajectory under combined electric and magnetic fields showing cycloid drift.</em></p>
<p><img alt="alt text" src="../image-2.png"/>
<em>Figure 4: 2D projection of cycloid-like drift in combined fields.</em>
<img alt="alt text" src="../image-3.png"/>
<em>Figure 5: 3D trajectory in crossed electric and magnetic fields showing E×B drift.</em></p>
<p><img alt="alt text" src="../image-4.png"/>
<em>Figure 7: 3D helical trajectory when the particle has a velocity component parallel to the magnetic field.</em></p>
<p><img alt="alt text" src="../image-5.png"/>
<em>Figure 8: 2D projection of helical motion in the XY plane.</em></p>
<p><img alt="alt text" src="../image-6.png"/>
<em>Figure 9: 3D trajectory in a magnetic mirror configuration showing the particle bouncing.</em></p>
<p><img alt="alt text" src="../image-7.png"/>
<em>Figure 10: XZ projection highlighting the mirror-bounce points.</em></p>
<h2 id="4-applications-to-real-systems">4. Applications to Real Systems</h2>
<h3 id="cyclotron">Cyclotron</h3>
<p>The cyclotron is a type of particle accelerator that uses a uniform magnetic field to bend charged particles in a circular path and an oscillating electric field to accelerate them. Our simulation of uniform magnetic fields demonstrates the fundamental principle behind cyclotrons:</p>
<pre><code class="language-python"># Cyclotron simulation
def cyclotron_E_field(position, t, frequency=1.0, E0=0.1):
    """
    Time-varying electric field for cyclotron acceleration
    Oscillates at the cyclotron frequency
    """
    # E-field alternates to accelerate particles at the right phase
    if np.sin(2 * np.pi * frequency * t) &gt; 0:
        return np.array([E0, 0, 0])
    else:
        return np.array([-E0, 0, 0])

simulator = LorentzForceSimulator(q=1.0, m=1.0)

# Initial conditions: position near origin with small velocity
initial_state = [0.1, 0, 0, 0.1, 0, 0]
t_span = (0, 50)
t_eval = np.linspace(*t_span, 2000)

# B-field in z-direction, cyclotron E-field
B_field = lambda pos, t: np.array([0, 0, 1])

# Run simulation
result = simulator.simulate(initial_state, t_span, t_eval, cyclotron_E_field, B_field)

# Plot trajectory showing the spiral pattern as particle accelerates
fig_cyc, ax_cyc = simulator.plot_trajectory_2d(plane='xy', title="Cyclotron Acceleration")
plt.close(fig_cyc)
</code></pre>
<p><img alt="alt text" src="../image-8.png"/></p>
<p>The cyclotron demonstrates:
- Particles spiral outward as they gain energy
- The cyclotron frequency (ω = qB/m) remains constant despite increasing energy
- This constancy breaks down at relativistic speeds (not modeled in our simulation)</p>
<h4 id="output">Output</h4>
<p>Cyclotron Acceleration – Spiral Trajectory<br/>
<em>Figure 11: Spiral trajectory of a charged particle in a cyclotron, illustrating outward drift as energy increases.</em></p>
<h3 id="mass-spectrometer">Mass Spectrometer</h3>
<p>Mass spectrometers use the Lorentz force to separate ions based on their mass-to-charge ratio. Our simulations with varying q/m ratios demonstrate this principle:</p>
<pre><code class="language-python"># Mass spectrometer simulation
simulators = []
ion_types = [
    {"name": "Ion 1", "q": 1.0, "m": 1.0},
    {"name": "Ion 2", "q": 1.0, "m": 2.0},
    {"name": "Ion 3", "q": 1.0, "m": 3.0}
]

# Plot trajectories for different ion types
fig_ms, ax_ms = plt.subplots(figsize=(10, 6))

for ion in ion_types:
    simulator = LorentzForceSimulator(q=ion["q"], m=ion["m"])

    # All ions start with the same initial velocity
    initial_state = [0, 0, 0, 1, 0, 0]
    t_span = (0, 20)
    t_eval = np.linspace(*t_span, 1000)

    # Uniform magnetic field
    B_field = lambda pos, t: np.array([0, 0, 1])
    E_field = lambda pos, t: np.array([0, 0, 0])

    # Run simulation
    result = simulator.simulate(initial_state, t_span, t_eval, E_field, B_field)

    # Plot trajectory
    ax_ms.plot(result.y[0], result.y[1], label=f"{ion['name']} (m={ion['m']})")

    # Calculate the radius of curvature
    radius = ion["m"] * 1.0 / (ion["q"] * 1.0)  # r = mv/(qB)
    simulators.append(simulator)

ax_ms.set_xlabel('X')
ax_ms.set_ylabel('Y')
ax_ms.set_title('Mass Spectrometer - Separation Based on Mass')
ax_ms.grid(True)
ax_ms.legend()
plt.close(fig_ms)
</code></pre>
<p>The mass spectrometer demonstrates:
- Heavier ions follow paths with larger radii
- The radius is proportional to the mass-to-charge ratio
- This allows precise separation of ions with different masses</p>
<h4 id="output_1">Output</h4>
<p><img alt="alt text" src="../image-9.png"/>ng)<br/>
<em>Figure 12: Trajectories of ions with different mass-to-charge ratios in a uniform magnetic field, illustrating separation based on mass.</em></p>
<h3 id="hall-effect-thruster">Hall Effect Thruster</h3>
<p>Hall effect thrusters use crossed E and B fields to accelerate ions for spacecraft propulsion:</p>
<pre><code class="language-python"># Hall effect thruster simulation
simulator = LorentzForceSimulator(q=1.0, m=1.0)

# Initial conditions: ion starts at rest
initial_state = [0, 0, 0, 0, 0, 0]
t_span = (0, 10)
t_eval = np.linspace(*t_span, 500)

# Crossed E and B fields
B_field = lambda pos, t: np.array([0, 1, 0])  # B in y-direction
E_field = lambda pos, t: np.array([0, 0, 1])  # E in z-direction

# Run simulation
result = simulator.simulate(initial_state, t_span, t_eval, E_field, B_field)

# Plot trajectory showing acceleration
fig_hall, ax_hall = simulator.plot_trajectory_3d(title="Hall Effect Thruster")
plt.close(fig_hall)
</code></pre>
<p>The Hall effect thruster demonstrates:
- Electrons undergo E×B drift, creating a Hall current
- Ions, due to their larger mass, are primarily accelerated by the electric field
- This differential behavior creates an efficient propulsion mechanism</p>
<h4 id="output_2">Output</h4>
<p><img alt="alt text" src="../image-10.png"/><br/>
<em>Figure 13: 3D trajectory of ions in a Hall effect thruster, showing acceleration due to crossed E and B fields.</em></p>
<h2 id="5-extensions-and-advanced-scenarios">5. Extensions and Advanced Scenarios</h2>
<h3 id="non-uniform-fields">Non-Uniform Fields</h3>
<p>Real electromagnetic systems often involve non-uniform fields. Here's a simple example with a non-uniform magnetic field:</p>
<pre><code class="language-python"># Non-uniform magnetic field example
def dipole_B_field(position, t, m=1.0):
    """
    Simplified magnetic dipole field
    """
    x, y, z = position
    r = np.sqrt(x**2 + y**2 + z**2)
    if r &lt; 0.1:  # Avoid singularity at origin
        r = 0.1

    # Magnetic moment in z-direction
    Bx = 3 * m * x * z / r**5
    By = 3 * m * y * z / r**5
    Bz = m * (3 * z**2 - r**2) / r**5

    return np.array([Bx, By, Bz])

simulator = LorentzForceSimulator(q=1.0, m=1.0)

# Initial conditions for dipole field simulation
initial_state = [2, 0, 0, 0, 0.5, 0.5]
t_span = (0, 20)
t_eval = np.linspace(*t_span, 1000)

# Use dipole field
E_field = lambda pos, t: np.array([0, 0, 0])

# Run simulation
result = simulator.simulate(initial_state, t_span, t_eval, E_field, dipole_B_field)

# Plot trajectory
fig_dipole, ax_dipole = simulator.plot_trajectory_3d(title="Particle in Magnetic Dipole Field")
plt.close(fig_dipole)
</code></pre>
<p>In the dipole field, we observe:
- Complex, non-circular trajectories
- Particles can become trapped in magnetic "bottles"
- Mirroring effects as particles enter regions of stronger field</p>
<h4 id="output_3">Output</h4>
<p><img alt="alt text" src="../image-11.png"/><br/>
<em>Figure 14: 3D trajectory of a charged particle in a magnetic dipole field, showing complex, non‐circular motion and trapping effects.</em></p>
<h3 id="time-varying-fields">Time-Varying Fields</h3>
<p>Many applications involve time-varying electromagnetic fields:</p>
<pre><code class="language-python"># Time-varying field example
def time_varying_B_field(position, t, B0=1.0, omega=0.5):
    """
    Time-varying magnetic field that rotates in the xy-plane
    """
    Bx = B0 * np.cos(omega * t)
    By = B0 * np.sin(omega * t)
    return np.array([Bx, By, 0])

simulator = LorentzForceSimulator(q=1.0, m=1.0)

# Initial conditions
initial_state = [0, 0, 0, 0.5, 0, 0]
t_span = (0, 30)
t_eval = np.linspace(*t_span, 1500)

# No electric field
E_field = lambda pos, t: np.array([0, 0, 0])

# Run simulation
result = simulator.simulate(initial_state, t_span, t_eval, E_field, time_varying_B_field)

# Plot trajectory
fig_tv, ax_tv = simulator.plot_trajectory_3d(title="Particle in Time-Varying B Field")
plt.close(fig_tv)
</code></pre>
<p>Time-varying fields demonstrate:
- Resonant acceleration when field variations match particle gyration
- This principle is used in RF accelerators and tokamaks
- Complex 3D trajectories that can't be predicted from simple circular motion</p>
<p><img alt="alt text" src="../image-12.png"/><br/>
<em>Figure 15: 3D trajectory of a charged particle in a magnetic field rotating in the xy-plane over time, illustrating complex time-dependent motion.</em></p>
<h2 id="7-practical-applications-discussion">7. Practical Applications Discussion</h2>
<h3 id="particle-accelerators_1">Particle Accelerators</h3>
<p>Particle accelerators use electromagnetic fields to accelerate charged particles to high energies for research, medical treatments, and industrial applications. Our simulations demonstrate key principles:</p>
<ol>
<li>
<p><strong>Cyclotrons</strong>: Use a constant magnetic field to bend particles in a circular path, with an oscillating electric field providing acceleration at the right phase. The particle spirals outward as it gains energy.</p>
</li>
<li>
<p><strong>Synchrotrons</strong>: More advanced accelerators that adjust the magnetic field strength as particles gain energy, keeping them in a fixed circular path. This overcomes the relativistic limit of cyclotrons.</p>
</li>
<li>
<p><strong>Linear Accelerators (LINACs)</strong>: Use oscillating electric fields to accelerate particles in a straight line, avoiding the synchrotron radiation losses that occur in circular accelerators.</p>
</li>
</ol>
<p>Our cyclotron simulation shows how particles gain energy with each oscillation of the electric field, resulting in an expanding spiral trajectory. This is the fundamental principle behind many medical accelerators used for cancer treatment.</p>
<h3 id="plasma-confinement_1">Plasma Confinement</h3>
<p>Magnetic confinement fusion relies on the Lorentz force to trap charged plasma particles:</p>
<ol>
<li>
<p><strong>Tokamaks</strong>: Use toroidal magnetic fields with additional poloidal fields to confine plasma. The helical field lines prevent particles from drifting out of the confinement region.</p>
</li>
<li>
<p><strong>Magnetic Mirrors</strong>: Use increasing magnetic field strength at the ends of a confinement region to reflect particles back, as demonstrated in our magnetic mirror simulation.</p>
</li>
<li>
<p><strong>E×B Drift</strong>: Understanding drifts is crucial for plasma confinement. Our crossed-fields simulation shows how particles drift perpendicular to both E and B fields.</p>
</li>
</ol>
<p>The magnetic mirror simulation demonstrates how particles bounce between regions of high magnetic field strength, a principle used in early fusion experiments. Modern tokamaks use more complex field configurations to minimize particle losses.</p>
<h3 id="mass-spectrometry_1">Mass Spectrometry</h3>
<p>Mass spectrometers rely on the mass-dependent radius of charged particles in magnetic fields:</p>
<ol>
<li>
<p><strong>Sector Mass Spectrometers</strong>: Use uniform magnetic fields to bend ion trajectories, with heavier ions following paths with larger radii.</p>
</li>
<li>
<p><strong>Time-of-Flight (TOF) Spectrometers</strong>: Accelerate ions through an electric field and measure the time taken to reach a detector.</p>
</li>
<li>
<p><strong>Quadrupole Mass Filters</strong>: Use oscillating electric fields to selectively filter ions based on their mass-to-charge ratio.</p>
</li>
</ol>
<p>Our simulations showing different trajectories for particles with different mass-to-charge ratios illustrate the basic principle of mass spectrometry, which is used in chemistry, biology, and environmental science for analyzing molecular compositions.</p>
<h3 id="space-propulsion">Space Propulsion</h3>
<p>Electric propulsion systems for spacecraft utilize the Lorentz force:</p>
<ol>
<li>
<p><strong>Hall Effect Thrusters</strong>: Use crossed E and B fields to create an E×B drift of electrons, generating an electric field that accelerates ions for thrust.</p>
</li>
<li>
<p><strong>Ion Engines</strong>: Accelerate ions through an electric field to produce thrust, with better fuel efficiency than chemical rockets.</p>
</li>
<li>
<p><strong>Magnetoplasmadynamic (MPD) Thrusters</strong>: Use the Lorentz force directly to accelerate plasma.</p>
</li>
</ol>
<p>Our crossed-fields simulation demonstrates the basic principle behind Hall thrusters, which are used on many satellites and deep-space missions for efficient propulsion.</p>
<h2 id="8-extensions-for-future-work">8. Extensions for Future Work</h2>
<p>This simulation framework can be extended in several ways:</p>
<ol>
<li>
<p><strong>Relativistic Effects</strong>: Incorporate special relativity for high-energy particles where classical mechanics breaks down.</p>
</li>
<li>
<p><strong>Particle-Field Interactions</strong>: Include the effects of particles on the fields themselves, important for plasma simulations.</p>
</li>
<li>
<p><strong>Collision Physics</strong>: Add particle-particle interactions for more realistic plasma or gas simulations.</p>
</li>
<li>
<p><strong>More Complex Field Geometries</strong>: Implement realistic field configurations from actual devices like tokamaks or mass spectrometers.</p>
</li>
<li>
<p><strong>Quantum Effects</strong>: For very small scales, incorporate quantum mechanical behavior of charged particles.</p>
</li>
<li>
<p><strong>Particle Ensembles</strong>: Simulate multiple particles simultaneously to study collective behavior.</p>
</li>
<li>
<p><strong>Optimization Tools</strong>: Add functionality to optimize field configurations for specific applications.</p>
</li>
</ol>
<h2 id="9-conclusion">9. Conclusion</h2>
<p>This simulation demonstrates how the Lorentz force governs the motion of charged particles in electromagnetic fields. We've observed several key phenomena:</p>
<ol>
<li><strong>Circular motion</strong> in uniform magnetic fields with radius determined by the Larmor radius</li>
<li><strong>Helical trajectories</strong> when particles have velocity components parallel to the magnetic field</li>
<li><strong>E×B drift</strong> in crossed electric and magnetic fields</li>
<li><strong>Mirroring effects</strong> in non-uniform magnetic fields</li>
<li><strong>Acceleration</strong> in time-varying fields</li>
</ol>
<p>These phenomena form the basis for numerous technologies, from particle accelerators used in cancer treatment to spacecraft propulsion systems. By understanding and simulating the Lorentz force, we gain insights into both fundamental physics and practical applications.</p>
<p>The simulation framework I've developed allows for exploration of various field configurations and particle parameters, providing a versatile tool for studying electromagnetic interactions.</p>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../../3%20Waves/Problem_1/" title="Problem 1"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../5%20Circuits/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../../3%20Waves/Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../5%20Circuits/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
