{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Below is a comprehensive Markdown document that outlines the derivation, analysis, and simulation of projectile motion with a focus on how the horizontal range depends on the launch angle. The document includes theoretical derivations, discussion of parameter effects and limitations, as well as a Python simulation to visualize the range versus the angle of projection. Investigating the Range as a Function of the Angle of Projection 1. Introduction Projectile motion is a classic problem in mechanics that offers deep insights into the interplay between linear and quadratic relationships. By varying parameters such as the initial velocity, gravitational acceleration, and launch height, one can obtain a rich family of solutions that model real-world phenomena ranging from sports to aerospace engineering. In this document, we: Derive the governing equations of motion. Analyze the dependence of the horizontal range on the angle of projection. Discuss the influence of initial velocity and gravitational acceleration. Explore practical applications and limitations of the idealized model. Implement a simulation in Python to visualize these relationships. 2. Theoretical Foundation Derivation of Equations of Motion Assume a projectile is launched with an initial speed \\(v_0\\) at an angle \\(\\theta\\) relative to the horizontal. Under the assumption of uniform gravitational acceleration \\(g\\) and no air resistance, the equations of motion are: \\[ x(t) = v_0 \\cos(\\theta) \\, t, \\] \\[ y(t) = v_0 \\sin(\\theta) \\, t - \\frac{1}{2} g t^2. \\] Time of Flight and Range For a projectile launched from and landing at the same vertical level ( \\(y = 0\\) ), setting \\(y(T) = 0\\) gives: \\[ 0 = v_0 \\sin(\\theta) \\, T - \\frac{1}{2} g T^2. \\] This yields two solutions: \\(T = 0\\) (the launch moment), and \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g}. \\] The horizontal range \\(R\\) is the horizontal displacement at \\(T\\) : \\[ R = x(T) = v_0 \\cos(\\theta) \\, T = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g}. \\] Thus, the range as a function of the angle \\(\\theta\\) is: \\[ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g}. \\] 3. Analysis of the Range Dependence on the Angle of Projection Optimal Angle: For a given \\(v_0\\) and \\(g\\) , the maximum range is achieved when \\(\\sin(2\\theta)\\) is maximized. Since \\(\\sin(2\\theta)\\) reaches its maximum value of 1 when \\(2\\theta = 90^\\circ\\) , the optimal angle is: $$ \\theta = 45^\\circ $$ Parameter Influences: Initial Velocity \\(v_0\\) : The range scales with \\(v_0^2\\) ; increasing \\(v_0\\) results in a quadratic increase in the range. Gravitational Acceleration \\(g\\) : A higher gravitational acceleration reduces the range. On celestial bodies with lower \\(g\\) , the projectile would travel farther. Launch Height: For non-zero launch heights, the time of flight and range are modified. This case introduces additional complexity and typically requires solving a quadratic equation for \\(T\\) . 4. Practical Applications and Limitations Applications Sports: The model helps in understanding the optimal angles for throwing or hitting balls. Engineering: Used in ballistics, trajectory planning, and robotics. Astrophysics: Similar principles can be adapted to study trajectories in different gravitational fields. Limitations Air Resistance: The idealized model neglects drag, which significantly affects real-world trajectories. Wind Effects: Lateral forces are not considered. Non-uniform Gravitational Fields: For large-scale projectiles (e.g., rockets), the assumption of constant \\(g\\) is not valid. Uneven Terrain: The analysis assumes level ground; varying terrain requires more complex modeling. 5. Implementation: Python Simulation Below is a Python script that simulates projectile motion and visualizes the horizontal range as a function of the projection angle for different initial conditions. import numpy as np import matplotlib.pyplot as plt # Constants and parameters g = 9.81 # gravitational acceleration (m/s^2) v0 = 20.0 # initial velocity (m/s) # Angle range from 0 to 90 degrees in radians angles_deg = np.linspace(0, 90, 180) angles_rad = np.deg2rad(angles_deg) # Calculate range for each angle using R = (v0^2 * sin(2\u03b8)) / g ranges = (v0**2 * np.sin(2 * angles_rad)) / g # Plot the Range vs. Angle of Projection plt.figure(figsize=(10, 6)) plt.plot(angles_deg, ranges, label=f'v0 = {v0} m/s', color='blue') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Horizontal Range (m)') plt.title('Projectile Range as a Function of the Angle of Projection') plt.legend() plt.grid(True) plt.show() Simulation Output from Python code Here is the static image generated from google colab by using python code: Explanation of the Code Parameter Setup: We define the gravitational acceleration \\(g\\) and the initial velocity \\(v_0\\) . Angle Range: Angles are sampled from 0\u00b0 to 90\u00b0 and converted to radians. Range Calculation: The range for each angle is computed using the derived formula. Visualization: A plot is generated to show the dependence of the range on the angle of projection. 6. Conclusion This investigation has provided: A derivation of the fundamental equations of projectile motion. A clear relationship showing that the range is maximized at a 45\u00b0 angle for level ground. An analysis of how initial velocity and gravitational acceleration influence the trajectory. A Python-based simulation that visualizes these relationships. While the idealized model offers significant insights, real-world applications require accounting for additional factors like air resistance, wind, and variable terrain. Future extensions might include these effects to provide a more comprehensive understanding of projectile motion in practical scenarios.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-introduction","text":"Projectile motion is a classic problem in mechanics that offers deep insights into the interplay between linear and quadratic relationships. By varying parameters such as the initial velocity, gravitational acceleration, and launch height, one can obtain a rich family of solutions that model real-world phenomena ranging from sports to aerospace engineering. In this document, we: Derive the governing equations of motion. Analyze the dependence of the horizontal range on the angle of projection. Discuss the influence of initial velocity and gravitational acceleration. Explore practical applications and limitations of the idealized model. Implement a simulation in Python to visualize these relationships.","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-theoretical-foundation","text":"","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-equations-of-motion","text":"Assume a projectile is launched with an initial speed \\(v_0\\) at an angle \\(\\theta\\) relative to the horizontal. Under the assumption of uniform gravitational acceleration \\(g\\) and no air resistance, the equations of motion are: \\[ x(t) = v_0 \\cos(\\theta) \\, t, \\] \\[ y(t) = v_0 \\sin(\\theta) \\, t - \\frac{1}{2} g t^2. \\]","title":"Derivation of Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight-and-range","text":"For a projectile launched from and landing at the same vertical level ( \\(y = 0\\) ), setting \\(y(T) = 0\\) gives: \\[ 0 = v_0 \\sin(\\theta) \\, T - \\frac{1}{2} g T^2. \\] This yields two solutions: \\(T = 0\\) (the launch moment), and \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g}. \\] The horizontal range \\(R\\) is the horizontal displacement at \\(T\\) : \\[ R = x(T) = v_0 \\cos(\\theta) \\, T = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g}. \\] Thus, the range as a function of the angle \\(\\theta\\) is: \\[ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g}. \\]","title":"Time of Flight and Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-analysis-of-the-range","text":"","title":"3. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#dependence-on-the-angle-of-projection","text":"Optimal Angle: For a given \\(v_0\\) and \\(g\\) , the maximum range is achieved when \\(\\sin(2\\theta)\\) is maximized. Since \\(\\sin(2\\theta)\\) reaches its maximum value of 1 when \\(2\\theta = 90^\\circ\\) , the optimal angle is: $$ \\theta = 45^\\circ $$ Parameter Influences: Initial Velocity \\(v_0\\) : The range scales with \\(v_0^2\\) ; increasing \\(v_0\\) results in a quadratic increase in the range. Gravitational Acceleration \\(g\\) : A higher gravitational acceleration reduces the range. On celestial bodies with lower \\(g\\) , the projectile would travel farther. Launch Height: For non-zero launch heights, the time of flight and range are modified. This case introduces additional complexity and typically requires solving a quadratic equation for \\(T\\) .","title":"Dependence on the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-practical-applications-and-limitations","text":"","title":"4. Practical Applications and Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#applications","text":"Sports: The model helps in understanding the optimal angles for throwing or hitting balls. Engineering: Used in ballistics, trajectory planning, and robotics. Astrophysics: Similar principles can be adapted to study trajectories in different gravitational fields.","title":"Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations","text":"Air Resistance: The idealized model neglects drag, which significantly affects real-world trajectories. Wind Effects: Lateral forces are not considered. Non-uniform Gravitational Fields: For large-scale projectiles (e.g., rockets), the assumption of constant \\(g\\) is not valid. Uneven Terrain: The analysis assumes level ground; varying terrain requires more complex modeling.","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-implementation-python-simulation","text":"Below is a Python script that simulates projectile motion and visualizes the horizontal range as a function of the projection angle for different initial conditions. import numpy as np import matplotlib.pyplot as plt # Constants and parameters g = 9.81 # gravitational acceleration (m/s^2) v0 = 20.0 # initial velocity (m/s) # Angle range from 0 to 90 degrees in radians angles_deg = np.linspace(0, 90, 180) angles_rad = np.deg2rad(angles_deg) # Calculate range for each angle using R = (v0^2 * sin(2\u03b8)) / g ranges = (v0**2 * np.sin(2 * angles_rad)) / g # Plot the Range vs. Angle of Projection plt.figure(figsize=(10, 6)) plt.plot(angles_deg, ranges, label=f'v0 = {v0} m/s', color='blue') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Horizontal Range (m)') plt.title('Projectile Range as a Function of the Angle of Projection') plt.legend() plt.grid(True) plt.show()","title":"5. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulation-output-from-python-code","text":"Here is the static image generated from google colab by using python code:","title":"Simulation Output from Python code"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-code","text":"Parameter Setup: We define the gravitational acceleration \\(g\\) and the initial velocity \\(v_0\\) . Angle Range: Angles are sampled from 0\u00b0 to 90\u00b0 and converted to radians. Range Calculation: The range for each angle is computed using the derived formula. Visualization: A plot is generated to show the dependence of the range on the angle of projection.","title":"Explanation of the Code"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-conclusion","text":"This investigation has provided: A derivation of the fundamental equations of projectile motion. A clear relationship showing that the range is maximized at a 45\u00b0 angle for level ground. An analysis of how initial velocity and gravitational acceleration influence the trajectory. A Python-based simulation that visualizes these relationships. While the idealized model offers significant insights, real-world applications require accounting for additional factors like air resistance, wind, and variable terrain. Future extensions might include these effects to provide a more comprehensive understanding of projectile motion in practical scenarios.","title":"6. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum 1. Introduction The forced damped pendulum is a classic nonlinear system that exhibits a rich variety of behaviors\u2014from simple periodic oscillations to complex chaotic motion\u2014due to the interplay between damping, restoring forces, and an external periodic drive. By varying parameters such as the damping coefficient, driving amplitude, and driving frequency, one can obtain a diverse set of solutions that model real-world phenomena ranging from energy harvesting to structural vibrations. In this document, we: Derive the governing differential equation for the forced damped pendulum. Analyze the influence of damping, driving amplitude, and driving frequency on the system\u2019s dynamics. Discuss practical applications and limitations of the forced damped pendulum model. Implement a simulation in Python to visualize the pendulum\u2019s behavior. 2. Theoretical Foundation Differential Equation The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\ddot{\\theta} + 2\\beta\\, \\dot{\\theta} + \\omega_0^2 \\sin\\theta = \\frac{F_D}{mL} \\cos(\\Omega t), \\] where: \\((\\theta)\\) is the angular displacement, \\((\\beta)\\) is the damping coefficient, \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural frequency of the pendulum (with $ L $ being the pendulum length), \\(F_D\\) is the amplitude of the driving force, \\(( m )\\) is the mass of the pendulum bob, \\(( L )\\) is the length of the pendulum, \\(( \\Omega )\\) is the driving frequency. Small-Angle Approximation For small oscillations, we use the approximation: \\[ \\sin\\theta \\approx \\theta, \\] which linearizes the equation to: \\[ \\ddot{\\theta} + 2\\beta\\, \\dot{\\theta} + \\omega_0^2 \\theta = \\frac{F_D}{mL} \\cos(\\Omega t). \\] The general solution is the sum of the homogeneous solution (which decays due to damping) and a particular solution that oscillates at the driving frequency. Resonance Conditions Resonance: The system experiences resonance when the driving frequency \\(\\Omega\\) is close to the natural frequency \\(\\omega_0\\) . At resonance, the amplitude of the steady-state oscillations becomes large, limited by the damping. Energy Implications: Under resonance, the system efficiently absorbs energy from the external force, resulting in significant oscillation amplitudes. 3. Analysis of Dynamics Parameter Influences Damping Coefficient ( \\(\\beta\\) ): Higher damping reduces the amplitude of oscillations and can suppress chaotic behavior, while lower damping allows for larger amplitudes and may lead to complex dynamics. Driving Amplitude ( \\(F_D/(mL)\\) ): Increasing the driving amplitude increases the steady-state oscillation amplitude. Very high driving amplitudes can push the system into a nonlinear regime, potentially resulting in chaotic motion. Driving Frequency ( \\(\\Omega\\) ): When \\(\\Omega\\) is near \\(\\omega_0\\) , the system experiences resonance. As \\(\\Omega\\) varies, the system may transition between regular (periodic) motion and chaotic behavior. Transition to Chaos Regular Motion: For moderate values of damping and driving amplitude, the pendulum displays periodic oscillations. Chaotic Motion: Under low damping or high driving amplitude, the system becomes highly sensitive to initial conditions, leading to chaotic behavior. Visualization Tools: Phase portraits and Poincar\u00e9 sections are used to reveal the underlying structure of the motion and the transition to chaos. 4. Practical Applications and Limitations Applications Energy Harvesting: Systems can be designed to exploit resonance, thereby maximizing energy absorption from periodic forces. Structural Engineering: Understanding forced oscillations is crucial in designing structures (e.g., suspension bridges, vibration isolation systems) that must withstand periodic loads. Oscillating Circuits: The behavior of driven RLC circuits is analogous to the forced damped pendulum, informing the design of filters and resonant circuits. Limitations The small-angle approximation simplifies the analysis but is only valid for small displacements. The model neglects effects such as nonlinear damping and non-periodic driving forces, which may be significant in real-world systems. For larger oscillations, the full nonlinear equation (with \\(\\sin\\theta\\) ) should be used. 5. Implementation: Python Simulation 5.1. First Simulation In this first simulation, we produce three key plots to analyze the forced damped pendulum\u2019s motion: A time series plot of \\(\\theta(t)\\) A phase portrait ( \\(\\theta\\) vs. \\(\\dot{\\theta}\\) ) A Poincar\u00e9 section to capture periodic and chaotic dynamics Below is the Python code for our initial simulation under the small-angle approximation. It uses solve_ivp to integrate the system, then plots the results. For now, we run one set of parameters ( \\(\\beta=0.25\\) , \\(F_D=1.2\\) , \\(\\Omega=2/3\\) , etc.): import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def run_forced_damped_pendulum(beta=0.25, F_D=1.2, Omega=2/3, t_span=(0, 100), y0=(0.1, 0.0), use_small_angle=True): \"\"\" Simulates and plots the forced damped pendulum. Parameters: ----------- beta : float Damping coefficient. F_D : float Driving force amplitude (N). Omega : float Driving frequency (rad/s). t_span : tuple Start and end time for the simulation, e.g. (0, 100). y0 : Initial conditions (theta, omega). use_small_angle : bool If True, use the small-angle approximation (sin(theta) ~ theta). If False, use the full nonlinear equation sin(theta). \"\"\" g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # pendulum length (m) m = 1.0 # mass (kg) # Natural frequency omega0 = np.sqrt(g / L) # Driving force term driving_force = F_D / (m * L) # Define the ODE def forced_damped_pendulum(t, y): theta, omega = y # Corrected: Added theta dtheta_dt = omega if use_small_angle: # Small-angle approximation: sin(theta) ~ theta restoring = -omega0**2 * theta else: # Full nonlinear: sin(theta) restoring = -omega0**2 * np.sin(theta) domega_dt = -2 * beta * omega + restoring + driving_force * np.cos(Omega * t) return [dtheta_dt, domega_dt] # Create a time array for evaluation t_eval = np.linspace(t_span[0], t_span[1], 10000) # Solve the ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, rtol=1e-8) # Corrected: Changed t to t_eval t = sol.t theta = sol.y[0] # Corrected: Added theta omega = sol.y[1] # --- PLOTS --- # 1) Time of Theta(t) plt.figure(figsize=(10, 4)) plt.plot(t, theta, 'b-', label=r'$\\theta(t)$') # Corrected: Changed plt to plt.plot plt.xlabel('Time (s)') # Corrected: Indentation plt.ylabel('Angle (rad)') plt.title(f'Time Series (beta={beta}, F_D={F_D}, Omega={Omega})') plt.legend() plt.grid(True) plt.tight_layout() plt.show() # 2) Phase Portrait (theta vs. omega) plt.figure(figsize=(6, 6)) plt.plot(theta, omega, 'r-', lw=0.8) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Phase Portrait (beta={beta}, F_D={F_D}, Omega={Omega})') plt.grid(True) plt.tight_layout() plt.show() # 3) Poincar\u00e9 Section # Sample points at every period T_drive = 2*pi/Omega after a transient T_drive = 2 * np.pi / Omega # Skip initial transients (e.g., first 50 cycles) skip_cycles = 50 # Corrected: Added = poincare_times = np.arange(skip_cycles * T_drive, t_span[1], T_drive) poincare_thetas = np.interp(poincare_times, t, theta) poincare_omegas = np.interp(poincare_times, t, omega) plt.figure(figsize=(6, 6)) plt.scatter(poincare_thetas, poincare_omegas, c='green', s=25) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Poincar\u00e9 Section (beta={beta}, F_D={F_D}, Omega={Omega})') plt.grid(True) plt.tight_layout() plt.show() # Main function to run multiple simulations def main(): # Define parameter ranges damping_coefficients = [0.1, 0.25, 0.5] # Different damping coefficients driving_forces = [0.5, 1.0, 1.5] # Different driving forces driving_frequencies = [1/2, 1, 2] # Different driving frequencies # Run simulations for different combinations of parameters for beta in damping_coefficients: for F_D in driving_forces: for Omega in driving_frequencies: run_forced_damped_pendulum(beta=beta, F_D=F_D, Omega=Omega, t_span=(0, 100), y0=(0.1, 0.0), use_small_angle=True) if __name__ == \"__main__\": main() Outputs for the First Simulation Running this script with \\((\\beta=0.25)\\) , \\((F_D=1.2)\\) , \\((\\Omega=2/3)\\) , and use_small_angle = True produces three plots : Time Series: Phase portrait Time Series (beta=01, F_D=0.5, Omega=1) Phase Portait( beta=0.1 F_D=0.5, Omega=1 ) Time series (beta=0.1 F_D=0.5, Omega=2 Time series (beta=0.1 F_D=1.0, Omega=0.5 Phase Portrait (beta=01, F_D=1.0, Omega=0.2) Phase Portait( beta=0.1 F_D=1.0, Omega=1 Time Series (beta=0.1, F_D=1.0, Omega=1) Portrait (Beta=0.1, Fr_D=1.0, Omega=2) Explanation Time Series: Shows how \\(\\theta(t)\\) evolves over time. A nearly sinusoidal plot indicates that the pendulum exhibits stable periodic motion. Phase Portrait: Plots \\(\\theta\\) versus \\(\\dot{\\theta}\\) . A closed loop in \\(\\theta\\) \u2013 \\(\\dot{\\theta}\\) space indicates a stable periodic orbit. Poincar\u00e9 Section: Samples the phase space at intervals of the driving period. A small set of discrete points indicates that the system is in regular, periodic motion rather than chaotic behavior. Small-Angle Approximation: Since use_small_angle = True , we use \\(\\sin(\\theta) \\approx \\theta\\) . This typically yields simpler, near-harmonic motion for moderate parameter values. Stable Periodic Orbit: Under \\((\\beta = 0.25)\\) , \\((F_D = 1.2)\\) , and \\((\\Omega = \\tfrac{2}{3})\\) , the pendulum exhibits a stable periodic solution\u2014evident from the sinusoidal time series, single-loop phase portrait, and a small set of points in the Poincar\u00e9 section. Potential Extensions: Set use_small_angle = False to use the full nonlinear equation \\(\\sin(\\theta)\\) , which can yield chaotic solutions for certain parameter ranges. Vary \\(\\beta\\) (damping), \\(F_D\\) (driving amplitude), and \\(\\Omega\\) (driving frequency) to see more complex dynamics, including chaos. 5.2. Second Simulation (Exploring More Complex Dynamics) To explore more complex or chaotic behavior, we can turn off the small\u2010angle approximation and adjust parameters such as damping and driving amplitude. In the following example, we lower the damping and increase the driving force: Damping coefficient: \\(\\beta = 0.2\\) Driving amplitude: \\(F_D = 1.5\\) Driving frequency: \\(\\Omega = \\tfrac{2}{3}\\) Full nonlinear equation (i.e., \\(\\sin(\\theta)\\) instead of \\(\\theta\\) ) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def run_forced_damped_pendulum(beta=0.2, F_D=1.5, Omega=2/3, t_span=(0, 200), y0=(0.2, 0.0), use_small_angle=False): \"\"\" Simulates and plots the forced damped pendulum with more extreme parameters, potentially leading to chaotic motion. \"\"\" g = 9.81 L = 1.0 m = 1.0 omega0 = np.sqrt(g / L) driving_force = F_D / (m * L) def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega if use_small_angle: restoring = -omega0**2 * theta else: restoring = -omega0**2 * np.sin(theta) domega_dt = -2 * beta * omega + restoring + driving_force * np.cos(Omega * t) return [dtheta_dt, domega_dt] t_eval = np.linspace(t_span[0], t_span[1], 20000) sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, rtol=1e-8) t = sol.t theta = sol.y[0] omega = sol.y[1] # Time Series plt.figure(figsize=(10, 4)) plt.plot(t, theta, 'b-', label=r'$\\theta(t)$') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title(f'Time Series (beta={beta}, F_D={F_D}, Omega={Omega}, Nonlinear)') plt.legend() plt.grid(True) plt.tight_layout() plt.show() # Phase Portrait plt.figure(figsize=(6, 6)) plt.plot(theta, omega, 'r-', lw=0.8) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Phase Portrait (beta={beta}, F_D={F_D}, Omega={Omega}, Nonlinear)') plt.grid(True) plt.tight_layout() plt.show() # Poincar\u00e9 Section T_drive = 2 * np.pi / Omega skip_cycles = 50 poincare_times = np.arange(skip_cycles * T_drive, t_span[1], T_drive) poincare_thetas = np.interp(poincare_times, t, theta) poincare_omegas = np.interp(poincare_times, t, omega) plt.figure(figsize=(6, 6)) plt.scatter(poincare_thetas, poincare_omegas, c='green', s=25) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Poincar\u00e9 Section (beta={beta}, F_D={F_D}, Omega={Omega}, Nonlinear)') plt.grid(True) plt.tight_layout() plt.show() if __name__ == \"__main__\": run_forced_damped_pendulum() Outputs for the Second Simulation Running this script with \\((\\beta=0.2\\) ), \\((F_D=1.5)\\) , \\(\\Omega=\\tfrac{2}{3}\\) , and use_small_angle = False often yields more complex or chaotic motion. You might see: Time Series: The waveform can become irregular, indicating non-periodic or chaotic behavior. Phase Portrait Instead of a single closed loop, the trajectory in \\(\\theta\\) \u2013 \\(\\dot{\\theta}\\) space may fill an area or form a strange attractor, characteristic of chaos. Poincar\u00e9 Section A scattered \u201ccloud\u201d of points, rather than a finite set, implies chaotic dynamics. Explanation Nonlinear Equation : We set use_small_angle = False so that \\(\\sin(\\theta)\\) is used instead of \\(\\theta\\) . This allows for larger amplitude oscillations and the possibility of chaos. Lower Damping, Higher Drive : \\(\\beta=0.2\\) is smaller than the previous 0.25, so the system loses energy more slowly. \\(F_D=1.5\\) is greater than 1.2, delivering more external energy per cycle. Together, these changes push the pendulum into a regime where chaotic behavior is more likely. Longer Time Span : We increased t_span to (0, 200) to observe the long-term evolution. Chaos sometimes takes a while to emerge or settle into an attractor. Potential Observations : If the motion is chaotic, the phase portrait and Poincar\u00e9 section won\u2019t settle into a simple loop or small set of points. You may see a scattered or more \u201cfilled-in\u201d region in phase space. With this second simulation, I demonstrate how changing parameters (especially lowering damping and increasing driving amplitude) can lead from stable periodic motion to more complex or chaotic behavior in the forced damped pendulum. 6. Discussion General Solutions: With the small-angle approximation and moderate parameters, the pendulum typically remains in a regular periodic orbit . However, for certain parameter sets (e.g., lower damping, higher driving amplitude, or using the full \\(\\sin(\\theta)\\) ), it can transition to chaotic motion . Graphical Representations: Time Series: Depicts how \\(\\theta\\) changes over time. Phase Portrait: Shows \\(\\theta\\) vs. \\(\\dot{\\theta}\\) , revealing periodic loops or chaotic attractors. Poincar\u00e9 Section: Captures the system\u2019s state once every driving period, distinguishing periodic from chaotic dynamics. Limitations & Future Work: The small-angle approximation may fail for larger amplitudes. Nonlinear damping or non-periodic driving forces can further complicate real-world behavior. Comparison of the Two Simulations Equations and Approximations: First Simulation uses the small-angle approximation \\(\\sin(\\theta)\\approx \\theta\\) . This linearizes the pendulum\u2019s restoring force, typically yielding stable, near-harmonic motion for moderate parameters. Second Simulation employs the full nonlinear equation \\(\\sin(\\theta)\\) . This allows for larger amplitude oscillations and the possibility of chaotic regimes under more extreme parameters. Parameter Choices: First Simulation : \\(\\beta=0.25,\\; F_D=1.2,\\; \\Omega=\\tfrac{2}{3},\\; \\text{use\\_small\\_angle = True}\\) . These moderate values produce a stable periodic orbit. Second Simulation : \\(\\beta=0.2,\\; F_D=1.5,\\; \\Omega=\\tfrac{2}{3},\\; \\text{use\\_small\\_angle=False}\\) . Lower damping and higher driving force are designed to push the system into more complex or chaotic motion. Observations in the Plots: Time Series : First Simulation : A smooth, sinusoidal-like wave indicating periodic motion. Second Simulation : Potentially more irregular or broader swings if chaos emerges. Phase Portrait \\((\\theta\\) vs. \\(\\dot{\\theta}\\) ): First Simulation : A single closed loop consistent with a periodic orbit. Second Simulation : May fill an area or produce more complicated loops, indicative of chaos or quasiperiodicity (depending on parameters). Poincar\u00e9 Section : First Simulation : A small set of discrete points reflects the regular (periodic) solution. Second Simulation : If truly chaotic, you\u2019d see a scattered cloud of points. However, it may still appear periodic if the parameters don\u2019t sufficiently drive chaos. Key Takeaways: The first (small-angle) simulation demonstrates how a forced damped pendulum can settle into a stable periodic orbit with moderate damping and driving. The second (full nonlinear) simulation attempts to highlight more extreme dynamics by reducing damping and increasing the driving force, thereby increasing the likelihood of chaos . If you still observe a periodic solution in the second simulation, you can further adjust parameters (e.g., reduce \\(\\beta\\) or raise \\(F_D\\) ) or extend the simulation time to reveal chaotic behavior. 7. Conclusion This investigation of the forced damped pendulum has: Derived the governing equations and provided an approximate solution for small oscillations. Analyzed how damping, driving amplitude, and driving frequency affect the system\u2019s dynamics. Illustrated the transition from periodic to chaotic behavior using time series , phase portraits , and Poincar\u00e9 sections . Demonstrated a computational simulation in Python that visualizes these dynamics. Overall, this study reinforces key concepts in nonlinear dynamics and provides a foundation for further exploration, including adjusting parameters to observe chaotic regimes or incorporating more realistic effects such as nonlinear damping.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-introduction","text":"The forced damped pendulum is a classic nonlinear system that exhibits a rich variety of behaviors\u2014from simple periodic oscillations to complex chaotic motion\u2014due to the interplay between damping, restoring forces, and an external periodic drive. By varying parameters such as the damping coefficient, driving amplitude, and driving frequency, one can obtain a diverse set of solutions that model real-world phenomena ranging from energy harvesting to structural vibrations. In this document, we: Derive the governing differential equation for the forced damped pendulum. Analyze the influence of damping, driving amplitude, and driving frequency on the system\u2019s dynamics. Discuss practical applications and limitations of the forced damped pendulum model. Implement a simulation in Python to visualize the pendulum\u2019s behavior.","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-theoretical-foundation","text":"","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation","text":"The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\ddot{\\theta} + 2\\beta\\, \\dot{\\theta} + \\omega_0^2 \\sin\\theta = \\frac{F_D}{mL} \\cos(\\Omega t), \\] where: \\((\\theta)\\) is the angular displacement, \\((\\beta)\\) is the damping coefficient, \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural frequency of the pendulum (with $ L $ being the pendulum length), \\(F_D\\) is the amplitude of the driving force, \\(( m )\\) is the mass of the pendulum bob, \\(( L )\\) is the length of the pendulum, \\(( \\Omega )\\) is the driving frequency.","title":"Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations, we use the approximation: \\[ \\sin\\theta \\approx \\theta, \\] which linearizes the equation to: \\[ \\ddot{\\theta} + 2\\beta\\, \\dot{\\theta} + \\omega_0^2 \\theta = \\frac{F_D}{mL} \\cos(\\Omega t). \\] The general solution is the sum of the homogeneous solution (which decays due to damping) and a particular solution that oscillates at the driving frequency.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance: The system experiences resonance when the driving frequency \\(\\Omega\\) is close to the natural frequency \\(\\omega_0\\) . At resonance, the amplitude of the steady-state oscillations becomes large, limited by the damping. Energy Implications: Under resonance, the system efficiently absorbs energy from the external force, resulting in significant oscillation amplitudes.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-analysis-of-dynamics","text":"","title":"3. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-influences","text":"Damping Coefficient ( \\(\\beta\\) ): Higher damping reduces the amplitude of oscillations and can suppress chaotic behavior, while lower damping allows for larger amplitudes and may lead to complex dynamics. Driving Amplitude ( \\(F_D/(mL)\\) ): Increasing the driving amplitude increases the steady-state oscillation amplitude. Very high driving amplitudes can push the system into a nonlinear regime, potentially resulting in chaotic motion. Driving Frequency ( \\(\\Omega\\) ): When \\(\\Omega\\) is near \\(\\omega_0\\) , the system experiences resonance. As \\(\\Omega\\) varies, the system may transition between regular (periodic) motion and chaotic behavior.","title":"Parameter Influences"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"Regular Motion: For moderate values of damping and driving amplitude, the pendulum displays periodic oscillations. Chaotic Motion: Under low damping or high driving amplitude, the system becomes highly sensitive to initial conditions, leading to chaotic behavior. Visualization Tools: Phase portraits and Poincar\u00e9 sections are used to reveal the underlying structure of the motion and the transition to chaos.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-practical-applications-and-limitations","text":"","title":"4. Practical Applications and Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#applications","text":"Energy Harvesting: Systems can be designed to exploit resonance, thereby maximizing energy absorption from periodic forces. Structural Engineering: Understanding forced oscillations is crucial in designing structures (e.g., suspension bridges, vibration isolation systems) that must withstand periodic loads. Oscillating Circuits: The behavior of driven RLC circuits is analogous to the forced damped pendulum, informing the design of filters and resonant circuits.","title":"Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations","text":"The small-angle approximation simplifies the analysis but is only valid for small displacements. The model neglects effects such as nonlinear damping and non-periodic driving forces, which may be significant in real-world systems. For larger oscillations, the full nonlinear equation (with \\(\\sin\\theta\\) ) should be used.","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-implementation-python-simulation","text":"","title":"5. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#51-first-simulation","text":"In this first simulation, we produce three key plots to analyze the forced damped pendulum\u2019s motion: A time series plot of \\(\\theta(t)\\) A phase portrait ( \\(\\theta\\) vs. \\(\\dot{\\theta}\\) ) A Poincar\u00e9 section to capture periodic and chaotic dynamics Below is the Python code for our initial simulation under the small-angle approximation. It uses solve_ivp to integrate the system, then plots the results. For now, we run one set of parameters ( \\(\\beta=0.25\\) , \\(F_D=1.2\\) , \\(\\Omega=2/3\\) , etc.): import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def run_forced_damped_pendulum(beta=0.25, F_D=1.2, Omega=2/3, t_span=(0, 100), y0=(0.1, 0.0), use_small_angle=True): \"\"\" Simulates and plots the forced damped pendulum. Parameters: ----------- beta : float Damping coefficient. F_D : float Driving force amplitude (N). Omega : float Driving frequency (rad/s). t_span : tuple Start and end time for the simulation, e.g. (0, 100). y0 : Initial conditions (theta, omega). use_small_angle : bool If True, use the small-angle approximation (sin(theta) ~ theta). If False, use the full nonlinear equation sin(theta). \"\"\" g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # pendulum length (m) m = 1.0 # mass (kg) # Natural frequency omega0 = np.sqrt(g / L) # Driving force term driving_force = F_D / (m * L) # Define the ODE def forced_damped_pendulum(t, y): theta, omega = y # Corrected: Added theta dtheta_dt = omega if use_small_angle: # Small-angle approximation: sin(theta) ~ theta restoring = -omega0**2 * theta else: # Full nonlinear: sin(theta) restoring = -omega0**2 * np.sin(theta) domega_dt = -2 * beta * omega + restoring + driving_force * np.cos(Omega * t) return [dtheta_dt, domega_dt] # Create a time array for evaluation t_eval = np.linspace(t_span[0], t_span[1], 10000) # Solve the ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, rtol=1e-8) # Corrected: Changed t to t_eval t = sol.t theta = sol.y[0] # Corrected: Added theta omega = sol.y[1] # --- PLOTS --- # 1) Time of Theta(t) plt.figure(figsize=(10, 4)) plt.plot(t, theta, 'b-', label=r'$\\theta(t)$') # Corrected: Changed plt to plt.plot plt.xlabel('Time (s)') # Corrected: Indentation plt.ylabel('Angle (rad)') plt.title(f'Time Series (beta={beta}, F_D={F_D}, Omega={Omega})') plt.legend() plt.grid(True) plt.tight_layout() plt.show() # 2) Phase Portrait (theta vs. omega) plt.figure(figsize=(6, 6)) plt.plot(theta, omega, 'r-', lw=0.8) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Phase Portrait (beta={beta}, F_D={F_D}, Omega={Omega})') plt.grid(True) plt.tight_layout() plt.show() # 3) Poincar\u00e9 Section # Sample points at every period T_drive = 2*pi/Omega after a transient T_drive = 2 * np.pi / Omega # Skip initial transients (e.g., first 50 cycles) skip_cycles = 50 # Corrected: Added = poincare_times = np.arange(skip_cycles * T_drive, t_span[1], T_drive) poincare_thetas = np.interp(poincare_times, t, theta) poincare_omegas = np.interp(poincare_times, t, omega) plt.figure(figsize=(6, 6)) plt.scatter(poincare_thetas, poincare_omegas, c='green', s=25) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Poincar\u00e9 Section (beta={beta}, F_D={F_D}, Omega={Omega})') plt.grid(True) plt.tight_layout() plt.show() # Main function to run multiple simulations def main(): # Define parameter ranges damping_coefficients = [0.1, 0.25, 0.5] # Different damping coefficients driving_forces = [0.5, 1.0, 1.5] # Different driving forces driving_frequencies = [1/2, 1, 2] # Different driving frequencies # Run simulations for different combinations of parameters for beta in damping_coefficients: for F_D in driving_forces: for Omega in driving_frequencies: run_forced_damped_pendulum(beta=beta, F_D=F_D, Omega=Omega, t_span=(0, 100), y0=(0.1, 0.0), use_small_angle=True) if __name__ == \"__main__\": main()","title":"5.1. First Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#outputs-for-the-first-simulation","text":"Running this script with \\((\\beta=0.25)\\) , \\((F_D=1.2)\\) , \\((\\Omega=2/3)\\) , and use_small_angle = True produces three plots : Time Series: Phase portrait Time Series (beta=01, F_D=0.5, Omega=1) Phase Portait( beta=0.1 F_D=0.5, Omega=1 ) Time series (beta=0.1 F_D=0.5, Omega=2 Time series (beta=0.1 F_D=1.0, Omega=0.5 Phase Portrait (beta=01, F_D=1.0, Omega=0.2) Phase Portait( beta=0.1 F_D=1.0, Omega=1 Time Series (beta=0.1, F_D=1.0, Omega=1) Portrait (Beta=0.1, Fr_D=1.0, Omega=2)","title":"Outputs for the First Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation","text":"Time Series: Shows how \\(\\theta(t)\\) evolves over time. A nearly sinusoidal plot indicates that the pendulum exhibits stable periodic motion. Phase Portrait: Plots \\(\\theta\\) versus \\(\\dot{\\theta}\\) . A closed loop in \\(\\theta\\) \u2013 \\(\\dot{\\theta}\\) space indicates a stable periodic orbit. Poincar\u00e9 Section: Samples the phase space at intervals of the driving period. A small set of discrete points indicates that the system is in regular, periodic motion rather than chaotic behavior. Small-Angle Approximation: Since use_small_angle = True , we use \\(\\sin(\\theta) \\approx \\theta\\) . This typically yields simpler, near-harmonic motion for moderate parameter values. Stable Periodic Orbit: Under \\((\\beta = 0.25)\\) , \\((F_D = 1.2)\\) , and \\((\\Omega = \\tfrac{2}{3})\\) , the pendulum exhibits a stable periodic solution\u2014evident from the sinusoidal time series, single-loop phase portrait, and a small set of points in the Poincar\u00e9 section. Potential Extensions: Set use_small_angle = False to use the full nonlinear equation \\(\\sin(\\theta)\\) , which can yield chaotic solutions for certain parameter ranges. Vary \\(\\beta\\) (damping), \\(F_D\\) (driving amplitude), and \\(\\Omega\\) (driving frequency) to see more complex dynamics, including chaos.","title":"Explanation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#52-second-simulation-exploring-more-complex-dynamics","text":"To explore more complex or chaotic behavior, we can turn off the small\u2010angle approximation and adjust parameters such as damping and driving amplitude. In the following example, we lower the damping and increase the driving force: Damping coefficient: \\(\\beta = 0.2\\) Driving amplitude: \\(F_D = 1.5\\) Driving frequency: \\(\\Omega = \\tfrac{2}{3}\\) Full nonlinear equation (i.e., \\(\\sin(\\theta)\\) instead of \\(\\theta\\) ) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def run_forced_damped_pendulum(beta=0.2, F_D=1.5, Omega=2/3, t_span=(0, 200), y0=(0.2, 0.0), use_small_angle=False): \"\"\" Simulates and plots the forced damped pendulum with more extreme parameters, potentially leading to chaotic motion. \"\"\" g = 9.81 L = 1.0 m = 1.0 omega0 = np.sqrt(g / L) driving_force = F_D / (m * L) def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega if use_small_angle: restoring = -omega0**2 * theta else: restoring = -omega0**2 * np.sin(theta) domega_dt = -2 * beta * omega + restoring + driving_force * np.cos(Omega * t) return [dtheta_dt, domega_dt] t_eval = np.linspace(t_span[0], t_span[1], 20000) sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, rtol=1e-8) t = sol.t theta = sol.y[0] omega = sol.y[1] # Time Series plt.figure(figsize=(10, 4)) plt.plot(t, theta, 'b-', label=r'$\\theta(t)$') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title(f'Time Series (beta={beta}, F_D={F_D}, Omega={Omega}, Nonlinear)') plt.legend() plt.grid(True) plt.tight_layout() plt.show() # Phase Portrait plt.figure(figsize=(6, 6)) plt.plot(theta, omega, 'r-', lw=0.8) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Phase Portrait (beta={beta}, F_D={F_D}, Omega={Omega}, Nonlinear)') plt.grid(True) plt.tight_layout() plt.show() # Poincar\u00e9 Section T_drive = 2 * np.pi / Omega skip_cycles = 50 poincare_times = np.arange(skip_cycles * T_drive, t_span[1], T_drive) poincare_thetas = np.interp(poincare_times, t, theta) poincare_omegas = np.interp(poincare_times, t, omega) plt.figure(figsize=(6, 6)) plt.scatter(poincare_thetas, poincare_omegas, c='green', s=25) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Poincar\u00e9 Section (beta={beta}, F_D={F_D}, Omega={Omega}, Nonlinear)') plt.grid(True) plt.tight_layout() plt.show() if __name__ == \"__main__\": run_forced_damped_pendulum()","title":"5.2. Second Simulation (Exploring More Complex Dynamics)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#outputs-for-the-second-simulation","text":"Running this script with \\((\\beta=0.2\\) ), \\((F_D=1.5)\\) , \\(\\Omega=\\tfrac{2}{3}\\) , and use_small_angle = False often yields more complex or chaotic motion. You might see: Time Series: The waveform can become irregular, indicating non-periodic or chaotic behavior. Phase Portrait Instead of a single closed loop, the trajectory in \\(\\theta\\) \u2013 \\(\\dot{\\theta}\\) space may fill an area or form a strange attractor, characteristic of chaos. Poincar\u00e9 Section A scattered \u201ccloud\u201d of points, rather than a finite set, implies chaotic dynamics.","title":"Outputs for the Second Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation_1","text":"Nonlinear Equation : We set use_small_angle = False so that \\(\\sin(\\theta)\\) is used instead of \\(\\theta\\) . This allows for larger amplitude oscillations and the possibility of chaos. Lower Damping, Higher Drive : \\(\\beta=0.2\\) is smaller than the previous 0.25, so the system loses energy more slowly. \\(F_D=1.5\\) is greater than 1.2, delivering more external energy per cycle. Together, these changes push the pendulum into a regime where chaotic behavior is more likely. Longer Time Span : We increased t_span to (0, 200) to observe the long-term evolution. Chaos sometimes takes a while to emerge or settle into an attractor. Potential Observations : If the motion is chaotic, the phase portrait and Poincar\u00e9 section won\u2019t settle into a simple loop or small set of points. You may see a scattered or more \u201cfilled-in\u201d region in phase space. With this second simulation, I demonstrate how changing parameters (especially lowering damping and increasing driving amplitude) can lead from stable periodic motion to more complex or chaotic behavior in the forced damped pendulum.","title":"Explanation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-discussion","text":"General Solutions: With the small-angle approximation and moderate parameters, the pendulum typically remains in a regular periodic orbit . However, for certain parameter sets (e.g., lower damping, higher driving amplitude, or using the full \\(\\sin(\\theta)\\) ), it can transition to chaotic motion . Graphical Representations: Time Series: Depicts how \\(\\theta\\) changes over time. Phase Portrait: Shows \\(\\theta\\) vs. \\(\\dot{\\theta}\\) , revealing periodic loops or chaotic attractors. Poincar\u00e9 Section: Captures the system\u2019s state once every driving period, distinguishing periodic from chaotic dynamics. Limitations & Future Work: The small-angle approximation may fail for larger amplitudes. Nonlinear damping or non-periodic driving forces can further complicate real-world behavior.","title":"6. Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#comparison-of-the-two-simulations","text":"Equations and Approximations: First Simulation uses the small-angle approximation \\(\\sin(\\theta)\\approx \\theta\\) . This linearizes the pendulum\u2019s restoring force, typically yielding stable, near-harmonic motion for moderate parameters. Second Simulation employs the full nonlinear equation \\(\\sin(\\theta)\\) . This allows for larger amplitude oscillations and the possibility of chaotic regimes under more extreme parameters. Parameter Choices: First Simulation : \\(\\beta=0.25,\\; F_D=1.2,\\; \\Omega=\\tfrac{2}{3},\\; \\text{use\\_small\\_angle = True}\\) . These moderate values produce a stable periodic orbit. Second Simulation : \\(\\beta=0.2,\\; F_D=1.5,\\; \\Omega=\\tfrac{2}{3},\\; \\text{use\\_small\\_angle=False}\\) . Lower damping and higher driving force are designed to push the system into more complex or chaotic motion. Observations in the Plots: Time Series : First Simulation : A smooth, sinusoidal-like wave indicating periodic motion. Second Simulation : Potentially more irregular or broader swings if chaos emerges. Phase Portrait \\((\\theta\\) vs. \\(\\dot{\\theta}\\) ): First Simulation : A single closed loop consistent with a periodic orbit. Second Simulation : May fill an area or produce more complicated loops, indicative of chaos or quasiperiodicity (depending on parameters). Poincar\u00e9 Section : First Simulation : A small set of discrete points reflects the regular (periodic) solution. Second Simulation : If truly chaotic, you\u2019d see a scattered cloud of points. However, it may still appear periodic if the parameters don\u2019t sufficiently drive chaos. Key Takeaways: The first (small-angle) simulation demonstrates how a forced damped pendulum can settle into a stable periodic orbit with moderate damping and driving. The second (full nonlinear) simulation attempts to highlight more extreme dynamics by reducing damping and increasing the driving force, thereby increasing the likelihood of chaos . If you still observe a periodic solution in the second simulation, you can further adjust parameters (e.g., reduce \\(\\beta\\) or raise \\(F_D\\) ) or extend the simulation time to reveal chaotic behavior.","title":"Comparison of the Two Simulations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#7-conclusion","text":"This investigation of the forced damped pendulum has: Derived the governing equations and provided an approximate solution for small oscillations. Analyzed how damping, driving amplitude, and driving frequency affect the system\u2019s dynamics. Illustrated the transition from periodic to chaotic behavior using time series , phase portraits , and Poincar\u00e9 sections . Demonstrated a computational simulation in Python that visualizes these dynamics. Overall, this study reinforces key concepts in nonlinear dynamics and provides a foundation for further exploration, including adjusting parameters to observe chaotic regimes or incorporating more realistic effects such as nonlinear damping.","title":"7. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius: An Analysis of Kepler's Third Law Introduction Kepler's Third Law of Planetary Motion states that the square of the orbital period (T) of a planet is directly proportional to the cube of the semi-major axis (r) of its orbit. This relationship can be expressed mathematically as: \\[ T^2 \\propto r^3 \\] or, more formally, \\[ \\frac{T^2}{r^3} = \\text{constant} \\] This law is fundamental in celestial mechanics and has significant implications for understanding the dynamics of planetary systems, satellite orbits, and gravitational interactions. Derivation of Kepler's Third Law For a circular orbit, the gravitational force provides the necessary centripetal force to keep a planet in orbit. The gravitational force ( F ) between two masses ( M ) (the mass of the central body) and ( m ) (the mass of the orbiting body) is given by Newton's law of gravitation: \\[ F = \\frac{G M m}{r^2} \\] where ( G ) is the gravitational constant. The centripetal force required to keep the mass ( m ) in a circular orbit of radius ( r ) with orbital speed ( v ) is: \\[ = \\frac{m v^2}{r} \\] Setting these two for force equal gives: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancelling m ) (assuming ( m \\neq 0 )) and rearranging yields: \\[ ^2 = \\frac{G M}{r} \\] The orbital period ( T ) is related to the orbital speed ( v ) and the circumference of the orbit: \\[ T = \\frac{2 \\pi r}{v} \\] Substituting ( v ) from the previous equation into this expression gives: \\[ T = 2 \\pi r \\sqrt{\\frac{r}{G M}} = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\] aring both sides results in: \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\] This confirms that ( T^2 \\propto r^3 ), establishing Kepler's Third Law. Implications for Astronomy Calculating Planetary Masses and Distances Kepler's Third Law allows astronomers to determine the mass of celestial bodies by observing the orbital periods and radii of their satellites. For example, by observing the orbital period of a moon around a planet, one can rearrange the equation to solve for the planet's mass: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] This relationship is crucial for understanding the dynamics of planetary systems and the gravitational interactions between bodies. Real-World Examples The Moon's Orbit Around Earth: The average distance from the Earth to the Moon is approximately 384,400 km, and its orbital period is about 27.3 days. Using Kepler's Third Law, we can verify the relationship and calculate the mass of the Earth. Orbits of Planets in the Solar System: The planets in our solar system follow Kepler's Third Law, allowing us to predict their orbital periods based on their distances from the Sun. Computational Model Below is a Python script that simulates circular orbits and verifies the relationship between the orbital period and radius. python import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun in kg Function to calculate orbital period def orbital_period(radius): return 2 * np.pi * np.sqrt(radius**3 / (G * M_sun)) Radii in meters (from 0.1 AU to 30 AU) radii = np.linspace(0.1 * 1.496e11, 30 * 1.496e11, 100) # 1 AU = 1.496e11 m periods = orbital_period(radii) Plotting the results plt.figure(figsize10, 6)) plt.plot(radii / 1.496e11 periods / (24 * 3600), label='Orbital Period (days)', color='blue') plt.title('Orbital Period vs. Orbital Radius') plt.xlabel('Orbital Radius (AU)') plt.ylabel('Orbital Period (days)') plt.xscale('log') plt.yscale('log') plt.grid() plt.legend() plt.show() Graphical Representation The plot generated by the above code show the relationship between the orbital radius (in astronomical units) and the orbital period (in days) on a logarithmic scale, illustrating the ( T^2 \\propto r^3 ) relationship. Additional Code for Simulating Circular Orbits We will extend the previous code to include multiple celestial bodies, such as the planets in our Solar System, and plot their orbital periods against their distances from the Sun. import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun in kg Function to calculate orbital period def orbital_period(radius): return 2 * np.pi * np.sqrt(radius**3 / (G * M_sun)) Radii in meters (from 0.1 AU to 30 AU) radii = np.linspace(0.1 * 1.496e11, 30 * 1.496e11, 100) # 1 AU = 1.496e11 m periods = orbital_period(radii) Plotting the relationship between radius and period plt.figure(figsize=(10, 6)) plt.plot(radii / 1.496e11, periods / (24 * 3600), label='Orbital Period (days)', color='blue') plt.title('Orbital Period vs. Orbital Radius') plt.xlabel('Orbital Radius (AU)') plt.ylabel('Orbital Period (days)') plt.xscale('log') plt.yscale('log') plt.grid() plt.legend() plt.show() Data for planets in the Solar System planet_names = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'] planet_radii = np.array([0.39, 0.72, 1.0, 1.52, 5.2, 9.58, 19.22, 30.07]) # in AU planet_periods = orbital_period(planet_radii * 1.496e11) / (24 * 3600 # Convert to days Plotting the planets plt.figure(figsize=(10, 6)) plt.scatter(planet_radii, planet_periods, color='red', label='ets') for i, name in enumerate(planet_names): plt.annotate(name, (planet_radii[i], planet_periods[i]), textcoords=\"offset points\", xytext=(0,10), ha='center') plt.title('Orbital Period of Planets in the Solar System') plt.xlabel('Orbital Radius (AU)') plt.ylabel('Orbital Period (days)') plt.xscale('log') plt.yscale('log') plt.grid() plt.legend() plt.show() Discussion on Elliptical Orbits While Kepler's Third Law is derived for circular orbits, it also applies to elliptical orbits. The semi-major axis of the ellipse can be used in place of the radius, and the law holds true. The relationship remains valid for all celestial bodies, including satellites, moons, and planets, regardless of the shape of their orbits. Conclusion Kepler's Third Law provides a fundamental understanding of the relationship between orbital period and radius, with significant implications for astronomy and celestial mechanics. By analyzing this relationship, we can gain insights into the dynamics of planetary systems and the gravitational interactions that govern them. The computational model further validates this relationship, demonstrating its applicability to real-world scenarios.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun in kg","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#function-to-calculate-orbital-period","text":"def orbital_period(radius): return 2 * np.pi * np.sqrt(radius**3 / (G * M_sun))","title":"Function to calculate orbital period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#radii-in-meters-from-01-au-to-30-au","text":"radii = np.linspace(0.1 * 1.496e11, 30 * 1.496e11, 100) # 1 AU = 1.496e11 m periods = orbital_period(radii)","title":"Radii in meters (from 0.1 AU to 30 AU)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plotting-the-results","text":"plt.figure(figsize10, 6)) plt.plot(radii / 1.496e11 periods / (24 * 3600), label='Orbital Period (days)', color='blue') plt.title('Orbital Period vs. Orbital Radius') plt.xlabel('Orbital Radius (AU)') plt.ylabel('Orbital Period (days)') plt.xscale('log') plt.yscale('log') plt.grid() plt.legend() plt.show() Graphical Representation The plot generated by the above code show the relationship between the orbital radius (in astronomical units) and the orbital period (in days) on a logarithmic scale, illustrating the ( T^2 \\propto r^3 ) relationship. Additional Code for Simulating Circular Orbits We will extend the previous code to include multiple celestial bodies, such as the planets in our Solar System, and plot their orbital periods against their distances from the Sun. import numpy as np import matplotlib.pyplot as plt","title":"Plotting the results"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants_1","text":"G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun in kg","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#function-to-calculate-orbital-period_1","text":"def orbital_period(radius): return 2 * np.pi * np.sqrt(radius**3 / (G * M_sun))","title":"Function to calculate orbital period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#radii-in-meters-from-01-au-to-30-au_1","text":"radii = np.linspace(0.1 * 1.496e11, 30 * 1.496e11, 100) # 1 AU = 1.496e11 m periods = orbital_period(radii)","title":"Radii in meters (from 0.1 AU to 30 AU)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plotting-the-relationship-between-radius-and-period","text":"plt.figure(figsize=(10, 6)) plt.plot(radii / 1.496e11, periods / (24 * 3600), label='Orbital Period (days)', color='blue') plt.title('Orbital Period vs. Orbital Radius') plt.xlabel('Orbital Radius (AU)') plt.ylabel('Orbital Period (days)') plt.xscale('log') plt.yscale('log') plt.grid() plt.legend() plt.show()","title":"Plotting the relationship between radius and period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#data-for-planets-in-the-solar-system","text":"planet_names = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'] planet_radii = np.array([0.39, 0.72, 1.0, 1.52, 5.2, 9.58, 19.22, 30.07]) # in AU planet_periods = orbital_period(planet_radii * 1.496e11) / (24 * 3600 # Convert to days","title":"Data for planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plotting-the-planets","text":"plt.figure(figsize=(10, 6)) plt.scatter(planet_radii, planet_periods, color='red', label='ets') for i, name in enumerate(planet_names): plt.annotate(name, (planet_radii[i], planet_periods[i]), textcoords=\"offset points\", xytext=(0,10), ha='center') plt.title('Orbital Period of Planets in the Solar System') plt.xlabel('Orbital Radius (AU)') plt.ylabel('Orbital Period (days)') plt.xscale('log') plt.yscale('log') plt.grid() plt.legend() plt.show() Discussion on Elliptical Orbits While Kepler's Third Law is derived for circular orbits, it also applies to elliptical orbits. The semi-major axis of the ellipse can be used in place of the radius, and the law holds true. The relationship remains valid for all celestial bodies, including satellites, moons, and planets, regardless of the shape of their orbits. Conclusion Kepler's Third Law provides a fundamental understanding of the relationship between orbital period and radius, with significant implications for astronomy and celestial mechanics. By analyzing this relationship, we can gain insights into the dynamics of planetary systems and the gravitational interactions that govern them. The computational model further validates this relationship, demonstrating its applicability to real-world scenarios.","title":"Plotting the planets"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities: Analysis and Simulation This solution presents a comprehensive explanation of the three key cosmic velocities\u2014first, second, and third\u2014along with their physical significance, detailed derivations, and simulations for Earth, Mars, and Jupiter. The content covers the theoretical background, advanced physics insights, computational implementation, and relevance to space exploration. Introduction Space missions require a thorough grasp of the velocities necessary to achieve various orbital and escape conditions. Beyond the basic definitions, understanding cosmic velocities involves energy conservation, orbital dynamics, and the interplay between a planet\u2019s and star\u2019s gravity. In this solution, we define: First Cosmic Velocity : The speed required for a spacecraft to maintain a circular orbit close to a celestial body's surface. Second Cosmic Velocity : The escape speed needed to overcome the gravitational pull of that body. Third Cosmic Velocity : The additional speed required, once free from a planet\u2019s gravity, to escape the gravitational influence of the central star (e.g., the Sun). Detailed Physics and Derivations 1. First Cosmic Velocity (v\u2081) \u2013 Orbital Mechanics For a celestial body with mass \\((M)\\) and radius \\((R)\\) , the first cosmic velocity is derived by equating the gravitational force to the centripetal force required for a circular orbit: \\[ \\frac{GM}{R^2} = \\frac{v_1^2}{R} \\Rightarrow v_1 = \\sqrt{\\frac{GM}{R}} \\] Physics Insight : This velocity decreases with increasing orbital radius as the gravitational pull weakens. For non-circular (elliptical) orbits, the vis-viva equation generalizes the orbital speed: $$ v = \\sqrt{GM\\left(\\frac{2}{r} - \\frac{1}{a}\\right)} $$ where \\(a\\) is the semi-major axis. In a low circular orbit, \\(r \\approx R\\) and \\(a \\approx R\\) , so \\(v \\approx v_1\\) . 2. Second Cosmic Velocity (v\u2082) \u2013 Escape Energy Escape velocity is determined by setting the total mechanical energy (kinetic plus potential) to zero so that the object reaches infinity with no residual speed: \\[ \\frac{1}{2}v_2^2 - \\frac{GM}{R} = 0 \\Rightarrow v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2}\\, v_1 \\] Physics Insight : The factor of \\(\\sqrt{2}\\) signifies the extra kinetic energy required to overcome the gravitational potential well. For \\(v < v_2\\) , the object remains bound (elliptical orbit), while for \\(v \\ge v_2\\) , the trajectory becomes parabolic or hyperbolic. 3. Third Cosmic Velocity (v\u2083) \u2013 Stellar Escape Escaping a star\u2019s gravitational field from a planet involves combining the planet\u2019s escape velocity with the dynamics of the star\u2019s gravity. Consider a planet at orbital radius \\(r\\) from its star: - The orbital speed of the planet is: $$ v_{\\text{orbit}} = \\sqrt{\\frac{GM_\\odot}{r}} $$ - The escape speed from the star at that distance is: $$ v_{\\text{esc,Sun}} = \\sqrt{\\frac{2GM_\\odot}{r}} $$ A spacecraft leaving the planet benefits from the planet\u2019s orbital speed. Hence, the additional speed needed relative to the star is given by: $$ v_3 = v_{\\text{esc,Sun}} - v_{\\text{orbit}} = \\sqrt{\\frac{GM_\\odot}{r}}\\,(\\sqrt{2} - 1) $$ Physics Insight : The subtraction of \\(v_{\\text{orbit}}\\) reflects that the planet\u2019s motion already contributes to the required energy for stellar escape. This makes \\(v_3\\) lower than \\(v_{\\text{esc,Sun}}\\) and highlights why gravitational assists (e.g., flybys of massive planets) can further reduce the propulsion needed. Additional Effects Atmospheric Drag : At low altitudes, air resistance reduces the effective velocity. It is modeled by: $$ F_{\\text{drag}} = \\frac{1}{2}\\rho v^2 C_d A$$ where \\((\\rho)\\) is air density, \\((C_d)\\) is the drag coefficient, and \\((A)\\) is the cross-sectional area. Gravitational Assists : Maneuvers near massive bodies (e.g., Jupiter) can boost a spacecraft\u2019s velocity via the Oberth effect, where applying thrust at high speeds in deep gravity wells yields maximum energy gain. Relativistic Corrections : Although typically negligible within the Solar System, at extremely high velocities or near massive bodies, general relativity modifies gravitational potential and orbital dynamics. Parameters for Celestial Bodies For the simulations, we use the following parameters: Earth: Mass: \\(5.972 \\times 10^{24}\\) \\(kg\\) Radius: \\(6.371 \\times 10^{6}\\) \\(m\\) Orbital radius: \\(1.496 \\times 10^{11}\\) \\(m\\) Mars: Mass: \\(6.4171 \\times 10^{23}\\) \\(kg\\) Radius: \\(3.3895 \\times 10^{6}\\) \\(m\\) Orbital radius: \\(2.279 \\times 10^{11}\\) \\(m\\) Jupiter: Mass: \\(1.898 \\times 10^{27}\\) \\(kg\\) Radius: \\(6.9911 \\times 10^{7}\\) \\(m\\) Orbital radius: \\(7.785 \\times 10^{11}\\) \\(m\\) For the Sun: Mass: \\(1.989 \\times 10^{30}\\) \\(kg\\) Computational Simulation and Visualization The following Python script computes the three cosmic velocities for Earth, Mars, and Jupiter, and visualizes the results with a bar chart. import math import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Parameters for celestial bodies: mass (kg), radius (m), and orbital radius around the Sun (m) bodies = { 'Earth': { 'mass': 5.972e24, 'radius': 6.371e6, 'orbital_radius': 1.496e11 }, 'Mars': { 'mass': 6.4171e23, 'radius': 3.3895e6, 'orbital_radius': 2.279e11 }, 'Jupiter': { 'mass': 1.898e27, 'radius': 6.9911e7, 'orbital_radius': 7.785e11 } } results = {} for body, params in bodies.items(): mass = params['mass'] radius = params['radius'] orbital_radius = params['orbital_radius'] # First cosmic velocity: circular orbital speed at the surface of the body v1 = math.sqrt(G * mass / radius) # Second cosmic velocity: escape velocity from the body v2 = math.sqrt(2 * G * mass / radius) # Orbital speed of the body around the Sun v_orbit = math.sqrt(G * M_sun / orbital_radius) # Solar escape speed at the body's orbital distance v_esc_sun = math.sqrt(2 * G * M_sun / orbital_radius) # Third cosmic velocity: additional speed required to overcome the Sun's gravity v3 = v_esc_sun - v_orbit results[body] = {'v1': v1, 'v2': v2, 'v3': v3, 'v_orbit': v_orbit, 'v_esc_sun': v_esc_sun} # Display the calculated velocities for each body for body, vals in results.items(): print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {vals['v1']:.2f} m/s ({vals['v1']/1000:.2f} km/s)\") print(f\" Second Cosmic Velocity (v2): {vals['v2']:.2f} m/s ({vals['v2']/1000:.2f} km/s)\") print(f\" Third Cosmic Velocity (v3): {vals['v3']:.2f} m/s ({vals['v3']/1000:.2f} km/s)\") print() # Prepare data for plotting (convert m/s to km/s) labels = list(bodies.keys()) v1_values = [results[body]['v1']/1000 for body in labels] v2_values = [results[body]['v2']/1000 for body in labels] v3_values = [results[body]['v3']/1000 for body in labels] x = range(len(labels)) bar_width = 0.25 fig, ax = plt.subplots(figsize=(10, 6)) ax.bar([p - bar_width for p in x], v1_values, width=bar_width, label='First Cosmic Velocity (km/s)') ax.bar(x, v2_values, width=bar_width, label='Second Cosmic Velocity (km/s)') ax.bar([p + bar_width for p in x], v3_values, width=bar_width, label='Third Cosmic Velocity (km/s)') ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.show() Simulation Output Explanation of the Output The simulation output is presented as a bar chart that compares the three key cosmic velocities for Earth, Mars, and Jupiter. Here\u2019s what the chart represents: X-axis : The different celestial bodies (Earth, Mars, Jupiter). Y-axis : The computed velocities in km/s. For each celestial body, three sets of bars are displayed: - First Cosmic Velocity (v\u2081) : Indicates the orbital speed necessary for a stable, circular orbit near the body's surface. - Second Cosmic Velocity (v\u2082) : Represents the escape speed required to overcome the gravitational binding of the body. Note that this value is always \\(\\sqrt{2}\\) times the first cosmic velocity. - Third Cosmic Velocity (v\u2083) : Shows the additional velocity needed (beyond the planet\u2019s orbital speed) to escape the gravitational influence of the Sun. This visualization clearly illustrates the differences between the velocities for various celestial bodies and highlights the impact of their mass, size, and orbital distances on mission planning. The reduced third cosmic velocity (compared to the solar escape speed) underscores the advantage provided by a planet\u2019s orbital motion in reducing the energy requirements for interplanetary travel. Additional Simulation: 1. Variation of Cosmic Velocities with Planet Mass import math import numpy as np import matplotlib.pyplot as plt \"\"\" This script varies each planet's mass from 80% to 120% of its nominal (real) mass and plots two key velocities: 1) v\u2081 (Orbital) = \u221a(GM/R), the speed for a circular orbit near the surface. 2) v\u2082 (Escape) = \u221a(2GM/R), the speed required to escape the planet's gravity. We highlight the real (nominal) mass point on BOTH v\u2081 and v\u2082 with black 'X' markers, but we do not show any arrow/text annotations. All other points are hypothetical. \"\"\" # Constants G = 6.67430e-11 # Gravitational constant [m^3 kg^-1 s^-2] M_sun = 1.989e30 # Mass of the Sun [kg] - not directly used here # Planetary parameters bodies = { 'Earth': { 'mass': 5.972e24, 'radius': 6.371e6 }, 'Mars': { 'mass': 6.4171e23, 'radius': 3.3895e6 }, 'Jupiter': { 'mass': 1.898e27, 'radius': 6.9911e7 } } # Range of mass factors (80% to 120% of nominal) mass_factors = np.array([0.8, 0.9, 1.0, 1.1, 1.2]) plt.figure(figsize=(12, 7)) # We'll only add the 'Real Mass' label once in the legend real_mass_label_added = False for planet, params in bodies.items(): nominal_mass = params['mass'] radius = params['radius'] # Arrays for v\u2081 and v\u2082 over the specified mass factors v1_values = [] # v\u2081 (Orbital) v2_values = [] # v\u2082 (Escape) for factor in mass_factors: mass = factor * nominal_mass v1 = math.sqrt(G * mass / radius) # m/s v2 = math.sqrt(2 * G * mass / radius) # m/s v1_values.append(v1 / 1000) # Convert to km/s v2_values.append(v2 / 1000) # Convert to km/s # x-axis in units of 10^24 kg x_values = mass_factors * nominal_mass / 1e24 # Plot v\u2081 (Orbital) and v\u2082 (Escape) plt.plot(x_values, v1_values, marker='o', linestyle='-', markersize=8, linewidth=2, label=f'{planet} v\u2081 (Orbital)') plt.plot(x_values, v2_values, marker='s', linestyle='--', markersize=8, linewidth=2, label=f'{planet} v\u2082 (Escape)') # Find the index for the nominal mass (factor=1.0) idx_nom = np.where(mass_factors == 1.0)[0][0] real_mass_x = x_values[idx_nom] # Extract the v\u2081 and v\u2082 values at the nominal mass real_mass_v1 = v1_values[idx_nom] real_mass_v2 = v2_values[idx_nom] # Plot black X marker on v\u2081 at nominal mass if not real_mass_label_added: # Add the label for the FIRST black X only plt.scatter(real_mass_x, real_mass_v1, color='black', marker='X', s=100, zorder=5, label='Real Mass (Nominal)') real_mass_label_added = True else: plt.scatter(real_mass_x, real_mass_v1, color='black', marker='X', s=100, zorder=5) # Plot black X marker on v\u2082 at nominal mass (no legend label) plt.scatter(real_mass_x, real_mass_v2, color='black', marker='X', s=100, zorder=5) # Optional: use a log scale if masses differ by orders of magnitude plt.xscale('log') plt.xlabel('Planet Mass (10^24 kg) [log scale]') plt.ylabel('Velocity (km/s)') plt.title('Variation of Cosmic Velocities with Planet Mass (v\u2081 and v\u2082)') plt.grid(True) # Initial legend call plt.legend() # Reorder legend so 'Real Mass (Nominal)' is first handles, labels = plt.gca().get_legend_handles_labels() rm_index = labels.index('Real Mass (Nominal)') new_handles = [handles[rm_index]] + handles[:rm_index] + handles[rm_index+1:] new_labels = [labels[rm_index]] + labels[:rm_index] + labels[rm_index+1:] plt.legend(new_handles, new_labels) plt.show() Simulation Output Explanation of the Mass-Variation Simulation This is purely a theoretical exercise \u2014planets don\u2019t spontaneously gain or lose 20% of their mass in reality. Varying the mass helps us understand how strongly these orbital and escape velocities depend on a planet\u2019s gravitational parameter \\(GM\\) . In this simulation we explore how two key velocities\u2014 \\(v\u2081\\) (Orbital Velocity) and \\(v\u2082\\) (Escape Velocity) \u2014depend on a planet\u2019s mass, using hypothetical variations of 80% to 120% of its nominal (actual) mass. Here\u2019s what each part means: Varying the Mass: We multiply the nominal mass of each planet by factors of 0.8, 0.9, 1.0, 1.1, and 1.2. This produces a set of hypothetical masses. Only the factor 1.0 corresponds to the real, physically measured mass. Changing the mass in the equations allows us to see how the gravitational parameter \\(GM\\) influences the speeds, even though in reality a planet\u2019s mass remains fixed. Calculating the Velocities: v\u2081 (Orbital Velocity): $$ v\u2081 = \\sqrt{\\frac{GM}{R}} $$ This is the speed required to maintain a circular orbit right at the planet\u2019s surface. It depends on both the planet\u2019s mass and its radius (which remains constant in our simulation). v\u2082 (Escape Velocity): $$ v\u2082 = \\sqrt{\\frac{2GM}{R}} $$ This is the speed required for a spacecraft to escape the planet\u2019s gravitational pull. It is always \\(\\sqrt{2}\\) times \\(v\u2081\\) . Real Mass Markers: For each planet, the data point computed at the mass factor of 1.0 is the only physically real value because it uses the planet\u2019s actual mass. We mark this real (nominal) mass point on both the \\(v\u2081\\) and \\(v\u2082\\) curves with a black \u201cX.\u201d Although the two markers appear at the same mass value on the x-axis, they represent two different speeds: one for orbital motion \\((v\u2081)\\) and one for escape \\((v\u2082)\\) . These markers help you distinguish between the real (nominal) scenario and the other hypothetical cases (0.8, 0.9, 1.1, and 1.2 factors). Logarithmic X-axis: The x-axis is set to a log scale because Jupiter\u2019s mass is many orders of magnitude larger than Earth\u2019s or Mars\u2019. This scaling prevents the smaller masses from being squashed near zero and makes all data points easier to compare visually. Interpretation Scaling with Mass: As the mass increases, both v\u2081 and v\u2082 increase in accordance with \\(\\sqrt{M}\\) . This explains why Jupiter\u2019s velocities are significantly higher than Earth\u2019s or Mars\u2019. Sensitivity Analysis: Although the mass variations are purely hypothetical, they illustrate how changes in the gravitational parameter \\(GM\\) affect the orbital and escape speeds. Practical Distinction: The two velocities represent different physical requirements: v\u2081 (Orbital Velocity) is the speed needed for a stable orbit near the planet\u2019s surface. v\u2082 (Escape Velocity) is the higher speed required to overcome the planet\u2019s gravitational pull. The black \\(\u201cX\u201d\\) markers at the nominal mass (mass factor = 1.0) indicate the actual speeds computed using the planet\u2019s true mass, while the other points show \u201cwhat-if\u201d scenarios. Overall, this exercise reveals the direct relationship between planetary mass and the speeds needed for orbiting and escaping. It provides insight into how sensitive these speeds are to changes in \\(GM\\) , even though in practice a planet\u2019s mass does not change. 2. Additional Simulation: Nominal Cosmic Velocities for Earth, Mars, and Jupiter Purpose: Each velocity is represented as a uniquely colored arrow with a label placed near its tip. This approach not only shows the individual values but also allows direct visual comparison of how these velocities differ among Earth, Mars, and Jupiter. Code for Earth import math import numpy as np import matplotlib.pyplot as plt # -------------------------- Nominal Cosmic Velocities for Earth -------------------------- # Earth nominal parameters mass_earth = 5.972e24 # kg radius_earth = 6.371e6 # m orbital_radius_earth = 1.496e11 # m # Compute Earth's nominal velocities v1_earth = math.sqrt(6.67430e-11 * mass_earth / radius_earth) # Orbital velocity [m/s] v2_earth = math.sqrt(2 * 6.67430e-11 * mass_earth / radius_earth) # Escape velocity [m/s] v_orbit_earth = math.sqrt(6.67430e-11 * 1.989e30 / orbital_radius_earth) # Earth's orbital speed around the Sun [m/s] v_esc_sun_earth = math.sqrt(2 * 6.67430e-11 * 1.989e30 / orbital_radius_earth) # Solar escape speed [m/s] v3_earth = v_esc_sun_earth - v_orbit_earth # Additional speed for solar escape [m/s] # Convert to km/s v1_earth_km = v1_earth / 1000 v2_earth_km = v2_earth / 1000 v_orbit_earth_km = v_orbit_earth / 1000 v_esc_sun_earth_km = v_esc_sun_earth / 1000 v3_earth_km = v3_earth / 1000 # Define velocities for Earth with unique angles and colors velocities_earth = [ {'label': 'v\u2081 (Orbital)', 'speed': v1_earth_km, 'angle': 0, 'color': 'C0'}, {'label': 'v\u2082 (Escape)', 'speed': v2_earth_km, 'angle': 45, 'color': 'C1'}, {'label': 'v_orbit', 'speed': v_orbit_earth_km, 'angle': 90, 'color': 'C2'}, {'label': 'v_esc,Sun', 'speed': v_esc_sun_earth_km, 'angle': 135, 'color': 'C3'}, {'label': 'v\u2083', 'speed': v3_earth_km, 'angle': 180, 'color': 'C4'} ] plt.figure(figsize=(8,8)) origin = (0,0) for vel in velocities_earth: label = vel['label'] speed = vel['speed'] angle = np.deg2rad(vel['angle']) dx = speed * np.cos(angle) dy = speed * np.sin(angle) plt.arrow(origin[0], origin[1], dx, dy, head_width=0.5, head_length=1, length_includes_head=True, color=vel['color'], alpha=0.8, label=label) plt.text(dx * 1.05, dy * 1.05, label, fontsize=10, color=vel['color'], ha='center', va='center') handles, labels = plt.gca().get_legend_handles_labels() by_label = dict(zip(labels, handles)) plt.legend(by_label.values(), by_label.keys()) max_speed = max(vel['speed'] for vel in velocities_earth) plt.xlim(-max_speed - 5, max_speed + 5) plt.ylim(-max_speed - 5, max_speed + 5) plt.xlabel('Velocity component (km/s)') plt.ylabel('Velocity component (km/s)') plt.title('Nominal Cosmic Velocities for Earth') plt.grid(True) plt.show() Code for Mars import math import numpy as np import matplotlib.pyplot as plt # -------------------------- Nominal Cosmic Velocities for Mars -------------------------- # Mars nominal parameters mass_mars = 6.4171e23 # kg radius_mars = 3.3895e6 # m orbital_radius_mars = 2.279e11 # m # Compute Mars' nominal velocities v1_mars = math.sqrt(6.67430e-11 * mass_mars / radius_mars) # Orbital velocity [m/s] v2_mars = math.sqrt(2 * 6.67430e-11 * mass_mars / radius_mars) # Escape velocity [m/s] v_orbit_mars = math.sqrt(6.67430e-11 * 1.989e30 / orbital_radius_mars) # Mars' orbital speed around the Sun [m/s] v_esc_sun_mars = math.sqrt(2 * 6.67430e-11 * 1.989e30 / orbital_radius_mars) # Solar escape speed [m/s] v3_mars = v_esc_sun_mars - v_orbit_mars # Additional speed for solar escape [m/s] # Convert to km/s v1_mars_km = v1_mars / 1000 v2_mars_km = v2_mars / 1000 v_orbit_mars_km = v_orbit_mars / 1000 v_esc_sun_mars_km = v_esc_sun_mars / 1000 v3_mars_km = v3_mars / 1000 # Define velocities for Mars with unique angles and colors velocities_mars = [ {'label': 'v\u2081 (Orbital)', 'speed': v1_mars_km, 'angle': 0, 'color': 'C0'}, {'label': 'v\u2082 (Escape)', 'speed': v2_mars_km, 'angle': 45, 'color': 'C1'}, {'label': 'v_orbit', 'speed': v_orbit_mars_km, 'angle': 90, 'color': 'C2'}, {'label': 'v_esc,Sun', 'speed': v_esc_sun_mars_km, 'angle': 135, 'color': 'C3'}, {'label': 'v\u2083', 'speed': v3_mars_km, 'angle': 180, 'color': 'C4'} ] plt.figure(figsize=(8,8)) origin = (0,0) for vel in velocities_mars: label = vel['label'] speed = vel['speed'] angle = np.deg2rad(vel['angle']) dx = speed * np.cos(angle) dy = speed * np.sin(angle) plt.arrow(origin[0], origin[1], dx, dy, head_width=0.5, head_length=1, length_includes_head=True, color=vel['color'], alpha=0.8, label=label) plt.text(dx * 1.05, dy * 1.05, label, fontsize=10, color=vel['color'], ha='center', va='center') handles, labels = plt.gca().get_legend_handles_labels() by_label = dict(zip(labels, handles)) plt.legend(by_label.values(), by_label.keys()) max_speed = max(vel['speed'] for vel in velocities_mars) plt.xlim(-max_speed - 5, max_speed + 5) plt.ylim(-max_speed - 5, max_speed + 5) plt.xlabel('Velocity component (km/s)') plt.ylabel('Velocity component (km/s)') plt.title('Nominal Cosmic Velocities for Mars') plt.grid(True) plt.show() Code for Jupiter import math import numpy as np import matplotlib.pyplot as plt # -------------------------- Nominal Cosmic Velocities for Jupiter -------------------------- # Jupiter nominal parameters mass_jupiter = 1.898e27 # kg radius_jupiter = 6.9911e7 # m orbital_radius_jupiter = 7.785e11 # m # Compute Jupiter's nominal velocities v1_jupiter = math.sqrt(6.67430e-11 * mass_jupiter / radius_jupiter) # Orbital velocity [m/s] v2_jupiter = math.sqrt(2 * 6.67430e-11 * mass_jupiter / radius_jupiter) # Escape velocity [m/s] v_orbit_jupiter = math.sqrt(6.67430e-11 * 1.989e30 / orbital_radius_jupiter) # Jupiter's orbital speed around the Sun [m/s] v_esc_sun_jupiter = math.sqrt(2 * 6.67430e-11 * 1.989e30 / orbital_radius_jupiter) # Solar escape speed [m/s] v3_jupiter = v_esc_sun_jupiter - v_orbit_jupiter # Additional speed for solar escape [m/s] # Convert to km/s v1_jupiter_km = v1_jupiter / 1000 v2_jupiter_km = v2_jupiter / 1000 v_orbit_jupiter_km = v_orbit_jupiter / 1000 v_esc_sun_jupiter_km = v_esc_sun_jupiter / 1000 v3_jupiter_km = v3_jupiter / 1000 # Define velocities for Jupiter with unique angles and colors velocities_jupiter = [ {'label': 'v\u2081 (Orbital)', 'speed': v1_jupiter_km, 'angle': 0, 'color': 'C0'}, {'label': 'v\u2082 (Escape)', 'speed': v2_jupiter_km, 'angle': 45, 'color': 'C1'}, {'label': 'v_orbit', 'speed': v_orbit_jupiter_km, 'angle': 90, 'color': 'C2'}, {'label': 'v_esc,Sun', 'speed': v_esc_sun_jupiter_km, 'angle': 135, 'color': 'C3'}, {'label': 'v\u2083', 'speed': v3_jupiter_km, 'angle': 180, 'color': 'C4'} ] plt.figure(figsize=(8,8)) origin = (0,0) for vel in velocities_jupiter: label = vel['label'] speed = vel['speed'] angle = np.deg2rad(vel['angle']) dx = speed * np.cos(angle) dy = speed * np.sin(angle) plt.arrow(origin[0], origin[1], dx, dy, head_width=0.5, head_length=1, length_includes_head=True, color=vel['color'], alpha=0.8, label=label) plt.text(dx * 1.05, dy * 1.05, label, fontsize=10, color=vel['color'], ha='center', va='center') handles, labels = plt.gca().get_legend_handles_labels() by_label = dict(zip(labels, handles)) plt.legend(by_label.values(), by_label.keys()) max_speed = max(vel['speed'] for vel in velocities_jupiter) plt.xlim(-max_speed - 5, max_speed + 5) plt.ylim(-max_speed - 5, max_speed + 5) plt.xlabel('Velocity component (km/s)') plt.ylabel('Velocity component (km/s)') plt.title('Nominal Cosmic Velocities for Jupiter') plt.grid(True) plt.show() Explanation This set of simulations displays the nominal cosmic velocities for Earth, Mars, and Jupiter as vector arrows. Each simulation computes five key velocities for the given planet: \\(v\u2081\\) (Orbital Velocity): The speed needed for a circular orbit at the planet\u2019s surface. \\(v\u2082\\) (Escape Velocity): The speed required to escape the planet\u2019s gravitational pull \\((\\sqrt{2} times(v\u2081))\\) . \\(v_orbit\\) : The orbital speed of the planet around the Sun. \\(v_esc,Sun\\) : The escape speed from the Sun at the planet\u2019s orbital distance. \\(v\\) \u2083: The extra speed needed to overcome the Sun\u2019s gravitational pull (i.e. \\(v_{\\text{esc,Sun}} - v_{\\text{orbit}})\\) . Each arrow is plotted with a unique angle and color and labeled near its tip for clarity. By comparing these vector diagrams: Earth\u2019s arrows provide a baseline of speeds for a planet with moderate mass and size. Mars\u2019 arrows are noticeably shorter, reflecting its lower mass and weaker gravity. Jupiter\u2019s arrows are much longer, indicating significantly higher speeds due to its massive gravitational pull. This comprehensive simulation and the side-by-side image display help illustrate how planetary properties influence key cosmic speeds, which is vital for space mission planning. 3. Hohmann Transfer Simulation Purpose : Demonstrate how cosmic velocities are applied in interplanetary travel by simulating the most fuel-efficient path between Earth and Mars. Physics Link : - Uses the vis-viva equation (from the derivations) to calculate transfer orbit velocities. - Shows how a partial escape velocity (not full \\(v_2\\) ) is sufficient when leveraging the Sun\u2019s gravity. How It Differs from the Previous Simulation : - The bar chart compares theoretical thresholds ( \\(v_1\\) , \\(v_2\\) , \\(v_3\\) ). - This simulation models a practical application : computing the delta\u2011v needed for a Hohmann transfer between Earth and Mars, and visualizing the transfer trajectory. import numpy as np def hohmann_transfer(r1, r2, M_central): \"\"\" Compute velocities and delta-v for a Hohmann transfer between two circular orbits. Args: r1 (float): Initial orbital radius (m). r2 (float): Target orbital radius (m). M_central (float): Mass of the central body (kg). Returns: dict: Delta-v values and transfer parameters. \"\"\" # Circular orbit velocities v1 = np.sqrt(G * M_central / r1) # Initial orbit (Earth) v2 = np.sqrt(G * M_central / r2) # Target orbit (Mars) # Transfer ellipse velocities (at perihelion and aphelion) a_transfer = (r1 + r2) / 2 # Semi-major axis of the transfer ellipse v_peri = np.sqrt(2 * G * M_central * (1/r1 - 1/(2*a_transfer))) # Velocity at departure burn v_aphel = np.sqrt(2 * G * M_central * (1/r2 - 1/(2*a_transfer))) # Velocity at arrival burn # Delta-v maneuvers delta_v1 = v_peri - v1 # Burn to leave Earth orbit delta_v2 = v2 - v_aphel # Burn to match Mars orbit return { 'delta_v1': delta_v1, 'delta_v2': delta_v2, 'total_delta_v': delta_v1 + delta_v2, 'transfer_time': np.pi * np.sqrt(a_transfer**3 / (G * M_central)) # Using Kepler's third law } # Earth to Mars transfer parameters r_earth = 1.496e11 # Earth's orbital radius (m) r_mars = 2.279e11 # Mars' orbital radius (m) transfer = hohmann_transfer(r_earth, r_mars, M_sun) print(\"Hohmann Transfer Earth \u2192 Mars:\") print(f\"Delta-v1: {transfer['delta_v1']/1000:.2f} km/s (Departure burn)\") print(f\"Delta-v2: {transfer['delta_v2']/1000:.2f} km/s (Arrival burn)\") print(f\"Total \u0394v: {transfer['total_delta_v']/1000:.2f} km/s\") print(f\"Transfer Time: {transfer['transfer_time'] / (60*60*24):.0f} days\") # Plot the transfer trajectory theta = np.linspace(0, 2*np.pi, 100) fig, ax = plt.subplots(figsize=(8, 8)) ax.plot(r_earth * np.cos(theta), r_earth * np.sin(theta), label=\"Earth Orbit\") ax.plot(r_mars * np.cos(theta), r_mars * np.sin(theta), label=\"Mars Orbit\") # Calculate Hohmann transfer ellipse eccentricity = (r_mars - r_earth) / (r_mars + r_earth) theta_transfer = np.linspace(0, np.pi, 100) r_transfer = (r_earth + r_mars) / 2 * (1 - eccentricity**2) / (1 + eccentricity * np.cos(theta_transfer)) x_transfer = r_transfer * np.cos(theta_transfer) y_transfer = r_transfer * np.sin(theta_transfer) ax.plot(x_transfer, y_transfer, 'r--', label=\"Hohmann Transfer\") ax.set_title(\"Hohmann Transfer: Earth to Mars\") ax.set_xlabel(\"Distance (m)\") ax.set_ylabel(\"Distance (m)\") ax.legend() ax.grid() plt.axis('equal') plt.show() Output : Hohmann Transfer Earth \u2192 Mars: Delta-v1: 2.94 km/s (Departure burn) Delta-v2: 2.65 km/s (Arrival burn) Total \u0394v: 5.59 km/s Transfer Time: 259 days Explanation of the Hohmann Transfer Simulation Relationship to Cosmic Velocities: First Cosmic Velocity ( \\(v_1\\) ) : The spacecraft starts in Earth\u2019s orbit, moving at its heliocentric speed. Second Cosmic Velocity ( \\(v_2\\) ) : The departure burn \\((\\Delta v_1)\\) is less than Earth's full escape speed because the transfer only requires leaving Earth's sphere of influence. Third Cosmic Velocity ( \\(v_3\\) ) : Instead of achieving full solar escape speed, the spacecraft performs an arrival burn \\((\\Delta v_2)\\) to match Mars' orbital speed. Why This Matters : Demonstrates that only a partial delta\u2011v (compared to full escape velocities) is necessary for interplanetary transfers. Connects the theoretical cosmic velocity concepts with practical mission design, illustrating how energy-efficient transfers are achieved in space exploration. This section integrates a practical Hohmann transfer simulation with the cosmic velocities analysis, providing clear insight into how these theoretical concepts are applied to real-world space mission planning. Discussion and Relevance First Cosmic Velocity: Achieving this velocity is essential for inserting satellites into stable orbits. It reflects the balance between gravitational pull and centripetal force, ensuring that a spacecraft remains in continuous free-fall. Second Cosmic Velocity: This is the minimum speed required to overcome a celestial body's gravitational binding. Its derivation from energy conservation underlines the kinetic energy needed to reach infinity with zero residual speed. Third Cosmic Velocity: Beyond escaping a planet\u2019s gravity, a spacecraft must also overcome the star's gravitational pull. The combined effect of the planet\u2019s orbital velocity and the star\u2019s escape speed determines \\(v_3\\) . This velocity is key for interplanetary and, eventually, interstellar missions\u2014especially when augmented by gravitational assists. Applications in Space Exploration Satellite Deployment: The first and second cosmic velocities are critical for designing launch vehicles that can insert satellites into stable orbits or set them on escape trajectories. Interplanetary Transfers: Detailed calculations of these velocities enable the design of energy-efficient trajectories. Advanced techniques like Hohmann transfers and gravitational assists further optimize the delta\u2011v requirements. Advanced Mission Planning: Understanding these velocity thresholds is fundamental for conceptualizing future missions, whether for planetary exploration or interstellar travel, where optimizing fuel usage and trajectory design is paramount. This final solution combines rigorous theoretical derivations with practical simulations to offer a robust framework for understanding cosmic velocities. It provides both the mathematical foundation and computational tools needed for modern space mission planning.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"Space missions require a thorough grasp of the velocities necessary to achieve various orbital and escape conditions. Beyond the basic definitions, understanding cosmic velocities involves energy conservation, orbital dynamics, and the interplay between a planet\u2019s and star\u2019s gravity. In this solution, we define: First Cosmic Velocity : The speed required for a spacecraft to maintain a circular orbit close to a celestial body's surface. Second Cosmic Velocity : The escape speed needed to overcome the gravitational pull of that body. Third Cosmic Velocity : The additional speed required, once free from a planet\u2019s gravity, to escape the gravitational influence of the central star (e.g., the Sun).","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#detailed-physics-and-derivations","text":"","title":"Detailed Physics and Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-v1-orbital-mechanics","text":"For a celestial body with mass \\((M)\\) and radius \\((R)\\) , the first cosmic velocity is derived by equating the gravitational force to the centripetal force required for a circular orbit: \\[ \\frac{GM}{R^2} = \\frac{v_1^2}{R} \\Rightarrow v_1 = \\sqrt{\\frac{GM}{R}} \\] Physics Insight : This velocity decreases with increasing orbital radius as the gravitational pull weakens. For non-circular (elliptical) orbits, the vis-viva equation generalizes the orbital speed: $$ v = \\sqrt{GM\\left(\\frac{2}{r} - \\frac{1}{a}\\right)} $$ where \\(a\\) is the semi-major axis. In a low circular orbit, \\(r \\approx R\\) and \\(a \\approx R\\) , so \\(v \\approx v_1\\) .","title":"1. First Cosmic Velocity (v\u2081) \u2013 Orbital Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-v2-escape-energy","text":"Escape velocity is determined by setting the total mechanical energy (kinetic plus potential) to zero so that the object reaches infinity with no residual speed: \\[ \\frac{1}{2}v_2^2 - \\frac{GM}{R} = 0 \\Rightarrow v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2}\\, v_1 \\] Physics Insight : The factor of \\(\\sqrt{2}\\) signifies the extra kinetic energy required to overcome the gravitational potential well. For \\(v < v_2\\) , the object remains bound (elliptical orbit), while for \\(v \\ge v_2\\) , the trajectory becomes parabolic or hyperbolic.","title":"2. Second Cosmic Velocity (v\u2082) \u2013 Escape Energy"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-v3-stellar-escape","text":"Escaping a star\u2019s gravitational field from a planet involves combining the planet\u2019s escape velocity with the dynamics of the star\u2019s gravity. Consider a planet at orbital radius \\(r\\) from its star: - The orbital speed of the planet is: $$ v_{\\text{orbit}} = \\sqrt{\\frac{GM_\\odot}{r}} $$ - The escape speed from the star at that distance is: $$ v_{\\text{esc,Sun}} = \\sqrt{\\frac{2GM_\\odot}{r}} $$ A spacecraft leaving the planet benefits from the planet\u2019s orbital speed. Hence, the additional speed needed relative to the star is given by: $$ v_3 = v_{\\text{esc,Sun}} - v_{\\text{orbit}} = \\sqrt{\\frac{GM_\\odot}{r}}\\,(\\sqrt{2} - 1) $$ Physics Insight : The subtraction of \\(v_{\\text{orbit}}\\) reflects that the planet\u2019s motion already contributes to the required energy for stellar escape. This makes \\(v_3\\) lower than \\(v_{\\text{esc,Sun}}\\) and highlights why gravitational assists (e.g., flybys of massive planets) can further reduce the propulsion needed.","title":"3. Third Cosmic Velocity (v\u2083) \u2013 Stellar Escape"},{"location":"1%20Physics/2%20Gravity/Problem_2/#additional-effects","text":"Atmospheric Drag : At low altitudes, air resistance reduces the effective velocity. It is modeled by: $$ F_{\\text{drag}} = \\frac{1}{2}\\rho v^2 C_d A$$ where \\((\\rho)\\) is air density, \\((C_d)\\) is the drag coefficient, and \\((A)\\) is the cross-sectional area. Gravitational Assists : Maneuvers near massive bodies (e.g., Jupiter) can boost a spacecraft\u2019s velocity via the Oberth effect, where applying thrust at high speeds in deep gravity wells yields maximum energy gain. Relativistic Corrections : Although typically negligible within the Solar System, at extremely high velocities or near massive bodies, general relativity modifies gravitational potential and orbital dynamics.","title":"Additional Effects"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-for-celestial-bodies","text":"For the simulations, we use the following parameters: Earth: Mass: \\(5.972 \\times 10^{24}\\) \\(kg\\) Radius: \\(6.371 \\times 10^{6}\\) \\(m\\) Orbital radius: \\(1.496 \\times 10^{11}\\) \\(m\\) Mars: Mass: \\(6.4171 \\times 10^{23}\\) \\(kg\\) Radius: \\(3.3895 \\times 10^{6}\\) \\(m\\) Orbital radius: \\(2.279 \\times 10^{11}\\) \\(m\\) Jupiter: Mass: \\(1.898 \\times 10^{27}\\) \\(kg\\) Radius: \\(6.9911 \\times 10^{7}\\) \\(m\\) Orbital radius: \\(7.785 \\times 10^{11}\\) \\(m\\) For the Sun: Mass: \\(1.989 \\times 10^{30}\\) \\(kg\\)","title":"Parameters for Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#computational-simulation-and-visualization","text":"The following Python script computes the three cosmic velocities for Earth, Mars, and Jupiter, and visualizes the results with a bar chart. import math import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Parameters for celestial bodies: mass (kg), radius (m), and orbital radius around the Sun (m) bodies = { 'Earth': { 'mass': 5.972e24, 'radius': 6.371e6, 'orbital_radius': 1.496e11 }, 'Mars': { 'mass': 6.4171e23, 'radius': 3.3895e6, 'orbital_radius': 2.279e11 }, 'Jupiter': { 'mass': 1.898e27, 'radius': 6.9911e7, 'orbital_radius': 7.785e11 } } results = {} for body, params in bodies.items(): mass = params['mass'] radius = params['radius'] orbital_radius = params['orbital_radius'] # First cosmic velocity: circular orbital speed at the surface of the body v1 = math.sqrt(G * mass / radius) # Second cosmic velocity: escape velocity from the body v2 = math.sqrt(2 * G * mass / radius) # Orbital speed of the body around the Sun v_orbit = math.sqrt(G * M_sun / orbital_radius) # Solar escape speed at the body's orbital distance v_esc_sun = math.sqrt(2 * G * M_sun / orbital_radius) # Third cosmic velocity: additional speed required to overcome the Sun's gravity v3 = v_esc_sun - v_orbit results[body] = {'v1': v1, 'v2': v2, 'v3': v3, 'v_orbit': v_orbit, 'v_esc_sun': v_esc_sun} # Display the calculated velocities for each body for body, vals in results.items(): print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {vals['v1']:.2f} m/s ({vals['v1']/1000:.2f} km/s)\") print(f\" Second Cosmic Velocity (v2): {vals['v2']:.2f} m/s ({vals['v2']/1000:.2f} km/s)\") print(f\" Third Cosmic Velocity (v3): {vals['v3']:.2f} m/s ({vals['v3']/1000:.2f} km/s)\") print() # Prepare data for plotting (convert m/s to km/s) labels = list(bodies.keys()) v1_values = [results[body]['v1']/1000 for body in labels] v2_values = [results[body]['v2']/1000 for body in labels] v3_values = [results[body]['v3']/1000 for body in labels] x = range(len(labels)) bar_width = 0.25 fig, ax = plt.subplots(figsize=(10, 6)) ax.bar([p - bar_width for p in x], v1_values, width=bar_width, label='First Cosmic Velocity (km/s)') ax.bar(x, v2_values, width=bar_width, label='Second Cosmic Velocity (km/s)') ax.bar([p + bar_width for p in x], v3_values, width=bar_width, label='Third Cosmic Velocity (km/s)') ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.show()","title":"Computational Simulation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#simulation-output","text":"","title":"Simulation Output"},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation-of-the-output","text":"The simulation output is presented as a bar chart that compares the three key cosmic velocities for Earth, Mars, and Jupiter. Here\u2019s what the chart represents: X-axis : The different celestial bodies (Earth, Mars, Jupiter). Y-axis : The computed velocities in km/s. For each celestial body, three sets of bars are displayed: - First Cosmic Velocity (v\u2081) : Indicates the orbital speed necessary for a stable, circular orbit near the body's surface. - Second Cosmic Velocity (v\u2082) : Represents the escape speed required to overcome the gravitational binding of the body. Note that this value is always \\(\\sqrt{2}\\) times the first cosmic velocity. - Third Cosmic Velocity (v\u2083) : Shows the additional velocity needed (beyond the planet\u2019s orbital speed) to escape the gravitational influence of the Sun. This visualization clearly illustrates the differences between the velocities for various celestial bodies and highlights the impact of their mass, size, and orbital distances on mission planning. The reduced third cosmic velocity (compared to the solar escape speed) underscores the advantage provided by a planet\u2019s orbital motion in reducing the energy requirements for interplanetary travel.","title":"Explanation of the Output"},{"location":"1%20Physics/2%20Gravity/Problem_2/#additional-simulation","text":"","title":"Additional Simulation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-variation-of-cosmic-velocities-with-planet-mass","text":"import math import numpy as np import matplotlib.pyplot as plt \"\"\" This script varies each planet's mass from 80% to 120% of its nominal (real) mass and plots two key velocities: 1) v\u2081 (Orbital) = \u221a(GM/R), the speed for a circular orbit near the surface. 2) v\u2082 (Escape) = \u221a(2GM/R), the speed required to escape the planet's gravity. We highlight the real (nominal) mass point on BOTH v\u2081 and v\u2082 with black 'X' markers, but we do not show any arrow/text annotations. All other points are hypothetical. \"\"\" # Constants G = 6.67430e-11 # Gravitational constant [m^3 kg^-1 s^-2] M_sun = 1.989e30 # Mass of the Sun [kg] - not directly used here # Planetary parameters bodies = { 'Earth': { 'mass': 5.972e24, 'radius': 6.371e6 }, 'Mars': { 'mass': 6.4171e23, 'radius': 3.3895e6 }, 'Jupiter': { 'mass': 1.898e27, 'radius': 6.9911e7 } } # Range of mass factors (80% to 120% of nominal) mass_factors = np.array([0.8, 0.9, 1.0, 1.1, 1.2]) plt.figure(figsize=(12, 7)) # We'll only add the 'Real Mass' label once in the legend real_mass_label_added = False for planet, params in bodies.items(): nominal_mass = params['mass'] radius = params['radius'] # Arrays for v\u2081 and v\u2082 over the specified mass factors v1_values = [] # v\u2081 (Orbital) v2_values = [] # v\u2082 (Escape) for factor in mass_factors: mass = factor * nominal_mass v1 = math.sqrt(G * mass / radius) # m/s v2 = math.sqrt(2 * G * mass / radius) # m/s v1_values.append(v1 / 1000) # Convert to km/s v2_values.append(v2 / 1000) # Convert to km/s # x-axis in units of 10^24 kg x_values = mass_factors * nominal_mass / 1e24 # Plot v\u2081 (Orbital) and v\u2082 (Escape) plt.plot(x_values, v1_values, marker='o', linestyle='-', markersize=8, linewidth=2, label=f'{planet} v\u2081 (Orbital)') plt.plot(x_values, v2_values, marker='s', linestyle='--', markersize=8, linewidth=2, label=f'{planet} v\u2082 (Escape)') # Find the index for the nominal mass (factor=1.0) idx_nom = np.where(mass_factors == 1.0)[0][0] real_mass_x = x_values[idx_nom] # Extract the v\u2081 and v\u2082 values at the nominal mass real_mass_v1 = v1_values[idx_nom] real_mass_v2 = v2_values[idx_nom] # Plot black X marker on v\u2081 at nominal mass if not real_mass_label_added: # Add the label for the FIRST black X only plt.scatter(real_mass_x, real_mass_v1, color='black', marker='X', s=100, zorder=5, label='Real Mass (Nominal)') real_mass_label_added = True else: plt.scatter(real_mass_x, real_mass_v1, color='black', marker='X', s=100, zorder=5) # Plot black X marker on v\u2082 at nominal mass (no legend label) plt.scatter(real_mass_x, real_mass_v2, color='black', marker='X', s=100, zorder=5) # Optional: use a log scale if masses differ by orders of magnitude plt.xscale('log') plt.xlabel('Planet Mass (10^24 kg) [log scale]') plt.ylabel('Velocity (km/s)') plt.title('Variation of Cosmic Velocities with Planet Mass (v\u2081 and v\u2082)') plt.grid(True) # Initial legend call plt.legend() # Reorder legend so 'Real Mass (Nominal)' is first handles, labels = plt.gca().get_legend_handles_labels() rm_index = labels.index('Real Mass (Nominal)') new_handles = [handles[rm_index]] + handles[:rm_index] + handles[rm_index+1:] new_labels = [labels[rm_index]] + labels[:rm_index] + labels[rm_index+1:] plt.legend(new_handles, new_labels) plt.show()","title":"1. Variation of Cosmic Velocities with Planet Mass"},{"location":"1%20Physics/2%20Gravity/Problem_2/#simulation-output_1","text":"","title":"Simulation Output"},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation-of-the-mass-variation-simulation","text":"This is purely a theoretical exercise \u2014planets don\u2019t spontaneously gain or lose 20% of their mass in reality. Varying the mass helps us understand how strongly these orbital and escape velocities depend on a planet\u2019s gravitational parameter \\(GM\\) . In this simulation we explore how two key velocities\u2014 \\(v\u2081\\) (Orbital Velocity) and \\(v\u2082\\) (Escape Velocity) \u2014depend on a planet\u2019s mass, using hypothetical variations of 80% to 120% of its nominal (actual) mass. Here\u2019s what each part means: Varying the Mass: We multiply the nominal mass of each planet by factors of 0.8, 0.9, 1.0, 1.1, and 1.2. This produces a set of hypothetical masses. Only the factor 1.0 corresponds to the real, physically measured mass. Changing the mass in the equations allows us to see how the gravitational parameter \\(GM\\) influences the speeds, even though in reality a planet\u2019s mass remains fixed. Calculating the Velocities: v\u2081 (Orbital Velocity): $$ v\u2081 = \\sqrt{\\frac{GM}{R}} $$ This is the speed required to maintain a circular orbit right at the planet\u2019s surface. It depends on both the planet\u2019s mass and its radius (which remains constant in our simulation). v\u2082 (Escape Velocity): $$ v\u2082 = \\sqrt{\\frac{2GM}{R}} $$ This is the speed required for a spacecraft to escape the planet\u2019s gravitational pull. It is always \\(\\sqrt{2}\\) times \\(v\u2081\\) . Real Mass Markers: For each planet, the data point computed at the mass factor of 1.0 is the only physically real value because it uses the planet\u2019s actual mass. We mark this real (nominal) mass point on both the \\(v\u2081\\) and \\(v\u2082\\) curves with a black \u201cX.\u201d Although the two markers appear at the same mass value on the x-axis, they represent two different speeds: one for orbital motion \\((v\u2081)\\) and one for escape \\((v\u2082)\\) . These markers help you distinguish between the real (nominal) scenario and the other hypothetical cases (0.8, 0.9, 1.1, and 1.2 factors). Logarithmic X-axis: The x-axis is set to a log scale because Jupiter\u2019s mass is many orders of magnitude larger than Earth\u2019s or Mars\u2019. This scaling prevents the smaller masses from being squashed near zero and makes all data points easier to compare visually.","title":"Explanation of the Mass-Variation Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#interpretation","text":"Scaling with Mass: As the mass increases, both v\u2081 and v\u2082 increase in accordance with \\(\\sqrt{M}\\) . This explains why Jupiter\u2019s velocities are significantly higher than Earth\u2019s or Mars\u2019. Sensitivity Analysis: Although the mass variations are purely hypothetical, they illustrate how changes in the gravitational parameter \\(GM\\) affect the orbital and escape speeds. Practical Distinction: The two velocities represent different physical requirements: v\u2081 (Orbital Velocity) is the speed needed for a stable orbit near the planet\u2019s surface. v\u2082 (Escape Velocity) is the higher speed required to overcome the planet\u2019s gravitational pull. The black \\(\u201cX\u201d\\) markers at the nominal mass (mass factor = 1.0) indicate the actual speeds computed using the planet\u2019s true mass, while the other points show \u201cwhat-if\u201d scenarios. Overall, this exercise reveals the direct relationship between planetary mass and the speeds needed for orbiting and escaping. It provides insight into how sensitive these speeds are to changes in \\(GM\\) , even though in practice a planet\u2019s mass does not change.","title":"Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-additional-simulation-nominal-cosmic-velocities-for-earth-mars-and-jupiter","text":"Purpose: Each velocity is represented as a uniquely colored arrow with a label placed near its tip. This approach not only shows the individual values but also allows direct visual comparison of how these velocities differ among Earth, Mars, and Jupiter.","title":"2. Additional Simulation: Nominal Cosmic Velocities for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#code-for-earth","text":"import math import numpy as np import matplotlib.pyplot as plt # -------------------------- Nominal Cosmic Velocities for Earth -------------------------- # Earth nominal parameters mass_earth = 5.972e24 # kg radius_earth = 6.371e6 # m orbital_radius_earth = 1.496e11 # m # Compute Earth's nominal velocities v1_earth = math.sqrt(6.67430e-11 * mass_earth / radius_earth) # Orbital velocity [m/s] v2_earth = math.sqrt(2 * 6.67430e-11 * mass_earth / radius_earth) # Escape velocity [m/s] v_orbit_earth = math.sqrt(6.67430e-11 * 1.989e30 / orbital_radius_earth) # Earth's orbital speed around the Sun [m/s] v_esc_sun_earth = math.sqrt(2 * 6.67430e-11 * 1.989e30 / orbital_radius_earth) # Solar escape speed [m/s] v3_earth = v_esc_sun_earth - v_orbit_earth # Additional speed for solar escape [m/s] # Convert to km/s v1_earth_km = v1_earth / 1000 v2_earth_km = v2_earth / 1000 v_orbit_earth_km = v_orbit_earth / 1000 v_esc_sun_earth_km = v_esc_sun_earth / 1000 v3_earth_km = v3_earth / 1000 # Define velocities for Earth with unique angles and colors velocities_earth = [ {'label': 'v\u2081 (Orbital)', 'speed': v1_earth_km, 'angle': 0, 'color': 'C0'}, {'label': 'v\u2082 (Escape)', 'speed': v2_earth_km, 'angle': 45, 'color': 'C1'}, {'label': 'v_orbit', 'speed': v_orbit_earth_km, 'angle': 90, 'color': 'C2'}, {'label': 'v_esc,Sun', 'speed': v_esc_sun_earth_km, 'angle': 135, 'color': 'C3'}, {'label': 'v\u2083', 'speed': v3_earth_km, 'angle': 180, 'color': 'C4'} ] plt.figure(figsize=(8,8)) origin = (0,0) for vel in velocities_earth: label = vel['label'] speed = vel['speed'] angle = np.deg2rad(vel['angle']) dx = speed * np.cos(angle) dy = speed * np.sin(angle) plt.arrow(origin[0], origin[1], dx, dy, head_width=0.5, head_length=1, length_includes_head=True, color=vel['color'], alpha=0.8, label=label) plt.text(dx * 1.05, dy * 1.05, label, fontsize=10, color=vel['color'], ha='center', va='center') handles, labels = plt.gca().get_legend_handles_labels() by_label = dict(zip(labels, handles)) plt.legend(by_label.values(), by_label.keys()) max_speed = max(vel['speed'] for vel in velocities_earth) plt.xlim(-max_speed - 5, max_speed + 5) plt.ylim(-max_speed - 5, max_speed + 5) plt.xlabel('Velocity component (km/s)') plt.ylabel('Velocity component (km/s)') plt.title('Nominal Cosmic Velocities for Earth') plt.grid(True) plt.show()","title":"Code for Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#code-for-mars","text":"import math import numpy as np import matplotlib.pyplot as plt # -------------------------- Nominal Cosmic Velocities for Mars -------------------------- # Mars nominal parameters mass_mars = 6.4171e23 # kg radius_mars = 3.3895e6 # m orbital_radius_mars = 2.279e11 # m # Compute Mars' nominal velocities v1_mars = math.sqrt(6.67430e-11 * mass_mars / radius_mars) # Orbital velocity [m/s] v2_mars = math.sqrt(2 * 6.67430e-11 * mass_mars / radius_mars) # Escape velocity [m/s] v_orbit_mars = math.sqrt(6.67430e-11 * 1.989e30 / orbital_radius_mars) # Mars' orbital speed around the Sun [m/s] v_esc_sun_mars = math.sqrt(2 * 6.67430e-11 * 1.989e30 / orbital_radius_mars) # Solar escape speed [m/s] v3_mars = v_esc_sun_mars - v_orbit_mars # Additional speed for solar escape [m/s] # Convert to km/s v1_mars_km = v1_mars / 1000 v2_mars_km = v2_mars / 1000 v_orbit_mars_km = v_orbit_mars / 1000 v_esc_sun_mars_km = v_esc_sun_mars / 1000 v3_mars_km = v3_mars / 1000 # Define velocities for Mars with unique angles and colors velocities_mars = [ {'label': 'v\u2081 (Orbital)', 'speed': v1_mars_km, 'angle': 0, 'color': 'C0'}, {'label': 'v\u2082 (Escape)', 'speed': v2_mars_km, 'angle': 45, 'color': 'C1'}, {'label': 'v_orbit', 'speed': v_orbit_mars_km, 'angle': 90, 'color': 'C2'}, {'label': 'v_esc,Sun', 'speed': v_esc_sun_mars_km, 'angle': 135, 'color': 'C3'}, {'label': 'v\u2083', 'speed': v3_mars_km, 'angle': 180, 'color': 'C4'} ] plt.figure(figsize=(8,8)) origin = (0,0) for vel in velocities_mars: label = vel['label'] speed = vel['speed'] angle = np.deg2rad(vel['angle']) dx = speed * np.cos(angle) dy = speed * np.sin(angle) plt.arrow(origin[0], origin[1], dx, dy, head_width=0.5, head_length=1, length_includes_head=True, color=vel['color'], alpha=0.8, label=label) plt.text(dx * 1.05, dy * 1.05, label, fontsize=10, color=vel['color'], ha='center', va='center') handles, labels = plt.gca().get_legend_handles_labels() by_label = dict(zip(labels, handles)) plt.legend(by_label.values(), by_label.keys()) max_speed = max(vel['speed'] for vel in velocities_mars) plt.xlim(-max_speed - 5, max_speed + 5) plt.ylim(-max_speed - 5, max_speed + 5) plt.xlabel('Velocity component (km/s)') plt.ylabel('Velocity component (km/s)') plt.title('Nominal Cosmic Velocities for Mars') plt.grid(True) plt.show()","title":"Code for Mars"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#code-for-jupiter","text":"import math import numpy as np import matplotlib.pyplot as plt # -------------------------- Nominal Cosmic Velocities for Jupiter -------------------------- # Jupiter nominal parameters mass_jupiter = 1.898e27 # kg radius_jupiter = 6.9911e7 # m orbital_radius_jupiter = 7.785e11 # m # Compute Jupiter's nominal velocities v1_jupiter = math.sqrt(6.67430e-11 * mass_jupiter / radius_jupiter) # Orbital velocity [m/s] v2_jupiter = math.sqrt(2 * 6.67430e-11 * mass_jupiter / radius_jupiter) # Escape velocity [m/s] v_orbit_jupiter = math.sqrt(6.67430e-11 * 1.989e30 / orbital_radius_jupiter) # Jupiter's orbital speed around the Sun [m/s] v_esc_sun_jupiter = math.sqrt(2 * 6.67430e-11 * 1.989e30 / orbital_radius_jupiter) # Solar escape speed [m/s] v3_jupiter = v_esc_sun_jupiter - v_orbit_jupiter # Additional speed for solar escape [m/s] # Convert to km/s v1_jupiter_km = v1_jupiter / 1000 v2_jupiter_km = v2_jupiter / 1000 v_orbit_jupiter_km = v_orbit_jupiter / 1000 v_esc_sun_jupiter_km = v_esc_sun_jupiter / 1000 v3_jupiter_km = v3_jupiter / 1000 # Define velocities for Jupiter with unique angles and colors velocities_jupiter = [ {'label': 'v\u2081 (Orbital)', 'speed': v1_jupiter_km, 'angle': 0, 'color': 'C0'}, {'label': 'v\u2082 (Escape)', 'speed': v2_jupiter_km, 'angle': 45, 'color': 'C1'}, {'label': 'v_orbit', 'speed': v_orbit_jupiter_km, 'angle': 90, 'color': 'C2'}, {'label': 'v_esc,Sun', 'speed': v_esc_sun_jupiter_km, 'angle': 135, 'color': 'C3'}, {'label': 'v\u2083', 'speed': v3_jupiter_km, 'angle': 180, 'color': 'C4'} ] plt.figure(figsize=(8,8)) origin = (0,0) for vel in velocities_jupiter: label = vel['label'] speed = vel['speed'] angle = np.deg2rad(vel['angle']) dx = speed * np.cos(angle) dy = speed * np.sin(angle) plt.arrow(origin[0], origin[1], dx, dy, head_width=0.5, head_length=1, length_includes_head=True, color=vel['color'], alpha=0.8, label=label) plt.text(dx * 1.05, dy * 1.05, label, fontsize=10, color=vel['color'], ha='center', va='center') handles, labels = plt.gca().get_legend_handles_labels() by_label = dict(zip(labels, handles)) plt.legend(by_label.values(), by_label.keys()) max_speed = max(vel['speed'] for vel in velocities_jupiter) plt.xlim(-max_speed - 5, max_speed + 5) plt.ylim(-max_speed - 5, max_speed + 5) plt.xlabel('Velocity component (km/s)') plt.ylabel('Velocity component (km/s)') plt.title('Nominal Cosmic Velocities for Jupiter') plt.grid(True) plt.show()","title":"Code for Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation","text":"This set of simulations displays the nominal cosmic velocities for Earth, Mars, and Jupiter as vector arrows. Each simulation computes five key velocities for the given planet: \\(v\u2081\\) (Orbital Velocity): The speed needed for a circular orbit at the planet\u2019s surface. \\(v\u2082\\) (Escape Velocity): The speed required to escape the planet\u2019s gravitational pull \\((\\sqrt{2} times(v\u2081))\\) . \\(v_orbit\\) : The orbital speed of the planet around the Sun. \\(v_esc,Sun\\) : The escape speed from the Sun at the planet\u2019s orbital distance. \\(v\\) \u2083: The extra speed needed to overcome the Sun\u2019s gravitational pull (i.e. \\(v_{\\text{esc,Sun}} - v_{\\text{orbit}})\\) . Each arrow is plotted with a unique angle and color and labeled near its tip for clarity. By comparing these vector diagrams: Earth\u2019s arrows provide a baseline of speeds for a planet with moderate mass and size. Mars\u2019 arrows are noticeably shorter, reflecting its lower mass and weaker gravity. Jupiter\u2019s arrows are much longer, indicating significantly higher speeds due to its massive gravitational pull. This comprehensive simulation and the side-by-side image display help illustrate how planetary properties influence key cosmic speeds, which is vital for space mission planning.","title":"Explanation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-hohmann-transfer-simulation","text":"Purpose : Demonstrate how cosmic velocities are applied in interplanetary travel by simulating the most fuel-efficient path between Earth and Mars. Physics Link : - Uses the vis-viva equation (from the derivations) to calculate transfer orbit velocities. - Shows how a partial escape velocity (not full \\(v_2\\) ) is sufficient when leveraging the Sun\u2019s gravity. How It Differs from the Previous Simulation : - The bar chart compares theoretical thresholds ( \\(v_1\\) , \\(v_2\\) , \\(v_3\\) ). - This simulation models a practical application : computing the delta\u2011v needed for a Hohmann transfer between Earth and Mars, and visualizing the transfer trajectory. import numpy as np def hohmann_transfer(r1, r2, M_central): \"\"\" Compute velocities and delta-v for a Hohmann transfer between two circular orbits. Args: r1 (float): Initial orbital radius (m). r2 (float): Target orbital radius (m). M_central (float): Mass of the central body (kg). Returns: dict: Delta-v values and transfer parameters. \"\"\" # Circular orbit velocities v1 = np.sqrt(G * M_central / r1) # Initial orbit (Earth) v2 = np.sqrt(G * M_central / r2) # Target orbit (Mars) # Transfer ellipse velocities (at perihelion and aphelion) a_transfer = (r1 + r2) / 2 # Semi-major axis of the transfer ellipse v_peri = np.sqrt(2 * G * M_central * (1/r1 - 1/(2*a_transfer))) # Velocity at departure burn v_aphel = np.sqrt(2 * G * M_central * (1/r2 - 1/(2*a_transfer))) # Velocity at arrival burn # Delta-v maneuvers delta_v1 = v_peri - v1 # Burn to leave Earth orbit delta_v2 = v2 - v_aphel # Burn to match Mars orbit return { 'delta_v1': delta_v1, 'delta_v2': delta_v2, 'total_delta_v': delta_v1 + delta_v2, 'transfer_time': np.pi * np.sqrt(a_transfer**3 / (G * M_central)) # Using Kepler's third law } # Earth to Mars transfer parameters r_earth = 1.496e11 # Earth's orbital radius (m) r_mars = 2.279e11 # Mars' orbital radius (m) transfer = hohmann_transfer(r_earth, r_mars, M_sun) print(\"Hohmann Transfer Earth \u2192 Mars:\") print(f\"Delta-v1: {transfer['delta_v1']/1000:.2f} km/s (Departure burn)\") print(f\"Delta-v2: {transfer['delta_v2']/1000:.2f} km/s (Arrival burn)\") print(f\"Total \u0394v: {transfer['total_delta_v']/1000:.2f} km/s\") print(f\"Transfer Time: {transfer['transfer_time'] / (60*60*24):.0f} days\") # Plot the transfer trajectory theta = np.linspace(0, 2*np.pi, 100) fig, ax = plt.subplots(figsize=(8, 8)) ax.plot(r_earth * np.cos(theta), r_earth * np.sin(theta), label=\"Earth Orbit\") ax.plot(r_mars * np.cos(theta), r_mars * np.sin(theta), label=\"Mars Orbit\") # Calculate Hohmann transfer ellipse eccentricity = (r_mars - r_earth) / (r_mars + r_earth) theta_transfer = np.linspace(0, np.pi, 100) r_transfer = (r_earth + r_mars) / 2 * (1 - eccentricity**2) / (1 + eccentricity * np.cos(theta_transfer)) x_transfer = r_transfer * np.cos(theta_transfer) y_transfer = r_transfer * np.sin(theta_transfer) ax.plot(x_transfer, y_transfer, 'r--', label=\"Hohmann Transfer\") ax.set_title(\"Hohmann Transfer: Earth to Mars\") ax.set_xlabel(\"Distance (m)\") ax.set_ylabel(\"Distance (m)\") ax.legend() ax.grid() plt.axis('equal') plt.show() Output : Hohmann Transfer Earth \u2192 Mars: Delta-v1: 2.94 km/s (Departure burn) Delta-v2: 2.65 km/s (Arrival burn) Total \u0394v: 5.59 km/s Transfer Time: 259 days","title":"3. Hohmann Transfer Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation-of-the-hohmann-transfer-simulation","text":"Relationship to Cosmic Velocities: First Cosmic Velocity ( \\(v_1\\) ) : The spacecraft starts in Earth\u2019s orbit, moving at its heliocentric speed. Second Cosmic Velocity ( \\(v_2\\) ) : The departure burn \\((\\Delta v_1)\\) is less than Earth's full escape speed because the transfer only requires leaving Earth's sphere of influence. Third Cosmic Velocity ( \\(v_3\\) ) : Instead of achieving full solar escape speed, the spacecraft performs an arrival burn \\((\\Delta v_2)\\) to match Mars' orbital speed. Why This Matters : Demonstrates that only a partial delta\u2011v (compared to full escape velocities) is necessary for interplanetary transfers. Connects the theoretical cosmic velocity concepts with practical mission design, illustrating how energy-efficient transfers are achieved in space exploration. This section integrates a practical Hohmann transfer simulation with the cosmic velocities analysis, providing clear insight into how these theoretical concepts are applied to real-world space mission planning.","title":"Explanation of the Hohmann Transfer Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#discussion-and-relevance","text":"First Cosmic Velocity: Achieving this velocity is essential for inserting satellites into stable orbits. It reflects the balance between gravitational pull and centripetal force, ensuring that a spacecraft remains in continuous free-fall. Second Cosmic Velocity: This is the minimum speed required to overcome a celestial body's gravitational binding. Its derivation from energy conservation underlines the kinetic energy needed to reach infinity with zero residual speed. Third Cosmic Velocity: Beyond escaping a planet\u2019s gravity, a spacecraft must also overcome the star's gravitational pull. The combined effect of the planet\u2019s orbital velocity and the star\u2019s escape speed determines \\(v_3\\) . This velocity is key for interplanetary and, eventually, interstellar missions\u2014especially when augmented by gravitational assists.","title":"Discussion and Relevance"},{"location":"1%20Physics/2%20Gravity/Problem_2/#applications-in-space-exploration","text":"Satellite Deployment: The first and second cosmic velocities are critical for designing launch vehicles that can insert satellites into stable orbits or set them on escape trajectories. Interplanetary Transfers: Detailed calculations of these velocities enable the design of energy-efficient trajectories. Advanced techniques like Hohmann transfers and gravitational assists further optimize the delta\u2011v requirements. Advanced Mission Planning: Understanding these velocity thresholds is fundamental for conceptualizing future missions, whether for planetary exploration or interstellar travel, where optimizing fuel usage and trajectory design is paramount. This final solution combines rigorous theoretical derivations with practical simulations to offer a robust framework for understanding cosmic velocities. It provides both the mathematical foundation and computational tools needed for modern space mission planning.","title":"Applications in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Introduction When a payload is released from a moving rocket near Earth, its subsequent trajectory is determined by its initial position, velocity, and the gravitational pull of the Earth. Depending on the initial conditions, the payload can follow: Elliptical (or circular) orbits: if its kinetic energy is such that the total energy is negative. Parabolic trajectories: the borderline case between bound and unbound orbits (zero total energy). Hyperbolic trajectories: if the payload has more than enough kinetic energy to escape Earth's gravitational field (positive total energy). This document explains the underlying physics, describes a numerical method to simulate the payload motion, and shows how to visualize the different trajectories. Extended Theoretical Background Understanding the trajectories of a freely released payload near Earth begins with Newton's Law of Gravitation and the conservation laws of energy and angular momentum. Here, we expand on these principles, derive key equations, and explain how they govern orbital motion. Newton\u2019s Law of Gravitation and Equations of Motion The gravitational force acting on a payload at a distance \\(r\\) from Earth's center is given by \\[ \\vec{F} = -\\frac{\\mu}{r^3}\\vec{r}, \\] where \\(\\mu = GM\\) is Earth\u2019s gravitational parameter ( \\(G\\) is the gravitational constant and \\(M\\) is the mass of Earth). Using Newton's second law, the acceleration of the payload is: \\[ \\ddot{\\vec{r}} = -\\frac{\\mu}{r^3}\\vec{r}. \\] While these equations can be expressed in Cartesian coordinates, gravity as a central force (always pointing toward the center) is more insightfully described in polar coordinates \\((r, \\theta)\\) . Polar Coordinates and Conservation Laws In polar coordinates, the position vector is represented as: \\[ \\vec{r} = r \\hat{r}. \\] The acceleration in polar coordinates has two components: Radial acceleration: $$ \\ddot{r} - r\\dot{\\theta}^2 = -\\frac{\\mu}{r^2}, $$ Transverse (angular) acceleration: $$ r\\ddot{\\theta} + 2\\dot{r}\\dot{\\theta} = 0. $$ The second equation implies the conservation of angular momentum \\(L\\) : \\[ L = r^2 \\dot{\\theta} = \\text{constant}. \\] Deriving the Orbit Equation Using the conservation of angular momentum, we derive an equation for the shape of the orbit. Introducing the substitution: \\[ u = \\frac{1}{r}, \\] and differentiating with respect to \\(\\theta\\) : \\[ \\frac{dr}{d\\theta} = -\\frac{1}{u^2} \\frac{du}{d\\theta}, \\] the radial acceleration term can be expressed in terms of \\(u\\) and \\(\\theta\\) . After some manipulation, the radial equation transforms into the differential equation: \\[ \\frac{d^2 u}{d\\theta^2} + u = \\frac{\\mu}{L^2}. \\] This linear differential equation has the general solution: \\[ u(\\theta) = \\frac{\\mu}{L^2}\\left(1 + e\\cos(\\theta)\\right), \\] or equivalently, the orbital equation in polar form: \\[ r(\\theta) = \\frac{L^2/\\mu}{1 + e\\cos(\\theta)}. \\] Here, \\(e\\) is the eccentricity of the orbit: - \\(0 \\leq e < 1\\) : Elliptical (or circular if \\(e=0\\) ) - \\(e = 1\\) : Parabolic (the threshold between bound and unbound) - \\(e > 1\\) : Hyperbolic (unbound) Energy Considerations: The Vis-Viva Equation The specific orbital energy (energy per unit mass) is given by \\[ \\epsilon = \\frac{v^2}{2} - \\frac{\\mu}{r}, \\] where \\(v\\) is the speed of the payload. The sign of \\(\\epsilon\\) determines the type of orbit: Elliptical orbits: \\(\\epsilon < 0\\) Parabolic trajectory: \\(\\epsilon = 0\\) Hyperbolic trajectory: \\(\\epsilon > 0\\) For a given orbit, the vis-viva equation relates the velocity \\(v\\) at any distance \\(r\\) to the semi-major axis \\(a\\) : \\[ v^2 = \\mu\\left(\\frac{2}{r} - \\frac{1}{a}\\right). \\] For a circular orbit ( \\(r = a\\) ), this simplifies to: \\[ v_{\\text{circ}} = \\sqrt{\\frac{\\mu}{r}}, \\] and the escape velocity (the speed needed for a parabolic trajectory) is: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2\\mu}{r}}. \\] Effective Potential and Radial Motion Another way to analyze orbital motion is through the effective potential. The total energy in the radial direction, considering the conservation of angular momentum, can be expressed as: \\[ \\epsilon = \\frac{1}{2}\\dot{r}^2 + V_{\\text{eff}}(r), \\] where the effective potential \\(V_{\\text{eff}}(r)\\) is defined as: \\[ V_{\\text{eff}}(r) = -\\frac{\\mu}{r} + \\frac{L^2}{2r^2}. \\] The first term represents gravitational potential energy. The second term represents the \"centrifugal\" potential energy due to the payload's angular momentum. The effective potential provides insight into radial stability. The minimum of \\(V_{\\text{eff}}(r)\\) corresponds to a stable circular orbit, while deviations lead to oscillatory changes in \\(r\\) , characteristic of elliptical orbits. Connecting Initial Conditions to Orbit Types The initial position and velocity determine both the specific energy \\(\\epsilon\\) and the angular momentum \\(L\\) : Circular Orbit: The velocity is exactly \\(v_{\\text{circ}}\\) , balancing gravitational pull and centripetal force for a constant \\(r\\) . Elliptical Orbit: A velocity lower than \\(v_{\\text{circ}}\\) results in an elliptical path with varying \\(r\\) . Hyperbolic Trajectory: A velocity exceeding \\(v_{\\text{esc}}\\) results in a positive energy orbit, allowing the payload to escape Earth\u2019s gravitational influence. Summary The trajectory of a payload released near Earth is governed by: - Gravitational forces: As described by Newton\u2019s law. - Conservation of angular momentum: Leading to the derivation of the orbit equation. - Energy considerations: Classifying orbits as elliptical, parabolic, or hyperbolic based on the specific orbital energy. - Effective potential: Providing insight into the stability of orbits. This theoretical framework forms the basis for designing simulations and computational tools to predict payload trajectories for space missions. Below is the updated Markdown document that includes the code, the image of the output , and a detailed explanation of that output. Note that we\u2019ve replaced references to \"simulation\" with \"output,\" as requested. Numerical Simulation Below are two separate simulation scenarios for comparison. The left side shows Scenario 1 (200 km Altitude) and the right side shows Scenario 2 (400 km Altitude) . In Scenario 1, the payload is released from 200\u202fkm altitude with: Circular Orbit: \\( v = \\sqrt{\\mu/(R_{\\text{earth}}+200\\,\\text{km})} \\) Elliptical / Reentry: \\( v = 0.8 \\times v_{\\text{circ}} \\) (which leads to reentry) Hyperbolic Trajectory: \\( v = 1.1 \\times v_{\\text{esc}} \\) In Scenario 2, the payload is released from 400\u202fkm altitude with: Circular Orbit: \\( v = \\sqrt{\\mu/(R_{\\text{earth}}+400\\,\\text{km})} \\) Elliptical Orbit: \\( v = 0.9 \\times v_{\\text{circ}} \\) (producing a stable, bound elliptical orbit) Hyperbolic Trajectory: \\( v = 1.1 \\times v_{\\text{esc}} \\) Scenario 1 (200 km Altitude) Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants mu = 3.986004418e14 # Earth's gravitational parameter (m^3/s^2) R_earth = 6.371e6 # Earth's radius (m) def dynamics(t, state): \"\"\" Computes the derivatives for the state vector. state = [x, y, vx, vy] \"\"\" x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] def collision_event(t, state): \"\"\" Event function to detect collision with Earth. Integration stops when r - R_earth = 0. \"\"\" x, y, _, _ = state r = np.sqrt(x**2 + y**2) return r - R_earth collision_event.terminal = True collision_event.direction = -1 def simulate_trajectory(r0, v0, t_span, t_eval): \"\"\" Simulates the payload trajectory given initial conditions. \"\"\" state0 = [r0[0], r0[1], v0[0], v0[1]] return solve_ivp(dynamics, t_span, state0, t_eval=t_eval, events=collision_event, rtol=1e-8) # Initial Conditions for 200 km altitude altitude = 200e3 # 200 km altitude r_mag = R_earth + altitude # Distance from Earth's center r0 = [r_mag, 0] # Starting along the x-axis # Trajectory Cases v_circ = np.sqrt(mu / r_mag) # Circular Orbit speed v0_circ = [0, v_circ] v0_ellipse = [0, 0.8 * v_circ] # Elliptical / Reentry (0.8\u00d7v_circ) v_esc = np.sqrt(2 * mu / r_mag) # Escape Velocity v0_hyper = [0, 1.1 * v_esc] # Hyperbolic Trajectory (1.1\u00d7v_esc) # Time parameters t_span = (0, 6000) # seconds t_eval = np.linspace(t_span[0], t_span[1], 10000) # Simulate trajectories for 200 km altitude sol_circ = simulate_trajectory(r0, v0_circ, t_span, t_eval) sol_ellipse = simulate_trajectory(r0, v0_ellipse, t_span, t_eval) sol_hyper = simulate_trajectory(r0, v0_hyper, t_span, t_eval) # Plot the trajectories (normalized by Earth's radius) plt.figure(figsize=(8, 8)) theta = np.linspace(0, 2*np.pi, 500) earth_x = np.cos(theta) earth_y = np.sin(theta) plt.fill(earth_x, earth_y, 'b', alpha=0.3, label=\"Earth\") plt.plot(sol_circ.y[0] / R_earth, sol_circ.y[1] / R_earth, 'r', label=\"Circular Orbit\") plt.plot(sol_ellipse.y[0] / R_earth, sol_ellipse.y[1] / R_earth, 'g', label=\"Elliptical / Reentry\") plt.plot(sol_hyper.y[0] / R_earth, sol_hyper.y[1] / R_earth, 'm', label=\"Hyperbolic Trajectory\") plt.xlabel(\"x (in Earth radii)\") plt.ylabel(\"y (in Earth radii)\") plt.title(\"Payload Trajectories Near Earth (200 km Altitude)\") plt.legend() plt.axis('equal') plt.grid() plt.show() Explanation of the Code (Scenario 1) Dynamics Function: The dynamics function computes the derivatives of the state vector \\([x, y, vx, vy]\\) using Newton\u2019s law of gravitation, \\(\\ddot{\\vec{r}} = -\\mu \\vec{r}/r^3\\) . Simulation Function: The simulate_trajectory function sets up the initial state and integrates the equations over the defined time span using the solve_ivp solver. The collision event stops the integration when the payload intersects Earth\u2019s surface. Initial Conditions: The payload is assumed to be released from a position 200 km above Earth's surface. Three initial velocity cases are defined: Circular orbit: using the circular velocity \\(v_{\\text{circ}} = \\sqrt{\\mu / r}\\) . Elliptical trajectory: using 80% of the circular velocity. Hyperbolic trajectory: using 110% of the escape velocity \\(v_{\\text{esc}} = \\sqrt{2\\mu / r}\\) . Plotting: The code normalizes positions by Earth's radius to display Earth as a unit circle. Each trajectory is plotted in the \\(xy\\) -plane. Graphical Representations (Output) Output Explanation (Scenario 1) Blue Circle (Earth): Represents Earth as a unit circle. The payload is released at approximately 1.03 Earth radii. Red Curve (Circular Orbit): The payload maintains a tight circular orbit at 200 km altitude. Green Curve (Elliptical / Reentry): With \\(0.8 \\times v_{\\text{circ}}\\) , the payload\u2019s trajectory intersects Earth (reentry). Magenta Curve (Hyperbolic Trajectory): The payload follows an escape trajectory. Key Takeaways (Scenario 1) Altering the initial velocity significantly changes the orbital path. At 200 km, using \\(0.8 \\times v_{\\text{circ}}\\) leads to reentry. The hyperbolic trajectory clearly demonstrates escape conditions. Scenario 2 (400 km Altitude) Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants mu = 3.986004418e14 # Earth's gravitational parameter (m^3/s^2) R_earth = 6.371e6 # Earth's radius (m) def dynamics(t, state): \"\"\"Computes the derivatives for the state vector [x, y, vx, vy] using Newton's law.\"\"\" x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] def collision_event(t, state): \"\"\"Stops integration when the payload reaches Earth's surface.\"\"\" x, y, _, _ = state return np.sqrt(x**2 + y**2) - R_earth collision_event.terminal = True collision_event.direction = -1 def simulate_trajectory(r0, v0, t_span, t_eval): \"\"\"Simulates the payload trajectory given initial conditions.\"\"\" state0 = [r0[0], r0[1], v0[0], v0[1]] return solve_ivp(dynamics, t_span, state0, t_eval=t_eval, events=collision_event, rtol=1e-8) # Initial Conditions for 400 km altitude altitude = 400e3 # 400 km altitude r_mag = R_earth + altitude # Distance from Earth's center r0 = [r_mag, 0] # Starting along the x-axis # Trajectory Cases v_circ = np.sqrt(mu / r_mag) # Circular Orbit speed v0_circ = [0, v_circ] v0_ellipse = [0, 0.9 * v_circ] # Elliptical Orbit (bound) using 0.9\u00d7v_circ v_esc = np.sqrt(2 * mu / r_mag) # Escape Velocity v0_hyper = [0, 1.1 * v_esc] # Hyperbolic Trajectory (1.1\u00d7v_esc) # Time parameters t_span = (0, 6000) # seconds t_eval = np.linspace(t_span[0], t_span[1], 10000) # Simulate trajectories for 400 km altitude sol_circ_new = simulate_trajectory(r0, v0_circ, t_span, t_eval) sol_ellipse_new = simulate_trajectory(r0, v0_ellipse, t_span, t_eval) sol_hyper_new = simulate_trajectory(r0, v0_hyper, t_span, t_eval) # Plot the trajectories (normalized by Earth's radius) plt.figure(figsize=(8, 8)) theta = np.linspace(0, 2*np.pi, 500) earth_x = np.cos(theta) earth_y = np.sin(theta) plt.fill(earth_x, earth_y, 'b', alpha=0.3, label=\"Earth\") plt.plot(sol_circ_new.y[0] / R_earth, sol_circ_new.y[1] / R_earth, 'r', label=\"Circular Orbit (400 km)\") plt.plot(sol_ellipse_new.y[0] / R_earth, sol_ellipse_new.y[1] / R_earth, 'g', label=\"Elliptical Orbit (400 km)\") plt.plot(sol_hyper_new.y[0] / R_earth, sol_hyper_new.y[1] / R_earth, 'm', label=\"Hyperbolic Trajectory (400 km)\") plt.xlabel(\"x (in Earth radii)\") plt.ylabel(\"y (in Earth radii)\") plt.title(\"Payload Trajectories at 400 km Altitude\") plt.legend() plt.axis('equal') plt.grid() plt.show() Explanation of the Code (Scenario 2) Dynamics Function: Computes the derivatives of the state vector \\([x, y, vx, vy]\\) using Newton\u2019s law. Simulation Function: Sets up the initial state and integrates the equations over time using solve_ivp, with a collision event stopping the integration when the payload hits Earth. Initial Conditions (400 km): The payload is released from 400 km altitude (approximately 1.06 Earth radii). Circular Orbit: \\(v = \\sqrt{\\mu/(R_{\\text{earth}}+400\\,\\text{km})}\\) Elliptical Orbit: \\(v = 0.9 \\times v_{\\text{circ}}\\) (producing a bound elliptical orbit) Hyperbolic Trajectory: \\(v = 1.1 \\times v_{\\text{esc}}\\) Plotting: Normalizes the trajectories by Earth's radius to display Earth as a unit circle. Graphical Representations (Output) Output Explanation (400 km Altitude) Blue Circle (Earth): Represents Earth as a unit circle; the payload starts at approximately 1.06 Earth radii. Red Curve (Circular Orbit): The payload maintains a stable circular orbit at 400 km altitude. Green Curve (Elliptical Orbit): With \\(0.9 \\times v_{\\text{circ}}\\) , the payload follows a bound elliptical orbit that does not reenter. Magenta Curve (Hyperbolic Trajectory): The payload follows an escape trajectory, with slight differences due to the higher altitude. Exploring the Oberth Effect at Periapsis In this simulation, we compare two cases of a payload initially in an elliptical orbit having a periapsis at 300\u202fkm and an apogee at 600\u202fkm altitude. We consider: Case 1 (No Burn): The payload follows the baseline elliptical orbit. Case 2 (With Burn): At periapsis\u2014where the payload is moving fastest\u2014a small impulsive burn is applied (adding, for example, 100\u202fm/s to the tangential velocity). This extra energy raises the apogee significantly, thereby demonstrating the Oberth effect. Python Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants mu = 3.986004418e14 # Earth's gravitational parameter (m^3/s^2) R_earth = 6.371e6 # Earth's radius (m) # Define orbital parameters for the elliptical orbit: # Periapsis at 300 km and Apogee at 600 km altitude r_p = R_earth + 300e3 # Periapsis radius r_a = R_earth + 600e3 # Apogee radius # Compute the velocity at periapsis for the desired elliptical orbit. # The velocity at periapsis for an ellipse is given by: # v_p = sqrt(2*mu*r_a / (r_p * (r_a + r_p))) v_p = np.sqrt(2 * mu * r_a / (r_p * (r_a + r_p))) # Define a small delta-V to be applied at periapsis (demonstrating the Oberth effect). delta_V = 100 # m/s # Define two cases: # Case 1: No burn (baseline elliptical orbit) # Case 2: Burn applied at periapsis (adds delta_V to the tangential speed) initial_state_no_burn = [r_p, 0, 0, v_p] # Position at (r_p, 0), velocity (0, v_p) initial_state_burn = [r_p, 0, 0, v_p + delta_V] # Position at (r_p, 0), velocity increased # Define the dynamics using Newton's law of gravitation. def dynamics(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] # Event function to stop integration if the payload impacts Earth. def collision_event(t, state): x, y, _, _ = state return np.sqrt(x**2 + y**2) - R_earth collision_event.terminal = True collision_event.direction = -1 # Time parameters t_span = (0, 6000) # seconds - roughly a simulation window covering one or more orbits t_eval = np.linspace(t_span[0], t_span[1], 10000) # Simulate the trajectories for both cases. sol_no_burn = solve_ivp(dynamics, t_span, initial_state_no_burn, t_eval=t_eval, events=collision_event, rtol=1e-8) sol_burn = solve_ivp(dynamics, t_span, initial_state_burn, t_eval=t_eval, events=collision_event, rtol=1e-8) # Plotting the results plt.figure(figsize=(8, 8)) # Draw Earth as a filled circle (normalized by Earth's radius). theta = np.linspace(0, 2*np.pi, 500) earth_x = np.cos(theta) earth_y = np.sin(theta) plt.fill(earth_x, earth_y, 'b', alpha=0.3, label=\"Earth\") # Plot both trajectories (positions normalized by Earth's radius). plt.plot(sol_no_burn.y[0] / R_earth, sol_no_burn.y[1] / R_earth, 'g', label=\"No Burn (Baseline)\") plt.plot(sol_burn.y[0] / R_earth, sol_burn.y[1] / R_earth, 'r', label=\"With Burn (\u0394V = 100 m/s)\") plt.xlabel(\"x (in Earth radii)\") plt.ylabel(\"y (in Earth radii)\") plt.title(\"Effect of an Impulsive Burn at Periapsis (Oberth Effect)\") plt.legend(loc=\"upper right\") plt.axis('equal') plt.grid() plt.show() Explanation of the Code Orbital Parameters and Initial Conditions: Altitudes: The periapsis is set at 300\u202fkm and the apogee at 600\u202fkm above Earth\u2019s surface. These values are converted into radii by adding them to Earth's radius. Periapsis Velocity Calculation: The velocity at periapsis is computed with: $$ v_p = \\sqrt{\\frac{2\\mu \\, r_a}{r_p (r_a + r_p)}} $$ This calculation ensures that the baseline elliptical orbit will have the specified periapsis and apogee. Impulsive Burn: A delta\u2011 \\(V\\) of 100\u202fm/s is applied at periapsis for the second case. Two initial state vectors are defined: No Burn (Baseline): \\([r_p, 0, 0, v_p]\\) With Burn: \\([r_p, 0, 0, v_p + \\Delta V]\\) Dynamics and Numerical Integration: Dynamics Function: The dynamics function calculates the acceleration using Newton\u2019s law of gravitation: $$ \\ddot{x} = -\\frac{\\mu x}{r^3}, \\quad \\ddot{y} = -\\frac{\\mu y}{r^3} $$ Event Function: The collision_event function halts the integration if the payload reaches Earth's surface (i.e., when \\(r = R_{\\text{earth}}\\) ). Integration: Both trajectories are simulated over a 6000-second window using solve_ivp with a tight relative tolerance of \\(1 \\times 10^{-8}\\) to ensure accuracy. Plotting: Earth Representation: Earth is plotted as a blue filled circle after normalizing positions by Earth's radius, so it appears as a unit circle. Trajectory Plotting: The baseline elliptical orbit (no burn) is plotted in green, and the orbit after the impulsive burn is plotted in red. Additional Plot Elements: Labels for the axes, a title, and a legend are included to clarify the two different scenarios. Output Image Below is a representative sample output image from the simulation: Explanation of the Output Visualization Context: Normalized Display: The plot displays Earth as a blue filled unit circle since all distances are normalized by Earth's radius. Starting Point: The simulation begins at a periapsis of 300\u202fkm (roughly \\(1.05\\,R_{\\text{earth}}\\) ), which places the orbits near Earth\u2019s surface on the normalized scale. Baseline Orbit (No Burn): Green Curve: The green curve represents the elliptical orbit with a periapsis at 300\u202fkm and an apogee at 600\u202fkm. This orbit follows the intended path without any modifications. Orbit with Impulsive Burn (Oberth Effect): Red Curve: The red curve shows the orbit after a 100\u202fm/s impulsive burn is applied at periapsis. Effect of the Burn: The burn, performed at the point of highest orbital speed, efficiently increases the orbital energy due to the Oberth effect. This results in a significantly higher apogee compared to the baseline elliptical orbit. Visual Distinction: Although the altitude differences are small relative to Earth's overall size, the divergence between the red and green curves clearly illustrates the impact of the impulsive burn. General Observations: The simulation demonstrates that impulsive burns executed at periapsis are highly effective, as the added delta\u2011 \\(V\\) results in a markedly altered orbit with a raised apogee. Modifying the value of \\(\\Delta V\\) or changing the orbital parameters would result in more pronounced visual differences.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#extended-theoretical-background","text":"Understanding the trajectories of a freely released payload near Earth begins with Newton's Law of Gravitation and the conservation laws of energy and angular momentum. Here, we expand on these principles, derive key equations, and explain how they govern orbital motion.","title":"Extended Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation-and-equations-of-motion","text":"The gravitational force acting on a payload at a distance \\(r\\) from Earth's center is given by \\[ \\vec{F} = -\\frac{\\mu}{r^3}\\vec{r}, \\] where \\(\\mu = GM\\) is Earth\u2019s gravitational parameter ( \\(G\\) is the gravitational constant and \\(M\\) is the mass of Earth). Using Newton's second law, the acceleration of the payload is: \\[ \\ddot{\\vec{r}} = -\\frac{\\mu}{r^3}\\vec{r}. \\] While these equations can be expressed in Cartesian coordinates, gravity as a central force (always pointing toward the center) is more insightfully described in polar coordinates \\((r, \\theta)\\) .","title":"Newton\u2019s Law of Gravitation and Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#polar-coordinates-and-conservation-laws","text":"In polar coordinates, the position vector is represented as: \\[ \\vec{r} = r \\hat{r}. \\] The acceleration in polar coordinates has two components: Radial acceleration: $$ \\ddot{r} - r\\dot{\\theta}^2 = -\\frac{\\mu}{r^2}, $$ Transverse (angular) acceleration: $$ r\\ddot{\\theta} + 2\\dot{r}\\dot{\\theta} = 0. $$ The second equation implies the conservation of angular momentum \\(L\\) : \\[ L = r^2 \\dot{\\theta} = \\text{constant}. \\]","title":"Polar Coordinates and Conservation Laws"},{"location":"1%20Physics/2%20Gravity/Problem_3/#deriving-the-orbit-equation","text":"Using the conservation of angular momentum, we derive an equation for the shape of the orbit. Introducing the substitution: \\[ u = \\frac{1}{r}, \\] and differentiating with respect to \\(\\theta\\) : \\[ \\frac{dr}{d\\theta} = -\\frac{1}{u^2} \\frac{du}{d\\theta}, \\] the radial acceleration term can be expressed in terms of \\(u\\) and \\(\\theta\\) . After some manipulation, the radial equation transforms into the differential equation: \\[ \\frac{d^2 u}{d\\theta^2} + u = \\frac{\\mu}{L^2}. \\] This linear differential equation has the general solution: \\[ u(\\theta) = \\frac{\\mu}{L^2}\\left(1 + e\\cos(\\theta)\\right), \\] or equivalently, the orbital equation in polar form: \\[ r(\\theta) = \\frac{L^2/\\mu}{1 + e\\cos(\\theta)}. \\] Here, \\(e\\) is the eccentricity of the orbit: - \\(0 \\leq e < 1\\) : Elliptical (or circular if \\(e=0\\) ) - \\(e = 1\\) : Parabolic (the threshold between bound and unbound) - \\(e > 1\\) : Hyperbolic (unbound)","title":"Deriving the Orbit Equation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#energy-considerations-the-vis-viva-equation","text":"The specific orbital energy (energy per unit mass) is given by \\[ \\epsilon = \\frac{v^2}{2} - \\frac{\\mu}{r}, \\] where \\(v\\) is the speed of the payload. The sign of \\(\\epsilon\\) determines the type of orbit: Elliptical orbits: \\(\\epsilon < 0\\) Parabolic trajectory: \\(\\epsilon = 0\\) Hyperbolic trajectory: \\(\\epsilon > 0\\) For a given orbit, the vis-viva equation relates the velocity \\(v\\) at any distance \\(r\\) to the semi-major axis \\(a\\) : \\[ v^2 = \\mu\\left(\\frac{2}{r} - \\frac{1}{a}\\right). \\] For a circular orbit ( \\(r = a\\) ), this simplifies to: \\[ v_{\\text{circ}} = \\sqrt{\\frac{\\mu}{r}}, \\] and the escape velocity (the speed needed for a parabolic trajectory) is: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2\\mu}{r}}. \\]","title":"Energy Considerations: The Vis-Viva Equation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#effective-potential-and-radial-motion","text":"Another way to analyze orbital motion is through the effective potential. The total energy in the radial direction, considering the conservation of angular momentum, can be expressed as: \\[ \\epsilon = \\frac{1}{2}\\dot{r}^2 + V_{\\text{eff}}(r), \\] where the effective potential \\(V_{\\text{eff}}(r)\\) is defined as: \\[ V_{\\text{eff}}(r) = -\\frac{\\mu}{r} + \\frac{L^2}{2r^2}. \\] The first term represents gravitational potential energy. The second term represents the \"centrifugal\" potential energy due to the payload's angular momentum. The effective potential provides insight into radial stability. The minimum of \\(V_{\\text{eff}}(r)\\) corresponds to a stable circular orbit, while deviations lead to oscillatory changes in \\(r\\) , characteristic of elliptical orbits.","title":"Effective Potential and Radial Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#connecting-initial-conditions-to-orbit-types","text":"The initial position and velocity determine both the specific energy \\(\\epsilon\\) and the angular momentum \\(L\\) : Circular Orbit: The velocity is exactly \\(v_{\\text{circ}}\\) , balancing gravitational pull and centripetal force for a constant \\(r\\) . Elliptical Orbit: A velocity lower than \\(v_{\\text{circ}}\\) results in an elliptical path with varying \\(r\\) . Hyperbolic Trajectory: A velocity exceeding \\(v_{\\text{esc}}\\) results in a positive energy orbit, allowing the payload to escape Earth\u2019s gravitational influence.","title":"Connecting Initial Conditions to Orbit Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary","text":"The trajectory of a payload released near Earth is governed by: - Gravitational forces: As described by Newton\u2019s law. - Conservation of angular momentum: Leading to the derivation of the orbit equation. - Energy considerations: Classifying orbits as elliptical, parabolic, or hyperbolic based on the specific orbital energy. - Effective potential: Providing insight into the stability of orbits. This theoretical framework forms the basis for designing simulations and computational tools to predict payload trajectories for space missions. Below is the updated Markdown document that includes the code, the image of the output , and a detailed explanation of that output. Note that we\u2019ve replaced references to \"simulation\" with \"output,\" as requested.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation","text":"Below are two separate simulation scenarios for comparison. The left side shows Scenario 1 (200 km Altitude) and the right side shows Scenario 2 (400 km Altitude) . In Scenario 1, the payload is released from 200\u202fkm altitude with: Circular Orbit: \\( v = \\sqrt{\\mu/(R_{\\text{earth}}+200\\,\\text{km})} \\) Elliptical / Reentry: \\( v = 0.8 \\times v_{\\text{circ}} \\) (which leads to reentry) Hyperbolic Trajectory: \\( v = 1.1 \\times v_{\\text{esc}} \\) In Scenario 2, the payload is released from 400\u202fkm altitude with: Circular Orbit: \\( v = \\sqrt{\\mu/(R_{\\text{earth}}+400\\,\\text{km})} \\) Elliptical Orbit: \\( v = 0.9 \\times v_{\\text{circ}} \\) (producing a stable, bound elliptical orbit) Hyperbolic Trajectory: \\( v = 1.1 \\times v_{\\text{esc}} \\)","title":"Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#scenario-1-200-km-altitude","text":"","title":"Scenario 1 (200 km Altitude)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants mu = 3.986004418e14 # Earth's gravitational parameter (m^3/s^2) R_earth = 6.371e6 # Earth's radius (m) def dynamics(t, state): \"\"\" Computes the derivatives for the state vector. state = [x, y, vx, vy] \"\"\" x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] def collision_event(t, state): \"\"\" Event function to detect collision with Earth. Integration stops when r - R_earth = 0. \"\"\" x, y, _, _ = state r = np.sqrt(x**2 + y**2) return r - R_earth collision_event.terminal = True collision_event.direction = -1 def simulate_trajectory(r0, v0, t_span, t_eval): \"\"\" Simulates the payload trajectory given initial conditions. \"\"\" state0 = [r0[0], r0[1], v0[0], v0[1]] return solve_ivp(dynamics, t_span, state0, t_eval=t_eval, events=collision_event, rtol=1e-8) # Initial Conditions for 200 km altitude altitude = 200e3 # 200 km altitude r_mag = R_earth + altitude # Distance from Earth's center r0 = [r_mag, 0] # Starting along the x-axis # Trajectory Cases v_circ = np.sqrt(mu / r_mag) # Circular Orbit speed v0_circ = [0, v_circ] v0_ellipse = [0, 0.8 * v_circ] # Elliptical / Reentry (0.8\u00d7v_circ) v_esc = np.sqrt(2 * mu / r_mag) # Escape Velocity v0_hyper = [0, 1.1 * v_esc] # Hyperbolic Trajectory (1.1\u00d7v_esc) # Time parameters t_span = (0, 6000) # seconds t_eval = np.linspace(t_span[0], t_span[1], 10000) # Simulate trajectories for 200 km altitude sol_circ = simulate_trajectory(r0, v0_circ, t_span, t_eval) sol_ellipse = simulate_trajectory(r0, v0_ellipse, t_span, t_eval) sol_hyper = simulate_trajectory(r0, v0_hyper, t_span, t_eval) # Plot the trajectories (normalized by Earth's radius) plt.figure(figsize=(8, 8)) theta = np.linspace(0, 2*np.pi, 500) earth_x = np.cos(theta) earth_y = np.sin(theta) plt.fill(earth_x, earth_y, 'b', alpha=0.3, label=\"Earth\") plt.plot(sol_circ.y[0] / R_earth, sol_circ.y[1] / R_earth, 'r', label=\"Circular Orbit\") plt.plot(sol_ellipse.y[0] / R_earth, sol_ellipse.y[1] / R_earth, 'g', label=\"Elliptical / Reentry\") plt.plot(sol_hyper.y[0] / R_earth, sol_hyper.y[1] / R_earth, 'm', label=\"Hyperbolic Trajectory\") plt.xlabel(\"x (in Earth radii)\") plt.ylabel(\"y (in Earth radii)\") plt.title(\"Payload Trajectories Near Earth (200 km Altitude)\") plt.legend() plt.axis('equal') plt.grid() plt.show()","title":"Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation-of-the-code-scenario-1","text":"Dynamics Function: The dynamics function computes the derivatives of the state vector \\([x, y, vx, vy]\\) using Newton\u2019s law of gravitation, \\(\\ddot{\\vec{r}} = -\\mu \\vec{r}/r^3\\) . Simulation Function: The simulate_trajectory function sets up the initial state and integrates the equations over the defined time span using the solve_ivp solver. The collision event stops the integration when the payload intersects Earth\u2019s surface. Initial Conditions: The payload is assumed to be released from a position 200 km above Earth's surface. Three initial velocity cases are defined: Circular orbit: using the circular velocity \\(v_{\\text{circ}} = \\sqrt{\\mu / r}\\) . Elliptical trajectory: using 80% of the circular velocity. Hyperbolic trajectory: using 110% of the escape velocity \\(v_{\\text{esc}} = \\sqrt{2\\mu / r}\\) . Plotting: The code normalizes positions by Earth's radius to display Earth as a unit circle. Each trajectory is plotted in the \\(xy\\) -plane.","title":"Explanation of the Code (Scenario 1)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#graphical-representations-output","text":"","title":"Graphical Representations (Output)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#output-explanation-scenario-1","text":"Blue Circle (Earth): Represents Earth as a unit circle. The payload is released at approximately 1.03 Earth radii. Red Curve (Circular Orbit): The payload maintains a tight circular orbit at 200 km altitude. Green Curve (Elliptical / Reentry): With \\(0.8 \\times v_{\\text{circ}}\\) , the payload\u2019s trajectory intersects Earth (reentry). Magenta Curve (Hyperbolic Trajectory): The payload follows an escape trajectory.","title":"Output Explanation (Scenario 1)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#key-takeaways-scenario-1","text":"Altering the initial velocity significantly changes the orbital path. At 200 km, using \\(0.8 \\times v_{\\text{circ}}\\) leads to reentry. The hyperbolic trajectory clearly demonstrates escape conditions.","title":"Key Takeaways (Scenario 1)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#scenario-2-400-km-altitude","text":"","title":"Scenario 2 (400 km Altitude)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#code_1","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants mu = 3.986004418e14 # Earth's gravitational parameter (m^3/s^2) R_earth = 6.371e6 # Earth's radius (m) def dynamics(t, state): \"\"\"Computes the derivatives for the state vector [x, y, vx, vy] using Newton's law.\"\"\" x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] def collision_event(t, state): \"\"\"Stops integration when the payload reaches Earth's surface.\"\"\" x, y, _, _ = state return np.sqrt(x**2 + y**2) - R_earth collision_event.terminal = True collision_event.direction = -1 def simulate_trajectory(r0, v0, t_span, t_eval): \"\"\"Simulates the payload trajectory given initial conditions.\"\"\" state0 = [r0[0], r0[1], v0[0], v0[1]] return solve_ivp(dynamics, t_span, state0, t_eval=t_eval, events=collision_event, rtol=1e-8) # Initial Conditions for 400 km altitude altitude = 400e3 # 400 km altitude r_mag = R_earth + altitude # Distance from Earth's center r0 = [r_mag, 0] # Starting along the x-axis # Trajectory Cases v_circ = np.sqrt(mu / r_mag) # Circular Orbit speed v0_circ = [0, v_circ] v0_ellipse = [0, 0.9 * v_circ] # Elliptical Orbit (bound) using 0.9\u00d7v_circ v_esc = np.sqrt(2 * mu / r_mag) # Escape Velocity v0_hyper = [0, 1.1 * v_esc] # Hyperbolic Trajectory (1.1\u00d7v_esc) # Time parameters t_span = (0, 6000) # seconds t_eval = np.linspace(t_span[0], t_span[1], 10000) # Simulate trajectories for 400 km altitude sol_circ_new = simulate_trajectory(r0, v0_circ, t_span, t_eval) sol_ellipse_new = simulate_trajectory(r0, v0_ellipse, t_span, t_eval) sol_hyper_new = simulate_trajectory(r0, v0_hyper, t_span, t_eval) # Plot the trajectories (normalized by Earth's radius) plt.figure(figsize=(8, 8)) theta = np.linspace(0, 2*np.pi, 500) earth_x = np.cos(theta) earth_y = np.sin(theta) plt.fill(earth_x, earth_y, 'b', alpha=0.3, label=\"Earth\") plt.plot(sol_circ_new.y[0] / R_earth, sol_circ_new.y[1] / R_earth, 'r', label=\"Circular Orbit (400 km)\") plt.plot(sol_ellipse_new.y[0] / R_earth, sol_ellipse_new.y[1] / R_earth, 'g', label=\"Elliptical Orbit (400 km)\") plt.plot(sol_hyper_new.y[0] / R_earth, sol_hyper_new.y[1] / R_earth, 'm', label=\"Hyperbolic Trajectory (400 km)\") plt.xlabel(\"x (in Earth radii)\") plt.ylabel(\"y (in Earth radii)\") plt.title(\"Payload Trajectories at 400 km Altitude\") plt.legend() plt.axis('equal') plt.grid() plt.show()","title":"Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation-of-the-code-scenario-2","text":"Dynamics Function: Computes the derivatives of the state vector \\([x, y, vx, vy]\\) using Newton\u2019s law. Simulation Function: Sets up the initial state and integrates the equations over time using solve_ivp, with a collision event stopping the integration when the payload hits Earth. Initial Conditions (400 km): The payload is released from 400 km altitude (approximately 1.06 Earth radii). Circular Orbit: \\(v = \\sqrt{\\mu/(R_{\\text{earth}}+400\\,\\text{km})}\\) Elliptical Orbit: \\(v = 0.9 \\times v_{\\text{circ}}\\) (producing a bound elliptical orbit) Hyperbolic Trajectory: \\(v = 1.1 \\times v_{\\text{esc}}\\) Plotting: Normalizes the trajectories by Earth's radius to display Earth as a unit circle.","title":"Explanation of the Code (Scenario 2)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#graphical-representations-output_1","text":"","title":"Graphical Representations (Output)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#output-explanation-400-km-altitude","text":"Blue Circle (Earth): Represents Earth as a unit circle; the payload starts at approximately 1.06 Earth radii. Red Curve (Circular Orbit): The payload maintains a stable circular orbit at 400 km altitude. Green Curve (Elliptical Orbit): With \\(0.9 \\times v_{\\text{circ}}\\) , the payload follows a bound elliptical orbit that does not reenter. Magenta Curve (Hyperbolic Trajectory): The payload follows an escape trajectory, with slight differences due to the higher altitude.","title":"Output Explanation (400 km Altitude)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#exploring-the-oberth-effect-at-periapsis","text":"In this simulation, we compare two cases of a payload initially in an elliptical orbit having a periapsis at 300\u202fkm and an apogee at 600\u202fkm altitude. We consider: Case 1 (No Burn): The payload follows the baseline elliptical orbit. Case 2 (With Burn): At periapsis\u2014where the payload is moving fastest\u2014a small impulsive burn is applied (adding, for example, 100\u202fm/s to the tangential velocity). This extra energy raises the apogee significantly, thereby demonstrating the Oberth effect.","title":"Exploring the Oberth Effect at Periapsis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants mu = 3.986004418e14 # Earth's gravitational parameter (m^3/s^2) R_earth = 6.371e6 # Earth's radius (m) # Define orbital parameters for the elliptical orbit: # Periapsis at 300 km and Apogee at 600 km altitude r_p = R_earth + 300e3 # Periapsis radius r_a = R_earth + 600e3 # Apogee radius # Compute the velocity at periapsis for the desired elliptical orbit. # The velocity at periapsis for an ellipse is given by: # v_p = sqrt(2*mu*r_a / (r_p * (r_a + r_p))) v_p = np.sqrt(2 * mu * r_a / (r_p * (r_a + r_p))) # Define a small delta-V to be applied at periapsis (demonstrating the Oberth effect). delta_V = 100 # m/s # Define two cases: # Case 1: No burn (baseline elliptical orbit) # Case 2: Burn applied at periapsis (adds delta_V to the tangential speed) initial_state_no_burn = [r_p, 0, 0, v_p] # Position at (r_p, 0), velocity (0, v_p) initial_state_burn = [r_p, 0, 0, v_p + delta_V] # Position at (r_p, 0), velocity increased # Define the dynamics using Newton's law of gravitation. def dynamics(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] # Event function to stop integration if the payload impacts Earth. def collision_event(t, state): x, y, _, _ = state return np.sqrt(x**2 + y**2) - R_earth collision_event.terminal = True collision_event.direction = -1 # Time parameters t_span = (0, 6000) # seconds - roughly a simulation window covering one or more orbits t_eval = np.linspace(t_span[0], t_span[1], 10000) # Simulate the trajectories for both cases. sol_no_burn = solve_ivp(dynamics, t_span, initial_state_no_burn, t_eval=t_eval, events=collision_event, rtol=1e-8) sol_burn = solve_ivp(dynamics, t_span, initial_state_burn, t_eval=t_eval, events=collision_event, rtol=1e-8) # Plotting the results plt.figure(figsize=(8, 8)) # Draw Earth as a filled circle (normalized by Earth's radius). theta = np.linspace(0, 2*np.pi, 500) earth_x = np.cos(theta) earth_y = np.sin(theta) plt.fill(earth_x, earth_y, 'b', alpha=0.3, label=\"Earth\") # Plot both trajectories (positions normalized by Earth's radius). plt.plot(sol_no_burn.y[0] / R_earth, sol_no_burn.y[1] / R_earth, 'g', label=\"No Burn (Baseline)\") plt.plot(sol_burn.y[0] / R_earth, sol_burn.y[1] / R_earth, 'r', label=\"With Burn (\u0394V = 100 m/s)\") plt.xlabel(\"x (in Earth radii)\") plt.ylabel(\"y (in Earth radii)\") plt.title(\"Effect of an Impulsive Burn at Periapsis (Oberth Effect)\") plt.legend(loc=\"upper right\") plt.axis('equal') plt.grid() plt.show()","title":"Python Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation-of-the-code","text":"Orbital Parameters and Initial Conditions: Altitudes: The periapsis is set at 300\u202fkm and the apogee at 600\u202fkm above Earth\u2019s surface. These values are converted into radii by adding them to Earth's radius. Periapsis Velocity Calculation: The velocity at periapsis is computed with: $$ v_p = \\sqrt{\\frac{2\\mu \\, r_a}{r_p (r_a + r_p)}} $$ This calculation ensures that the baseline elliptical orbit will have the specified periapsis and apogee. Impulsive Burn: A delta\u2011 \\(V\\) of 100\u202fm/s is applied at periapsis for the second case. Two initial state vectors are defined: No Burn (Baseline): \\([r_p, 0, 0, v_p]\\) With Burn: \\([r_p, 0, 0, v_p + \\Delta V]\\) Dynamics and Numerical Integration: Dynamics Function: The dynamics function calculates the acceleration using Newton\u2019s law of gravitation: $$ \\ddot{x} = -\\frac{\\mu x}{r^3}, \\quad \\ddot{y} = -\\frac{\\mu y}{r^3} $$ Event Function: The collision_event function halts the integration if the payload reaches Earth's surface (i.e., when \\(r = R_{\\text{earth}}\\) ). Integration: Both trajectories are simulated over a 6000-second window using solve_ivp with a tight relative tolerance of \\(1 \\times 10^{-8}\\) to ensure accuracy. Plotting: Earth Representation: Earth is plotted as a blue filled circle after normalizing positions by Earth's radius, so it appears as a unit circle. Trajectory Plotting: The baseline elliptical orbit (no burn) is plotted in green, and the orbit after the impulsive burn is plotted in red. Additional Plot Elements: Labels for the axes, a title, and a legend are included to clarify the two different scenarios.","title":"Explanation of the Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#output-image","text":"Below is a representative sample output image from the simulation:","title":"Output Image"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation-of-the-output","text":"Visualization Context: Normalized Display: The plot displays Earth as a blue filled unit circle since all distances are normalized by Earth's radius. Starting Point: The simulation begins at a periapsis of 300\u202fkm (roughly \\(1.05\\,R_{\\text{earth}}\\) ), which places the orbits near Earth\u2019s surface on the normalized scale. Baseline Orbit (No Burn): Green Curve: The green curve represents the elliptical orbit with a periapsis at 300\u202fkm and an apogee at 600\u202fkm. This orbit follows the intended path without any modifications. Orbit with Impulsive Burn (Oberth Effect): Red Curve: The red curve shows the orbit after a 100\u202fm/s impulsive burn is applied at periapsis. Effect of the Burn: The burn, performed at the point of highest orbital speed, efficiently increases the orbital energy due to the Oberth effect. This results in a significantly higher apogee compared to the baseline elliptical orbit. Visual Distinction: Although the altitude differences are small relative to Earth's overall size, the divergence between the red and green curves clearly illustrates the impact of the impulsive burn. General Observations: The simulation demonstrates that impulsive burns executed at periapsis are highly effective, as the added delta\u2011 \\(V\\) results in a markedly altered orbit with a raised apogee. Modifying the value of \\(\\Delta V\\) or changing the orbital parameters would result in more pronounced visual differences.","title":"Explanation of the Output"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Introduction Interference occurs when circular waves from multiple coherent point sources combine, resulting in patterns of constructive and destructive interference on a water surface. In this study, sources are placed at the vertices of a regular polygon. All sources are identical in terms of amplitude, wavelength, frequency, and phase, and the overall wave field is determined by the superposition of the individual waves. Theoretical Background A circular wave generated by a point source at \\((x_i, y_i)\\) is modeled by \\[ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i + \\epsilon}} \\cos\\Bigl(k\\,r_i - \\omega\\,t + \\phi\\Bigr), \\] where - \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the source to the point \\((x,y)\\) , - \\(A\\) is the amplitude, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega = 2\\pi f\\) is the angular frequency, - \\(\\phi\\) is the initial phase, and - \\(\\epsilon\\) (typically 0.01) prevents division by zero. For \\(N\\) sources arranged in a regular polygon of radius \\(R\\) , the source coordinates are \\[ x_i = R \\cos\\Bigl(\\frac{2\\pi i}{N}\\Bigr), \\quad y_i = R \\sin\\Bigl(\\frac{2\\pi i}{N}\\Bigr), \\quad i = 0, 1, \\dots, N-1. \\] The overall displacement at a point \\((x,y)\\) and time \\(t\\) is obtained by the superposition: \\[ \\eta(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t). \\] Python Code Implementation import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from matplotlib import cm import matplotlib.colors as colors class WaveInterferenceSimulation: def __init__(self, polygon_sides=3, radius=1.0, amplitude=1.0, wavelength=0.5, frequency=1.0, initial_phase=0.0): \"\"\" Initialize the simulation with sources located at the vertices of a regular polygon. \"\"\" self.n_sides = polygon_sides self.radius = radius self.A = amplitude self.wavelength = wavelength self.f = frequency self.phi = initial_phase # Derived parameters self.k = 2 * np.pi / wavelength # Wave number self.omega = 2 * np.pi * frequency # Angular frequency # Calculate source positions self.source_positions = self._calculate_polygon_vertices() # Setup a grid for visualization self.resolution = 300 self.grid_range = 3.0 self.x = np.linspace(-self.grid_range, self.grid_range, self.resolution) self.y = np.linspace(-self.grid_range, self.grid_range, self.resolution) self.X, self.Y = np.meshgrid(self.x, self.y) # Initialize time self.t = 0.0 def _calculate_polygon_vertices(self): \"\"\"Calculate vertices of a regular polygon centered at the origin.\"\"\" angles = np.linspace(0, 2*np.pi, self.n_sides, endpoint=False) x_coords = self.radius * np.cos(angles) y_coords = self.radius * np.sin(angles) return list(zip(x_coords, y_coords)) def single_wave(self, x, y, source_x, source_y, t): \"\"\" Compute displacement from a single source at (source_x, source_y) at time t. \"\"\" r = np.sqrt((x - source_x)**2 + (y - source_y)**2) return self.A / np.sqrt(r + 0.01) * np.cos(self.k * r - self.omega * t + self.phi) def total_displacement(self, x, y, t): \"\"\" Compute total displacement by summing contributions from all sources. \"\"\" eta_total = np.zeros_like(x) for source_x, source_y in self.source_positions: eta_total += self.single_wave(x, y, source_x, source_y, t) return eta_total def calculate_intensity(self, x, y): \"\"\" Compute time-averaged intensity (proportional to amplitude squared). \"\"\" times = np.linspace(0, 2*np.pi/self.omega, 12) intensity = np.zeros_like(x) for t in times: displacement = self.total_displacement(x, y, t) intensity += displacement**2 intensity /= len(times) return intensity def plot_sources(self): \"\"\"Mark source positions on the current figure.\"\"\" for i, (sx, sy) in enumerate(self.source_positions): plt.plot(sx, sy, 'ro', markersize=10) plt.text(sx*1.1, sy*1.1, f'S{i+1}', fontsize=12) def plot_snapshot(self, t=0.0, show_sources=True, cmap='seismic'): \"\"\" Generate a contour plot of the wave displacement at time t. \"\"\" displacement = self.total_displacement(self.X, self.Y, t) plt.figure(figsize=(10, 8)) plt.contourf(self.X, self.Y, displacement, 50, cmap=cmap) plt.colorbar(label='Displacement') if show_sources: self.plot_sources() x_sources, y_sources = zip(*self.source_positions) plt.plot(x_sources + (x_sources[0],), y_sources + (y_sources[0],), 'k--', alpha=0.5) plt.title(f'Wave Displacement at t = {t:.2f}s') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.grid(alpha=0.3) return plt.gcf() def plot_intensity_map(self, show_sources=True): \"\"\" Generate a contour plot of the time-averaged intensity. \"\"\" intensity = self.calculate_intensity(self.X, self.Y) plt.figure(figsize=(10, 8)) plt.contourf(self.X, self.Y, intensity, 50, cmap='viridis') plt.colorbar(label='Intensity (proportional to amplitude\u00b2)') if show_sources: self.plot_sources() x_sources, y_sources = zip(*self.source_positions) plt.plot(x_sources + (x_sources[0],), y_sources + (y_sources[0],), 'k--', alpha=0.5) plt.title(f'Interference Pattern Intensity Map - {self.n_sides}-sided polygon') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.grid(alpha=0.3) return plt.gcf() def create_animation(self, duration=5.0, fps=20): \"\"\" Create an animation of the evolving wave interference pattern. \"\"\" fig, ax = plt.subplots(figsize=(8, 8)) displacement = self.total_displacement(self.X, self.Y, 0) contour_plot = ax.contourf(self.X, self.Y, displacement, 50, cmap='seismic') for sx, sy in self.source_positions: ax.plot(sx, sy, 'ro', markersize=8) x_sources, y_sources = zip(*self.source_positions) ax.plot(x_sources + (x_sources[0],), y_sources + (y_sources[0],), 'k--', alpha=0.5) ax.set_xlim(-self.grid_range, self.grid_range) ax.set_ylim(-self.grid_range, self.grid_range) ax.set_title('Wave Interference Animation') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_aspect('equal') ax.grid(alpha=0.3) plt.colorbar(contour_plot, ax=ax, label='Displacement') def update(frame): t = frame / fps for c in contour_plot.collections: c.remove() new_disp = self.total_displacement(self.X, self.Y, t) new_contour = ax.contourf(self.X, self.Y, new_disp, 50, cmap='seismic') ax.set_title(f'Wave Interference at t = {t:.2f}s') return new_contour.collections frames = int(duration * fps) anim = FuncAnimation(fig, update, frames=frames, interval=1000/fps, blit=False) return anim def analyze_different_polygons(self, n_sides_list=[3, 4, 5, 6], figsize=(16, 12)): \"\"\" Compare displacement and intensity maps for various regular polygons. \"\"\" fig, axes = plt.subplots(2, len(n_sides_list), figsize=figsize) for i, n in enumerate(n_sides_list): sim = WaveInterferenceSimulation( polygon_sides=n, amplitude=self.A, wavelength=self.wavelength, frequency=self.f, initial_phase=self.phi ) disp = sim.total_displacement(sim.X, sim.Y, 0) intensity = sim.calculate_intensity(sim.X, sim.Y) # Displacement plot ax1 = axes[0, i] im1 = ax1.contourf(sim.X, sim.Y, disp, 50, cmap='seismic') plt.colorbar(im1, ax=ax1, label='Displacement') for sx, sy in sim.source_positions: ax1.plot(sx, sy, 'ro', markersize=6) x_src, y_src = zip(*sim.source_positions) ax1.plot(x_src + (x_src[0],), y_src + (y_src[0],), 'k--', alpha=0.5) ax1.set_title(f'{n}-sided Polygon - Displacement') ax1.set_xlabel('x') ax1.set_ylabel('y') ax1.set_aspect('equal') # Intensity plot ax2 = axes[1, i] im2 = ax2.contourf(sim.X, sim.Y, intensity, 50, cmap='viridis') plt.colorbar(im2, ax=ax2, label='Intensity') for sx, sy in sim.source_positions: ax2.plot(sx, sy, 'ro', markersize=6) ax2.plot(x_src + (x_src[0],), y_src + (y_src[0],), 'k--', alpha=0.5) ax2.set_title(f'{n}-sided Polygon - Intensity') ax2.set_xlabel('x') ax2.set_ylabel('y') ax2.set_aspect('equal') plt.tight_layout() return fig # Example usage if __name__ == \"__main__\": sim = WaveInterferenceSimulation( polygon_sides=3, # Triangle radius=1.0, amplitude=1.0, wavelength=0.5, frequency=1.0 ) # 1) Plot a snapshot at t = 0 and save the figure sim.plot_snapshot(t=0) plt.savefig('triangle_wave_snapshot.png', dpi=150) # 2) Plot the time-averaged intensity map and save the figure sim.plot_intensity_map() plt.savefig('triangle_intensity_map.png', dpi=150) # 3) Compare different polygons (3, 4, 5, 6) and save the figure fig = sim.analyze_different_polygons([3, 4, 5, 6]) plt.savefig('polygon_comparison.png', dpi=150) # 4) Create an animation of the wave field (3 seconds at 15 fps) anim = sim.create_animation(duration=3.0, fps=15) # To save the animation as a GIF, uncomment the following line: # anim.save('wave_animation.gif', writer='pillow', fps=15) plt.show() Output Images and Explanations 1. Wave Snapshot Explanation: The snapshot shows the instantaneous displacement of the wave field at \\(t = 0\\) for a triangular configuration. The contour plot clearly illustrates areas where wave amplitudes reinforce (constructive interference) and cancel (destructive interference). The red markers denote the positions of the sources, and the dashed line outlines the triangular boundary. 2. Intensity Map Explanation: The intensity map displays the time-averaged energy distribution of the wave field. Bright regions indicate consistent high amplitude (constructive interference), while darker areas reveal destructive interference. The map includes the marked source positions and the connecting polygon, providing a clear visual of the interference pattern\u2019s overall structure. 3. Polygon Comparison Explanation: This comparison presents displacement maps (top row) and intensity maps (bottom row) for polygons with 3, 4, 5, and 6 sides. The plots reveal that as the number of sides increases, the interference pattern becomes more intricate and symmetric, demonstrating the impact of source geometry on wave superposition. 4. Wave Animation Explanation: The animation shows the dynamic evolution of the interference pattern over time. The moving crests and troughs indicate phase variations, yet the overall symmetry dictated by the polygon is maintained throughout the animation. This dynamic visualization offers insight into how the interference pattern shifts while the basic structure remains constant. Summary Wave Snapshot: Captures the instantaneous wave displacement, highlighting constructive and destructive interference in a triangular configuration. Intensity Map: Illustrates the time-averaged energy distribution, revealing stable regions of interference. Polygon Comparison: Demonstrates how increasing the number of sources (i.e., using different regular polygons) affects the complexity and symmetry of the interference patterns. Wave Animation: Provides a dynamic view of the wave evolution, emphasizing the temporal changes in the interference pattern while preserving the geometric symmetry. This solution, including theoretical background, full Python code, output images with explanations, and a summary, meets all the problem requirements.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#theoretical-background","text":"A circular wave generated by a point source at \\((x_i, y_i)\\) is modeled by \\[ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i + \\epsilon}} \\cos\\Bigl(k\\,r_i - \\omega\\,t + \\phi\\Bigr), \\] where - \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the source to the point \\((x,y)\\) , - \\(A\\) is the amplitude, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega = 2\\pi f\\) is the angular frequency, - \\(\\phi\\) is the initial phase, and - \\(\\epsilon\\) (typically 0.01) prevents division by zero. For \\(N\\) sources arranged in a regular polygon of radius \\(R\\) , the source coordinates are \\[ x_i = R \\cos\\Bigl(\\frac{2\\pi i}{N}\\Bigr), \\quad y_i = R \\sin\\Bigl(\\frac{2\\pi i}{N}\\Bigr), \\quad i = 0, 1, \\dots, N-1. \\] The overall displacement at a point \\((x,y)\\) and time \\(t\\) is obtained by the superposition: \\[ \\eta(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t). \\]","title":"Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from matplotlib import cm import matplotlib.colors as colors class WaveInterferenceSimulation: def __init__(self, polygon_sides=3, radius=1.0, amplitude=1.0, wavelength=0.5, frequency=1.0, initial_phase=0.0): \"\"\" Initialize the simulation with sources located at the vertices of a regular polygon. \"\"\" self.n_sides = polygon_sides self.radius = radius self.A = amplitude self.wavelength = wavelength self.f = frequency self.phi = initial_phase # Derived parameters self.k = 2 * np.pi / wavelength # Wave number self.omega = 2 * np.pi * frequency # Angular frequency # Calculate source positions self.source_positions = self._calculate_polygon_vertices() # Setup a grid for visualization self.resolution = 300 self.grid_range = 3.0 self.x = np.linspace(-self.grid_range, self.grid_range, self.resolution) self.y = np.linspace(-self.grid_range, self.grid_range, self.resolution) self.X, self.Y = np.meshgrid(self.x, self.y) # Initialize time self.t = 0.0 def _calculate_polygon_vertices(self): \"\"\"Calculate vertices of a regular polygon centered at the origin.\"\"\" angles = np.linspace(0, 2*np.pi, self.n_sides, endpoint=False) x_coords = self.radius * np.cos(angles) y_coords = self.radius * np.sin(angles) return list(zip(x_coords, y_coords)) def single_wave(self, x, y, source_x, source_y, t): \"\"\" Compute displacement from a single source at (source_x, source_y) at time t. \"\"\" r = np.sqrt((x - source_x)**2 + (y - source_y)**2) return self.A / np.sqrt(r + 0.01) * np.cos(self.k * r - self.omega * t + self.phi) def total_displacement(self, x, y, t): \"\"\" Compute total displacement by summing contributions from all sources. \"\"\" eta_total = np.zeros_like(x) for source_x, source_y in self.source_positions: eta_total += self.single_wave(x, y, source_x, source_y, t) return eta_total def calculate_intensity(self, x, y): \"\"\" Compute time-averaged intensity (proportional to amplitude squared). \"\"\" times = np.linspace(0, 2*np.pi/self.omega, 12) intensity = np.zeros_like(x) for t in times: displacement = self.total_displacement(x, y, t) intensity += displacement**2 intensity /= len(times) return intensity def plot_sources(self): \"\"\"Mark source positions on the current figure.\"\"\" for i, (sx, sy) in enumerate(self.source_positions): plt.plot(sx, sy, 'ro', markersize=10) plt.text(sx*1.1, sy*1.1, f'S{i+1}', fontsize=12) def plot_snapshot(self, t=0.0, show_sources=True, cmap='seismic'): \"\"\" Generate a contour plot of the wave displacement at time t. \"\"\" displacement = self.total_displacement(self.X, self.Y, t) plt.figure(figsize=(10, 8)) plt.contourf(self.X, self.Y, displacement, 50, cmap=cmap) plt.colorbar(label='Displacement') if show_sources: self.plot_sources() x_sources, y_sources = zip(*self.source_positions) plt.plot(x_sources + (x_sources[0],), y_sources + (y_sources[0],), 'k--', alpha=0.5) plt.title(f'Wave Displacement at t = {t:.2f}s') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.grid(alpha=0.3) return plt.gcf() def plot_intensity_map(self, show_sources=True): \"\"\" Generate a contour plot of the time-averaged intensity. \"\"\" intensity = self.calculate_intensity(self.X, self.Y) plt.figure(figsize=(10, 8)) plt.contourf(self.X, self.Y, intensity, 50, cmap='viridis') plt.colorbar(label='Intensity (proportional to amplitude\u00b2)') if show_sources: self.plot_sources() x_sources, y_sources = zip(*self.source_positions) plt.plot(x_sources + (x_sources[0],), y_sources + (y_sources[0],), 'k--', alpha=0.5) plt.title(f'Interference Pattern Intensity Map - {self.n_sides}-sided polygon') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.grid(alpha=0.3) return plt.gcf() def create_animation(self, duration=5.0, fps=20): \"\"\" Create an animation of the evolving wave interference pattern. \"\"\" fig, ax = plt.subplots(figsize=(8, 8)) displacement = self.total_displacement(self.X, self.Y, 0) contour_plot = ax.contourf(self.X, self.Y, displacement, 50, cmap='seismic') for sx, sy in self.source_positions: ax.plot(sx, sy, 'ro', markersize=8) x_sources, y_sources = zip(*self.source_positions) ax.plot(x_sources + (x_sources[0],), y_sources + (y_sources[0],), 'k--', alpha=0.5) ax.set_xlim(-self.grid_range, self.grid_range) ax.set_ylim(-self.grid_range, self.grid_range) ax.set_title('Wave Interference Animation') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_aspect('equal') ax.grid(alpha=0.3) plt.colorbar(contour_plot, ax=ax, label='Displacement') def update(frame): t = frame / fps for c in contour_plot.collections: c.remove() new_disp = self.total_displacement(self.X, self.Y, t) new_contour = ax.contourf(self.X, self.Y, new_disp, 50, cmap='seismic') ax.set_title(f'Wave Interference at t = {t:.2f}s') return new_contour.collections frames = int(duration * fps) anim = FuncAnimation(fig, update, frames=frames, interval=1000/fps, blit=False) return anim def analyze_different_polygons(self, n_sides_list=[3, 4, 5, 6], figsize=(16, 12)): \"\"\" Compare displacement and intensity maps for various regular polygons. \"\"\" fig, axes = plt.subplots(2, len(n_sides_list), figsize=figsize) for i, n in enumerate(n_sides_list): sim = WaveInterferenceSimulation( polygon_sides=n, amplitude=self.A, wavelength=self.wavelength, frequency=self.f, initial_phase=self.phi ) disp = sim.total_displacement(sim.X, sim.Y, 0) intensity = sim.calculate_intensity(sim.X, sim.Y) # Displacement plot ax1 = axes[0, i] im1 = ax1.contourf(sim.X, sim.Y, disp, 50, cmap='seismic') plt.colorbar(im1, ax=ax1, label='Displacement') for sx, sy in sim.source_positions: ax1.plot(sx, sy, 'ro', markersize=6) x_src, y_src = zip(*sim.source_positions) ax1.plot(x_src + (x_src[0],), y_src + (y_src[0],), 'k--', alpha=0.5) ax1.set_title(f'{n}-sided Polygon - Displacement') ax1.set_xlabel('x') ax1.set_ylabel('y') ax1.set_aspect('equal') # Intensity plot ax2 = axes[1, i] im2 = ax2.contourf(sim.X, sim.Y, intensity, 50, cmap='viridis') plt.colorbar(im2, ax=ax2, label='Intensity') for sx, sy in sim.source_positions: ax2.plot(sx, sy, 'ro', markersize=6) ax2.plot(x_src + (x_src[0],), y_src + (y_src[0],), 'k--', alpha=0.5) ax2.set_title(f'{n}-sided Polygon - Intensity') ax2.set_xlabel('x') ax2.set_ylabel('y') ax2.set_aspect('equal') plt.tight_layout() return fig # Example usage if __name__ == \"__main__\": sim = WaveInterferenceSimulation( polygon_sides=3, # Triangle radius=1.0, amplitude=1.0, wavelength=0.5, frequency=1.0 ) # 1) Plot a snapshot at t = 0 and save the figure sim.plot_snapshot(t=0) plt.savefig('triangle_wave_snapshot.png', dpi=150) # 2) Plot the time-averaged intensity map and save the figure sim.plot_intensity_map() plt.savefig('triangle_intensity_map.png', dpi=150) # 3) Compare different polygons (3, 4, 5, 6) and save the figure fig = sim.analyze_different_polygons([3, 4, 5, 6]) plt.savefig('polygon_comparison.png', dpi=150) # 4) Create an animation of the wave field (3 seconds at 15 fps) anim = sim.create_animation(duration=3.0, fps=15) # To save the animation as a GIF, uncomment the following line: # anim.save('wave_animation.gif', writer='pillow', fps=15) plt.show()","title":"Python Code Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#output-images-and-explanations","text":"","title":"Output Images and Explanations"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-wave-snapshot","text":"Explanation: The snapshot shows the instantaneous displacement of the wave field at \\(t = 0\\) for a triangular configuration. The contour plot clearly illustrates areas where wave amplitudes reinforce (constructive interference) and cancel (destructive interference). The red markers denote the positions of the sources, and the dashed line outlines the triangular boundary.","title":"1. Wave Snapshot"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-intensity-map","text":"Explanation: The intensity map displays the time-averaged energy distribution of the wave field. Bright regions indicate consistent high amplitude (constructive interference), while darker areas reveal destructive interference. The map includes the marked source positions and the connecting polygon, providing a clear visual of the interference pattern\u2019s overall structure.","title":"2. Intensity Map"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-polygon-comparison","text":"Explanation: This comparison presents displacement maps (top row) and intensity maps (bottom row) for polygons with 3, 4, 5, and 6 sides. The plots reveal that as the number of sides increases, the interference pattern becomes more intricate and symmetric, demonstrating the impact of source geometry on wave superposition.","title":"3. Polygon Comparison"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-wave-animation","text":"Explanation: The animation shows the dynamic evolution of the interference pattern over time. The moving crests and troughs indicate phase variations, yet the overall symmetry dictated by the polygon is maintained throughout the animation. This dynamic visualization offers insight into how the interference pattern shifts while the basic structure remains constant.","title":"4. Wave Animation"},{"location":"1%20Physics/3%20Waves/Problem_1/#summary","text":"Wave Snapshot: Captures the instantaneous wave displacement, highlighting constructive and destructive interference in a triangular configuration. Intensity Map: Illustrates the time-averaged energy distribution, revealing stable regions of interference. Polygon Comparison: Demonstrates how increasing the number of sources (i.e., using different regular polygons) affects the complexity and symmetry of the interference patterns. Wave Animation: Provides a dynamic view of the wave evolution, emphasizing the temporal changes in the interference pattern while preserving the geometric symmetry. This solution, including theoretical background, full Python code, output images with explanations, and a summary, meets all the problem requirements.","title":"Summary"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}