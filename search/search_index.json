{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Below is a comprehensive Markdown document that outlines the derivation, analysis, and simulation of projectile motion with a focus on how the horizontal range depends on the launch angle. The document includes theoretical derivations, discussion of parameter effects and limitations, as well as a Python simulation to visualize the range versus the angle of projection. Investigating the Range as a Function of the Angle of Projection 1. Introduction Projectile motion is a classic problem in mechanics that offers deep insights into the interplay between linear and quadratic relationships. By varying parameters such as the initial velocity, gravitational acceleration, and launch height, one can obtain a rich family of solutions that model real-world phenomena ranging from sports to aerospace engineering. In this document, we: Derive the governing equations of motion. Analyze the dependence of the horizontal range on the angle of projection. Discuss the influence of initial velocity and gravitational acceleration. Explore practical applications and limitations of the idealized model. Implement a simulation in Python to visualize these relationships. 2. Theoretical Foundation Derivation of Equations of Motion Assume a projectile is launched with an initial speed \\(v_0\\) at an angle \\(\\theta\\) relative to the horizontal. Under the assumption of uniform gravitational acceleration \\(g\\) and no air resistance, the equations of motion are: \\[ x(t) = v_0 \\cos(\\theta) \\, t, \\] \\[ y(t) = v_0 \\sin(\\theta) \\, t - \\frac{1}{2} g t^2. \\] Time of Flight and Range For a projectile launched from and landing at the same vertical level ( \\(y = 0\\) ), setting \\(y(T) = 0\\) gives: \\[ 0 = v_0 \\sin(\\theta) \\, T - \\frac{1}{2} g T^2. \\] This yields two solutions: \\(T = 0\\) (the launch moment), and \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g}. \\] The horizontal range \\(R\\) is the horizontal displacement at \\(T\\) : \\[ R = x(T) = v_0 \\cos(\\theta) \\, T = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g}. \\] Thus, the range as a function of the angle \\(\\theta\\) is: \\[ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g}. \\] 3. Analysis of the Range Dependence on the Angle of Projection Optimal Angle: For a given \\(v_0\\) and \\(g\\) , the maximum range is achieved when \\(\\sin(2\\theta)\\) is maximized. Since \\(\\sin(2\\theta)\\) reaches its maximum value of 1 when \\(2\\theta = 90^\\circ\\) , the optimal angle is: $$ \\theta = 45^\\circ $$ Parameter Influences: Initial Velocity \\(v_0\\) : The range scales with \\(v_0^2\\) ; increasing \\(v_0\\) results in a quadratic increase in the range. Gravitational Acceleration \\(g\\) : A higher gravitational acceleration reduces the range. On celestial bodies with lower \\(g\\) , the projectile would travel farther. Launch Height: For non-zero launch heights, the time of flight and range are modified. This case introduces additional complexity and typically requires solving a quadratic equation for \\(T\\) . 4. Practical Applications and Limitations Applications Sports: The model helps in understanding the optimal angles for throwing or hitting balls. Engineering: Used in ballistics, trajectory planning, and robotics. Astrophysics: Similar principles can be adapted to study trajectories in different gravitational fields. Limitations Air Resistance: The idealized model neglects drag, which significantly affects real-world trajectories. Wind Effects: Lateral forces are not considered. Non-uniform Gravitational Fields: For large-scale projectiles (e.g., rockets), the assumption of constant \\(g\\) is not valid. Uneven Terrain: The analysis assumes level ground; varying terrain requires more complex modeling. 5. Implementation: Python Simulation Below is a Python script that simulates projectile motion and visualizes the horizontal range as a function of the projection angle for different initial conditions. import numpy as np import matplotlib.pyplot as plt # Constants and parameters g = 9.81 # gravitational acceleration (m/s^2) v0 = 20.0 # initial velocity (m/s) # Angle range from 0 to 90 degrees in radians angles_deg = np.linspace(0, 90, 180) angles_rad = np.deg2rad(angles_deg) # Calculate range for each angle using R = (v0^2 * sin(2\u03b8)) / g ranges = (v0**2 * np.sin(2 * angles_rad)) / g # Plot the Range vs. Angle of Projection plt.figure(figsize=(10, 6)) plt.plot(angles_deg, ranges, label=f'v0 = {v0} m/s', color='blue') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Horizontal Range (m)') plt.title('Projectile Range as a Function of the Angle of Projection') plt.legend() plt.grid(True) plt.show() Simulation Output from Python code Here is the static image generated from google colab by using python code: Explanation of the Code Parameter Setup: We define the gravitational acceleration \\(g\\) and the initial velocity \\(v_0\\) . Angle Range: Angles are sampled from 0\u00b0 to 90\u00b0 and converted to radians. Range Calculation: The range for each angle is computed using the derived formula. Visualization: A plot is generated to show the dependence of the range on the angle of projection. 6. Conclusion This investigation has provided: A derivation of the fundamental equations of projectile motion. A clear relationship showing that the range is maximized at a 45\u00b0 angle for level ground. An analysis of how initial velocity and gravitational acceleration influence the trajectory. A Python-based simulation that visualizes these relationships. While the idealized model offers significant insights, real-world applications require accounting for additional factors like air resistance, wind, and variable terrain. Future extensions might include these effects to provide a more comprehensive understanding of projectile motion in practical scenarios.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-introduction","text":"Projectile motion is a classic problem in mechanics that offers deep insights into the interplay between linear and quadratic relationships. By varying parameters such as the initial velocity, gravitational acceleration, and launch height, one can obtain a rich family of solutions that model real-world phenomena ranging from sports to aerospace engineering. In this document, we: Derive the governing equations of motion. Analyze the dependence of the horizontal range on the angle of projection. Discuss the influence of initial velocity and gravitational acceleration. Explore practical applications and limitations of the idealized model. Implement a simulation in Python to visualize these relationships.","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-theoretical-foundation","text":"","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-equations-of-motion","text":"Assume a projectile is launched with an initial speed \\(v_0\\) at an angle \\(\\theta\\) relative to the horizontal. Under the assumption of uniform gravitational acceleration \\(g\\) and no air resistance, the equations of motion are: \\[ x(t) = v_0 \\cos(\\theta) \\, t, \\] \\[ y(t) = v_0 \\sin(\\theta) \\, t - \\frac{1}{2} g t^2. \\]","title":"Derivation of Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight-and-range","text":"For a projectile launched from and landing at the same vertical level ( \\(y = 0\\) ), setting \\(y(T) = 0\\) gives: \\[ 0 = v_0 \\sin(\\theta) \\, T - \\frac{1}{2} g T^2. \\] This yields two solutions: \\(T = 0\\) (the launch moment), and \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g}. \\] The horizontal range \\(R\\) is the horizontal displacement at \\(T\\) : \\[ R = x(T) = v_0 \\cos(\\theta) \\, T = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g}. \\] Thus, the range as a function of the angle \\(\\theta\\) is: \\[ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g}. \\]","title":"Time of Flight and Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-analysis-of-the-range","text":"","title":"3. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#dependence-on-the-angle-of-projection","text":"Optimal Angle: For a given \\(v_0\\) and \\(g\\) , the maximum range is achieved when \\(\\sin(2\\theta)\\) is maximized. Since \\(\\sin(2\\theta)\\) reaches its maximum value of 1 when \\(2\\theta = 90^\\circ\\) , the optimal angle is: $$ \\theta = 45^\\circ $$ Parameter Influences: Initial Velocity \\(v_0\\) : The range scales with \\(v_0^2\\) ; increasing \\(v_0\\) results in a quadratic increase in the range. Gravitational Acceleration \\(g\\) : A higher gravitational acceleration reduces the range. On celestial bodies with lower \\(g\\) , the projectile would travel farther. Launch Height: For non-zero launch heights, the time of flight and range are modified. This case introduces additional complexity and typically requires solving a quadratic equation for \\(T\\) .","title":"Dependence on the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-practical-applications-and-limitations","text":"","title":"4. Practical Applications and Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#applications","text":"Sports: The model helps in understanding the optimal angles for throwing or hitting balls. Engineering: Used in ballistics, trajectory planning, and robotics. Astrophysics: Similar principles can be adapted to study trajectories in different gravitational fields.","title":"Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations","text":"Air Resistance: The idealized model neglects drag, which significantly affects real-world trajectories. Wind Effects: Lateral forces are not considered. Non-uniform Gravitational Fields: For large-scale projectiles (e.g., rockets), the assumption of constant \\(g\\) is not valid. Uneven Terrain: The analysis assumes level ground; varying terrain requires more complex modeling.","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-implementation-python-simulation","text":"Below is a Python script that simulates projectile motion and visualizes the horizontal range as a function of the projection angle for different initial conditions. import numpy as np import matplotlib.pyplot as plt # Constants and parameters g = 9.81 # gravitational acceleration (m/s^2) v0 = 20.0 # initial velocity (m/s) # Angle range from 0 to 90 degrees in radians angles_deg = np.linspace(0, 90, 180) angles_rad = np.deg2rad(angles_deg) # Calculate range for each angle using R = (v0^2 * sin(2\u03b8)) / g ranges = (v0**2 * np.sin(2 * angles_rad)) / g # Plot the Range vs. Angle of Projection plt.figure(figsize=(10, 6)) plt.plot(angles_deg, ranges, label=f'v0 = {v0} m/s', color='blue') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Horizontal Range (m)') plt.title('Projectile Range as a Function of the Angle of Projection') plt.legend() plt.grid(True) plt.show()","title":"5. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulation-output-from-python-code","text":"Here is the static image generated from google colab by using python code:","title":"Simulation Output from Python code"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-code","text":"Parameter Setup: We define the gravitational acceleration \\(g\\) and the initial velocity \\(v_0\\) . Angle Range: Angles are sampled from 0\u00b0 to 90\u00b0 and converted to radians. Range Calculation: The range for each angle is computed using the derived formula. Visualization: A plot is generated to show the dependence of the range on the angle of projection.","title":"Explanation of the Code"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-conclusion","text":"This investigation has provided: A derivation of the fundamental equations of projectile motion. A clear relationship showing that the range is maximized at a 45\u00b0 angle for level ground. An analysis of how initial velocity and gravitational acceleration influence the trajectory. A Python-based simulation that visualizes these relationships. While the idealized model offers significant insights, real-world applications require accounting for additional factors like air resistance, wind, and variable terrain. Future extensions might include these effects to provide a more comprehensive understanding of projectile motion in practical scenarios.","title":"6. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum 1. Introduction The forced damped pendulum is a classic nonlinear system that exhibits a rich variety of behaviors\u2014from simple periodic oscillations to complex chaotic motion\u2014due to the interplay between damping, restoring forces, and an external periodic drive. By varying parameters such as the damping coefficient, driving amplitude, and driving frequency, one can obtain a diverse set of solutions that model real-world phenomena ranging from energy harvesting to structural vibrations. In this document, we: Derive the governing differential equation for the forced damped pendulum. Analyze the influence of damping, driving amplitude, and driving frequency on the system\u2019s dynamics. Discuss practical applications and limitations of the forced damped pendulum model. Implement a simulation in Python to visualize the pendulum\u2019s behavior. 2. Theoretical Foundation Differential Equation The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\ddot{\\theta} + 2\\beta\\, \\dot{\\theta} + \\omega_0^2 \\sin\\theta = \\frac{F_D}{mL} \\cos(\\Omega t), \\] where: \\((\\theta)\\) is the angular displacement, \\((\\beta)\\) is the damping coefficient, \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural frequency of the pendulum (with $ L $ being the pendulum length), \\(F_D\\) is the amplitude of the driving force, \\(( m )\\) is the mass of the pendulum bob, \\(( L )\\) is the length of the pendulum, \\(( \\Omega )\\) is the driving frequency. Small-Angle Approximation For small oscillations, we use the approximation: \\[ \\sin\\theta \\approx \\theta, \\] which linearizes the equation to: \\[ \\ddot{\\theta} + 2\\beta\\, \\dot{\\theta} + \\omega_0^2 \\theta = \\frac{F_D}{mL} \\cos(\\Omega t). \\] The general solution is the sum of the homogeneous solution (which decays due to damping) and a particular solution that oscillates at the driving frequency. Resonance Conditions Resonance: The system experiences resonance when the driving frequency \\(\\Omega\\) is close to the natural frequency \\(\\omega_0\\) . At resonance, the amplitude of the steady-state oscillations becomes large, limited by the damping. Energy Implications: Under resonance, the system efficiently absorbs energy from the external force, resulting in significant oscillation amplitudes. 3. Analysis of Dynamics Parameter Influences Damping Coefficient ( \\(\\beta\\) ): Higher damping reduces the amplitude of oscillations and can suppress chaotic behavior, while lower damping allows for larger amplitudes and may lead to complex dynamics. Driving Amplitude ( \\(F_D/(mL)\\) ): Increasing the driving amplitude increases the steady-state oscillation amplitude. Very high driving amplitudes can push the system into a nonlinear regime, potentially resulting in chaotic motion. Driving Frequency ( \\(\\Omega\\) ): When \\(\\Omega\\) is near \\(\\omega_0\\) , the system experiences resonance. As \\(\\Omega\\) varies, the system may transition between regular (periodic) motion and chaotic behavior. Transition to Chaos Regular Motion: For moderate values of damping and driving amplitude, the pendulum displays periodic oscillations. Chaotic Motion: Under low damping or high driving amplitude, the system becomes highly sensitive to initial conditions, leading to chaotic behavior. Visualization Tools: Phase portraits and Poincar\u00e9 sections are used to reveal the underlying structure of the motion and the transition to chaos. 4. Practical Applications and Limitations Applications Energy Harvesting: Systems can be designed to exploit resonance, thereby maximizing energy absorption from periodic forces. Structural Engineering: Understanding forced oscillations is crucial in designing structures (e.g., suspension bridges, vibration isolation systems) that must withstand periodic loads. Oscillating Circuits: The behavior of driven RLC circuits is analogous to the forced damped pendulum, informing the design of filters and resonant circuits. Limitations The small-angle approximation simplifies the analysis but is only valid for small displacements. The model neglects effects such as nonlinear damping and non-periodic driving forces, which may be significant in real-world systems. For larger oscillations, the full nonlinear equation (with \\(\\sin\\theta\\) ) should be used. 5. Implementation: Python Simulation 5.1. First Simulation In this first simulation, we produce three key plots to analyze the forced damped pendulum\u2019s motion: A time series plot of \\(\\theta(t)\\) A phase portrait ( \\(\\theta\\) vs. \\(\\dot{\\theta}\\) ) A Poincar\u00e9 section to capture periodic and chaotic dynamics Below is the Python code for our initial simulation under the small-angle approximation. It uses solve_ivp to integrate the system, then plots the results. For now, we run one set of parameters ( \\(\\beta=0.25\\) , \\(F_D=1.2\\) , \\(\\Omega=2/3\\) , etc.): import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def run_forced_damped_pendulum(beta=0.25, F_D=1.2, Omega=2/3, t_span=(0, 100), y0=(0.1, 0.0), use_small_angle=True): \"\"\" Simulates and plots the forced damped pendulum. Parameters: ----------- beta : float Damping coefficient. F_D : float Driving force amplitude (N). Omega : float Driving frequency (rad/s). t_span : tuple Start and end time for the simulation, e.g. (0, 100). y0 : Initial conditions (theta, omega). use_small_angle : bool If True, use the small-angle approximation (sin(theta) ~ theta). If False, use the full nonlinear equation sin(theta). \"\"\" g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # pendulum length (m) m = 1.0 # mass (kg) # Natural frequency omega0 = np.sqrt(g / L) # Driving force term driving_force = F_D / (m * L) # Define the ODE def forced_damped_pendulum(t, y): theta, omega = y # Corrected: Added theta dtheta_dt = omega if use_small_angle: # Small-angle approximation: sin(theta) ~ theta restoring = -omega0**2 * theta else: # Full nonlinear: sin(theta) restoring = -omega0**2 * np.sin(theta) domega_dt = -2 * beta * omega + restoring + driving_force * np.cos(Omega * t) return [dtheta_dt, domega_dt] # Create a time array for evaluation t_eval = np.linspace(t_span[0], t_span[1], 10000) # Solve the ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, rtol=1e-8) # Corrected: Changed t to t_eval t = sol.t theta = sol.y[0] # Corrected: Added theta omega = sol.y[1] # --- PLOTS --- # 1) Time of Theta(t) plt.figure(figsize=(10, 4)) plt.plot(t, theta, 'b-', label=r'$\\theta(t)$') # Corrected: Changed plt to plt.plot plt.xlabel('Time (s)') # Corrected: Indentation plt.ylabel('Angle (rad)') plt.title(f'Time Series (beta={beta}, F_D={F_D}, Omega={Omega})') plt.legend() plt.grid(True) plt.tight_layout() plt.show() # 2) Phase Portrait (theta vs. omega) plt.figure(figsize=(6, 6)) plt.plot(theta, omega, 'r-', lw=0.8) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Phase Portrait (beta={beta}, F_D={F_D}, Omega={Omega})') plt.grid(True) plt.tight_layout() plt.show() # 3) Poincar\u00e9 Section # Sample points at every period T_drive = 2*pi/Omega after a transient T_drive = 2 * np.pi / Omega # Skip initial transients (e.g., first 50 cycles) skip_cycles = 50 # Corrected: Added = poincare_times = np.arange(skip_cycles * T_drive, t_span[1], T_drive) poincare_thetas = np.interp(poincare_times, t, theta) poincare_omegas = np.interp(poincare_times, t, omega) plt.figure(figsize=(6, 6)) plt.scatter(poincare_thetas, poincare_omegas, c='green', s=25) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Poincar\u00e9 Section (beta={beta}, F_D={F_D}, Omega={Omega})') plt.grid(True) plt.tight_layout() plt.show() # Main function to run multiple simulations def main(): # Define parameter ranges damping_coefficients = [0.1, 0.25, 0.5] # Different damping coefficients driving_forces = [0.5, 1.0, 1.5] # Different driving forces driving_frequencies = [1/2, 1, 2] # Different driving frequencies # Run simulations for different combinations of parameters for beta in damping_coefficients: for F_D in driving_forces: for Omega in driving_frequencies: run_forced_damped_pendulum(beta=beta, F_D=F_D, Omega=Omega, t_span=(0, 100), y0=(0.1, 0.0), use_small_angle=True) if __name__ == \"__main__\": main() Outputs for the First Simulation Running this script with \\((\\beta=0.25)\\) , \\((F_D=1.2)\\) , \\((\\Omega=2/3)\\) , and use_small_angle = True produces three plots : Time Series: Phase portrait Time Series (beta=01, F_D=0.5, Omega=1) Phase Portait( beta=0.1 F_D=0.5, Omega=1 ) Time series (beta=0.1 F_D=0.5, Omega=2 Time series (beta=0.1 F_D=1.0, Omega=0.5 Phase Portrait (beta=01, F_D=1.0, Omega=0.2) Phase Portait( beta=0.1 F_D=1.0, Omega=1 Time Series (beta=0.1, F_D=1.0, Omega=1) Portrait (Beta=0.1, Fr_D=1.0, Omega=2) Explanation Time Series: Shows how \\(\\theta(t)\\) evolves over time. A nearly sinusoidal plot indicates that the pendulum exhibits stable periodic motion. Phase Portrait: Plots \\(\\theta\\) versus \\(\\dot{\\theta}\\) . A closed loop in \\(\\theta\\) \u2013 \\(\\dot{\\theta}\\) space indicates a stable periodic orbit. Poincar\u00e9 Section: Samples the phase space at intervals of the driving period. A small set of discrete points indicates that the system is in regular, periodic motion rather than chaotic behavior. Small-Angle Approximation: Since use_small_angle = True , we use \\(\\sin(\\theta) \\approx \\theta\\) . This typically yields simpler, near-harmonic motion for moderate parameter values. Stable Periodic Orbit: Under \\((\\beta = 0.25)\\) , \\((F_D = 1.2)\\) , and \\((\\Omega = \\tfrac{2}{3})\\) , the pendulum exhibits a stable periodic solution\u2014evident from the sinusoidal time series, single-loop phase portrait, and a small set of points in the Poincar\u00e9 section. Potential Extensions: Set use_small_angle = False to use the full nonlinear equation \\(\\sin(\\theta)\\) , which can yield chaotic solutions for certain parameter ranges. Vary \\(\\beta\\) (damping), \\(F_D\\) (driving amplitude), and \\(\\Omega\\) (driving frequency) to see more complex dynamics, including chaos. 5.2. Second Simulation (Exploring More Complex Dynamics) To explore more complex or chaotic behavior, we can turn off the small\u2010angle approximation and adjust parameters such as damping and driving amplitude. In the following example, we lower the damping and increase the driving force: Damping coefficient: \\(\\beta = 0.2\\) Driving amplitude: \\(F_D = 1.5\\) Driving frequency: \\(\\Omega = \\tfrac{2}{3}\\) Full nonlinear equation (i.e., \\(\\sin(\\theta)\\) instead of \\(\\theta\\) ) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def run_forced_damped_pendulum(beta=0.2, F_D=1.5, Omega=2/3, t_span=(0, 200), y0=(0.2, 0.0), use_small_angle=False): \"\"\" Simulates and plots the forced damped pendulum with more extreme parameters, potentially leading to chaotic motion. \"\"\" g = 9.81 L = 1.0 m = 1.0 omega0 = np.sqrt(g / L) driving_force = F_D / (m * L) def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega if use_small_angle: restoring = -omega0**2 * theta else: restoring = -omega0**2 * np.sin(theta) domega_dt = -2 * beta * omega + restoring + driving_force * np.cos(Omega * t) return [dtheta_dt, domega_dt] t_eval = np.linspace(t_span[0], t_span[1], 20000) sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, rtol=1e-8) t = sol.t theta = sol.y[0] omega = sol.y[1] # Time Series plt.figure(figsize=(10, 4)) plt.plot(t, theta, 'b-', label=r'$\\theta(t)$') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title(f'Time Series (beta={beta}, F_D={F_D}, Omega={Omega}, Nonlinear)') plt.legend() plt.grid(True) plt.tight_layout() plt.show() # Phase Portrait plt.figure(figsize=(6, 6)) plt.plot(theta, omega, 'r-', lw=0.8) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Phase Portrait (beta={beta}, F_D={F_D}, Omega={Omega}, Nonlinear)') plt.grid(True) plt.tight_layout() plt.show() # Poincar\u00e9 Section T_drive = 2 * np.pi / Omega skip_cycles = 50 poincare_times = np.arange(skip_cycles * T_drive, t_span[1], T_drive) poincare_thetas = np.interp(poincare_times, t, theta) poincare_omegas = np.interp(poincare_times, t, omega) plt.figure(figsize=(6, 6)) plt.scatter(poincare_thetas, poincare_omegas, c='green', s=25) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Poincar\u00e9 Section (beta={beta}, F_D={F_D}, Omega={Omega}, Nonlinear)') plt.grid(True) plt.tight_layout() plt.show() if __name__ == \"__main__\": run_forced_damped_pendulum() Outputs for the Second Simulation Running this script with \\((\\beta=0.2\\) ), \\((F_D=1.5)\\) , \\(\\Omega=\\tfrac{2}{3}\\) , and use_small_angle = False often yields more complex or chaotic motion. You might see: Time Series: The waveform can become irregular, indicating non-periodic or chaotic behavior. Phase Portrait Instead of a single closed loop, the trajectory in \\(\\theta\\) \u2013 \\(\\dot{\\theta}\\) space may fill an area or form a strange attractor, characteristic of chaos. Poincar\u00e9 Section A scattered \u201ccloud\u201d of points, rather than a finite set, implies chaotic dynamics. Explanation Nonlinear Equation : We set use_small_angle = False so that \\(\\sin(\\theta)\\) is used instead of \\(\\theta\\) . This allows for larger amplitude oscillations and the possibility of chaos. Lower Damping, Higher Drive : \\(\\beta=0.2\\) is smaller than the previous 0.25, so the system loses energy more slowly. \\(F_D=1.5\\) is greater than 1.2, delivering more external energy per cycle. Together, these changes push the pendulum into a regime where chaotic behavior is more likely. Longer Time Span : We increased t_span to (0, 200) to observe the long-term evolution. Chaos sometimes takes a while to emerge or settle into an attractor. Potential Observations : If the motion is chaotic, the phase portrait and Poincar\u00e9 section won\u2019t settle into a simple loop or small set of points. You may see a scattered or more \u201cfilled-in\u201d region in phase space. With this second simulation, I demonstrate how changing parameters (especially lowering damping and increasing driving amplitude) can lead from stable periodic motion to more complex or chaotic behavior in the forced damped pendulum. 6. Discussion General Solutions: With the small-angle approximation and moderate parameters, the pendulum typically remains in a regular periodic orbit . However, for certain parameter sets (e.g., lower damping, higher driving amplitude, or using the full \\(\\sin(\\theta)\\) ), it can transition to chaotic motion . Graphical Representations: Time Series: Depicts how \\(\\theta\\) changes over time. Phase Portrait: Shows \\(\\theta\\) vs. \\(\\dot{\\theta}\\) , revealing periodic loops or chaotic attractors. Poincar\u00e9 Section: Captures the system\u2019s state once every driving period, distinguishing periodic from chaotic dynamics. Limitations & Future Work: The small-angle approximation may fail for larger amplitudes. Nonlinear damping or non-periodic driving forces can further complicate real-world behavior. Comparison of the Two Simulations Equations and Approximations: First Simulation uses the small-angle approximation \\(\\sin(\\theta)\\approx \\theta\\) . This linearizes the pendulum\u2019s restoring force, typically yielding stable, near-harmonic motion for moderate parameters. Second Simulation employs the full nonlinear equation \\(\\sin(\\theta)\\) . This allows for larger amplitude oscillations and the possibility of chaotic regimes under more extreme parameters. Parameter Choices: First Simulation : \\(\\beta=0.25,\\; F_D=1.2,\\; \\Omega=\\tfrac{2}{3},\\; \\text{use\\_small\\_angle = True}\\) . These moderate values produce a stable periodic orbit. Second Simulation : \\(\\beta=0.2,\\; F_D=1.5,\\; \\Omega=\\tfrac{2}{3},\\; \\text{use\\_small\\_angle=False}\\) . Lower damping and higher driving force are designed to push the system into more complex or chaotic motion. Observations in the Plots: Time Series : First Simulation : A smooth, sinusoidal-like wave indicating periodic motion. Second Simulation : Potentially more irregular or broader swings if chaos emerges. Phase Portrait \\((\\theta\\) vs. \\(\\dot{\\theta}\\) ): First Simulation : A single closed loop consistent with a periodic orbit. Second Simulation : May fill an area or produce more complicated loops, indicative of chaos or quasiperiodicity (depending on parameters). Poincar\u00e9 Section : First Simulation : A small set of discrete points reflects the regular (periodic) solution. Second Simulation : If truly chaotic, you\u2019d see a scattered cloud of points. However, it may still appear periodic if the parameters don\u2019t sufficiently drive chaos. Key Takeaways: The first (small-angle) simulation demonstrates how a forced damped pendulum can settle into a stable periodic orbit with moderate damping and driving. The second (full nonlinear) simulation attempts to highlight more extreme dynamics by reducing damping and increasing the driving force, thereby increasing the likelihood of chaos . If you still observe a periodic solution in the second simulation, you can further adjust parameters (e.g., reduce \\(\\beta\\) or raise \\(F_D\\) ) or extend the simulation time to reveal chaotic behavior. 7. Conclusion This investigation of the forced damped pendulum has: Derived the governing equations and provided an approximate solution for small oscillations. Analyzed how damping, driving amplitude, and driving frequency affect the system\u2019s dynamics. Illustrated the transition from periodic to chaotic behavior using time series , phase portraits , and Poincar\u00e9 sections . Demonstrated a computational simulation in Python that visualizes these dynamics. Overall, this study reinforces key concepts in nonlinear dynamics and provides a foundation for further exploration, including adjusting parameters to observe chaotic regimes or incorporating more realistic effects such as nonlinear damping.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-introduction","text":"The forced damped pendulum is a classic nonlinear system that exhibits a rich variety of behaviors\u2014from simple periodic oscillations to complex chaotic motion\u2014due to the interplay between damping, restoring forces, and an external periodic drive. By varying parameters such as the damping coefficient, driving amplitude, and driving frequency, one can obtain a diverse set of solutions that model real-world phenomena ranging from energy harvesting to structural vibrations. In this document, we: Derive the governing differential equation for the forced damped pendulum. Analyze the influence of damping, driving amplitude, and driving frequency on the system\u2019s dynamics. Discuss practical applications and limitations of the forced damped pendulum model. Implement a simulation in Python to visualize the pendulum\u2019s behavior.","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-theoretical-foundation","text":"","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation","text":"The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\ddot{\\theta} + 2\\beta\\, \\dot{\\theta} + \\omega_0^2 \\sin\\theta = \\frac{F_D}{mL} \\cos(\\Omega t), \\] where: \\((\\theta)\\) is the angular displacement, \\((\\beta)\\) is the damping coefficient, \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural frequency of the pendulum (with $ L $ being the pendulum length), \\(F_D\\) is the amplitude of the driving force, \\(( m )\\) is the mass of the pendulum bob, \\(( L )\\) is the length of the pendulum, \\(( \\Omega )\\) is the driving frequency.","title":"Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations, we use the approximation: \\[ \\sin\\theta \\approx \\theta, \\] which linearizes the equation to: \\[ \\ddot{\\theta} + 2\\beta\\, \\dot{\\theta} + \\omega_0^2 \\theta = \\frac{F_D}{mL} \\cos(\\Omega t). \\] The general solution is the sum of the homogeneous solution (which decays due to damping) and a particular solution that oscillates at the driving frequency.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance: The system experiences resonance when the driving frequency \\(\\Omega\\) is close to the natural frequency \\(\\omega_0\\) . At resonance, the amplitude of the steady-state oscillations becomes large, limited by the damping. Energy Implications: Under resonance, the system efficiently absorbs energy from the external force, resulting in significant oscillation amplitudes.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-analysis-of-dynamics","text":"","title":"3. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-influences","text":"Damping Coefficient ( \\(\\beta\\) ): Higher damping reduces the amplitude of oscillations and can suppress chaotic behavior, while lower damping allows for larger amplitudes and may lead to complex dynamics. Driving Amplitude ( \\(F_D/(mL)\\) ): Increasing the driving amplitude increases the steady-state oscillation amplitude. Very high driving amplitudes can push the system into a nonlinear regime, potentially resulting in chaotic motion. Driving Frequency ( \\(\\Omega\\) ): When \\(\\Omega\\) is near \\(\\omega_0\\) , the system experiences resonance. As \\(\\Omega\\) varies, the system may transition between regular (periodic) motion and chaotic behavior.","title":"Parameter Influences"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"Regular Motion: For moderate values of damping and driving amplitude, the pendulum displays periodic oscillations. Chaotic Motion: Under low damping or high driving amplitude, the system becomes highly sensitive to initial conditions, leading to chaotic behavior. Visualization Tools: Phase portraits and Poincar\u00e9 sections are used to reveal the underlying structure of the motion and the transition to chaos.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-practical-applications-and-limitations","text":"","title":"4. Practical Applications and Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#applications","text":"Energy Harvesting: Systems can be designed to exploit resonance, thereby maximizing energy absorption from periodic forces. Structural Engineering: Understanding forced oscillations is crucial in designing structures (e.g., suspension bridges, vibration isolation systems) that must withstand periodic loads. Oscillating Circuits: The behavior of driven RLC circuits is analogous to the forced damped pendulum, informing the design of filters and resonant circuits.","title":"Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations","text":"The small-angle approximation simplifies the analysis but is only valid for small displacements. The model neglects effects such as nonlinear damping and non-periodic driving forces, which may be significant in real-world systems. For larger oscillations, the full nonlinear equation (with \\(\\sin\\theta\\) ) should be used.","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-implementation-python-simulation","text":"","title":"5. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#51-first-simulation","text":"In this first simulation, we produce three key plots to analyze the forced damped pendulum\u2019s motion: A time series plot of \\(\\theta(t)\\) A phase portrait ( \\(\\theta\\) vs. \\(\\dot{\\theta}\\) ) A Poincar\u00e9 section to capture periodic and chaotic dynamics Below is the Python code for our initial simulation under the small-angle approximation. It uses solve_ivp to integrate the system, then plots the results. For now, we run one set of parameters ( \\(\\beta=0.25\\) , \\(F_D=1.2\\) , \\(\\Omega=2/3\\) , etc.): import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def run_forced_damped_pendulum(beta=0.25, F_D=1.2, Omega=2/3, t_span=(0, 100), y0=(0.1, 0.0), use_small_angle=True): \"\"\" Simulates and plots the forced damped pendulum. Parameters: ----------- beta : float Damping coefficient. F_D : float Driving force amplitude (N). Omega : float Driving frequency (rad/s). t_span : tuple Start and end time for the simulation, e.g. (0, 100). y0 : Initial conditions (theta, omega). use_small_angle : bool If True, use the small-angle approximation (sin(theta) ~ theta). If False, use the full nonlinear equation sin(theta). \"\"\" g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # pendulum length (m) m = 1.0 # mass (kg) # Natural frequency omega0 = np.sqrt(g / L) # Driving force term driving_force = F_D / (m * L) # Define the ODE def forced_damped_pendulum(t, y): theta, omega = y # Corrected: Added theta dtheta_dt = omega if use_small_angle: # Small-angle approximation: sin(theta) ~ theta restoring = -omega0**2 * theta else: # Full nonlinear: sin(theta) restoring = -omega0**2 * np.sin(theta) domega_dt = -2 * beta * omega + restoring + driving_force * np.cos(Omega * t) return [dtheta_dt, domega_dt] # Create a time array for evaluation t_eval = np.linspace(t_span[0], t_span[1], 10000) # Solve the ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, rtol=1e-8) # Corrected: Changed t to t_eval t = sol.t theta = sol.y[0] # Corrected: Added theta omega = sol.y[1] # --- PLOTS --- # 1) Time of Theta(t) plt.figure(figsize=(10, 4)) plt.plot(t, theta, 'b-', label=r'$\\theta(t)$') # Corrected: Changed plt to plt.plot plt.xlabel('Time (s)') # Corrected: Indentation plt.ylabel('Angle (rad)') plt.title(f'Time Series (beta={beta}, F_D={F_D}, Omega={Omega})') plt.legend() plt.grid(True) plt.tight_layout() plt.show() # 2) Phase Portrait (theta vs. omega) plt.figure(figsize=(6, 6)) plt.plot(theta, omega, 'r-', lw=0.8) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Phase Portrait (beta={beta}, F_D={F_D}, Omega={Omega})') plt.grid(True) plt.tight_layout() plt.show() # 3) Poincar\u00e9 Section # Sample points at every period T_drive = 2*pi/Omega after a transient T_drive = 2 * np.pi / Omega # Skip initial transients (e.g., first 50 cycles) skip_cycles = 50 # Corrected: Added = poincare_times = np.arange(skip_cycles * T_drive, t_span[1], T_drive) poincare_thetas = np.interp(poincare_times, t, theta) poincare_omegas = np.interp(poincare_times, t, omega) plt.figure(figsize=(6, 6)) plt.scatter(poincare_thetas, poincare_omegas, c='green', s=25) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Poincar\u00e9 Section (beta={beta}, F_D={F_D}, Omega={Omega})') plt.grid(True) plt.tight_layout() plt.show() # Main function to run multiple simulations def main(): # Define parameter ranges damping_coefficients = [0.1, 0.25, 0.5] # Different damping coefficients driving_forces = [0.5, 1.0, 1.5] # Different driving forces driving_frequencies = [1/2, 1, 2] # Different driving frequencies # Run simulations for different combinations of parameters for beta in damping_coefficients: for F_D in driving_forces: for Omega in driving_frequencies: run_forced_damped_pendulum(beta=beta, F_D=F_D, Omega=Omega, t_span=(0, 100), y0=(0.1, 0.0), use_small_angle=True) if __name__ == \"__main__\": main()","title":"5.1. First Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#outputs-for-the-first-simulation","text":"Running this script with \\((\\beta=0.25)\\) , \\((F_D=1.2)\\) , \\((\\Omega=2/3)\\) , and use_small_angle = True produces three plots : Time Series: Phase portrait Time Series (beta=01, F_D=0.5, Omega=1) Phase Portait( beta=0.1 F_D=0.5, Omega=1 ) Time series (beta=0.1 F_D=0.5, Omega=2 Time series (beta=0.1 F_D=1.0, Omega=0.5 Phase Portrait (beta=01, F_D=1.0, Omega=0.2) Phase Portait( beta=0.1 F_D=1.0, Omega=1 Time Series (beta=0.1, F_D=1.0, Omega=1) Portrait (Beta=0.1, Fr_D=1.0, Omega=2)","title":"Outputs for the First Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation","text":"Time Series: Shows how \\(\\theta(t)\\) evolves over time. A nearly sinusoidal plot indicates that the pendulum exhibits stable periodic motion. Phase Portrait: Plots \\(\\theta\\) versus \\(\\dot{\\theta}\\) . A closed loop in \\(\\theta\\) \u2013 \\(\\dot{\\theta}\\) space indicates a stable periodic orbit. Poincar\u00e9 Section: Samples the phase space at intervals of the driving period. A small set of discrete points indicates that the system is in regular, periodic motion rather than chaotic behavior. Small-Angle Approximation: Since use_small_angle = True , we use \\(\\sin(\\theta) \\approx \\theta\\) . This typically yields simpler, near-harmonic motion for moderate parameter values. Stable Periodic Orbit: Under \\((\\beta = 0.25)\\) , \\((F_D = 1.2)\\) , and \\((\\Omega = \\tfrac{2}{3})\\) , the pendulum exhibits a stable periodic solution\u2014evident from the sinusoidal time series, single-loop phase portrait, and a small set of points in the Poincar\u00e9 section. Potential Extensions: Set use_small_angle = False to use the full nonlinear equation \\(\\sin(\\theta)\\) , which can yield chaotic solutions for certain parameter ranges. Vary \\(\\beta\\) (damping), \\(F_D\\) (driving amplitude), and \\(\\Omega\\) (driving frequency) to see more complex dynamics, including chaos.","title":"Explanation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#52-second-simulation-exploring-more-complex-dynamics","text":"To explore more complex or chaotic behavior, we can turn off the small\u2010angle approximation and adjust parameters such as damping and driving amplitude. In the following example, we lower the damping and increase the driving force: Damping coefficient: \\(\\beta = 0.2\\) Driving amplitude: \\(F_D = 1.5\\) Driving frequency: \\(\\Omega = \\tfrac{2}{3}\\) Full nonlinear equation (i.e., \\(\\sin(\\theta)\\) instead of \\(\\theta\\) ) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def run_forced_damped_pendulum(beta=0.2, F_D=1.5, Omega=2/3, t_span=(0, 200), y0=(0.2, 0.0), use_small_angle=False): \"\"\" Simulates and plots the forced damped pendulum with more extreme parameters, potentially leading to chaotic motion. \"\"\" g = 9.81 L = 1.0 m = 1.0 omega0 = np.sqrt(g / L) driving_force = F_D / (m * L) def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega if use_small_angle: restoring = -omega0**2 * theta else: restoring = -omega0**2 * np.sin(theta) domega_dt = -2 * beta * omega + restoring + driving_force * np.cos(Omega * t) return [dtheta_dt, domega_dt] t_eval = np.linspace(t_span[0], t_span[1], 20000) sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, rtol=1e-8) t = sol.t theta = sol.y[0] omega = sol.y[1] # Time Series plt.figure(figsize=(10, 4)) plt.plot(t, theta, 'b-', label=r'$\\theta(t)$') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title(f'Time Series (beta={beta}, F_D={F_D}, Omega={Omega}, Nonlinear)') plt.legend() plt.grid(True) plt.tight_layout() plt.show() # Phase Portrait plt.figure(figsize=(6, 6)) plt.plot(theta, omega, 'r-', lw=0.8) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Phase Portrait (beta={beta}, F_D={F_D}, Omega={Omega}, Nonlinear)') plt.grid(True) plt.tight_layout() plt.show() # Poincar\u00e9 Section T_drive = 2 * np.pi / Omega skip_cycles = 50 poincare_times = np.arange(skip_cycles * T_drive, t_span[1], T_drive) poincare_thetas = np.interp(poincare_times, t, theta) poincare_omegas = np.interp(poincare_times, t, omega) plt.figure(figsize=(6, 6)) plt.scatter(poincare_thetas, poincare_omegas, c='green', s=25) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title(f'Poincar\u00e9 Section (beta={beta}, F_D={F_D}, Omega={Omega}, Nonlinear)') plt.grid(True) plt.tight_layout() plt.show() if __name__ == \"__main__\": run_forced_damped_pendulum()","title":"5.2. Second Simulation (Exploring More Complex Dynamics)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#outputs-for-the-second-simulation","text":"Running this script with \\((\\beta=0.2\\) ), \\((F_D=1.5)\\) , \\(\\Omega=\\tfrac{2}{3}\\) , and use_small_angle = False often yields more complex or chaotic motion. You might see: Time Series: The waveform can become irregular, indicating non-periodic or chaotic behavior. Phase Portrait Instead of a single closed loop, the trajectory in \\(\\theta\\) \u2013 \\(\\dot{\\theta}\\) space may fill an area or form a strange attractor, characteristic of chaos. Poincar\u00e9 Section A scattered \u201ccloud\u201d of points, rather than a finite set, implies chaotic dynamics.","title":"Outputs for the Second Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation_1","text":"Nonlinear Equation : We set use_small_angle = False so that \\(\\sin(\\theta)\\) is used instead of \\(\\theta\\) . This allows for larger amplitude oscillations and the possibility of chaos. Lower Damping, Higher Drive : \\(\\beta=0.2\\) is smaller than the previous 0.25, so the system loses energy more slowly. \\(F_D=1.5\\) is greater than 1.2, delivering more external energy per cycle. Together, these changes push the pendulum into a regime where chaotic behavior is more likely. Longer Time Span : We increased t_span to (0, 200) to observe the long-term evolution. Chaos sometimes takes a while to emerge or settle into an attractor. Potential Observations : If the motion is chaotic, the phase portrait and Poincar\u00e9 section won\u2019t settle into a simple loop or small set of points. You may see a scattered or more \u201cfilled-in\u201d region in phase space. With this second simulation, I demonstrate how changing parameters (especially lowering damping and increasing driving amplitude) can lead from stable periodic motion to more complex or chaotic behavior in the forced damped pendulum.","title":"Explanation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-discussion","text":"General Solutions: With the small-angle approximation and moderate parameters, the pendulum typically remains in a regular periodic orbit . However, for certain parameter sets (e.g., lower damping, higher driving amplitude, or using the full \\(\\sin(\\theta)\\) ), it can transition to chaotic motion . Graphical Representations: Time Series: Depicts how \\(\\theta\\) changes over time. Phase Portrait: Shows \\(\\theta\\) vs. \\(\\dot{\\theta}\\) , revealing periodic loops or chaotic attractors. Poincar\u00e9 Section: Captures the system\u2019s state once every driving period, distinguishing periodic from chaotic dynamics. Limitations & Future Work: The small-angle approximation may fail for larger amplitudes. Nonlinear damping or non-periodic driving forces can further complicate real-world behavior.","title":"6. Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#comparison-of-the-two-simulations","text":"Equations and Approximations: First Simulation uses the small-angle approximation \\(\\sin(\\theta)\\approx \\theta\\) . This linearizes the pendulum\u2019s restoring force, typically yielding stable, near-harmonic motion for moderate parameters. Second Simulation employs the full nonlinear equation \\(\\sin(\\theta)\\) . This allows for larger amplitude oscillations and the possibility of chaotic regimes under more extreme parameters. Parameter Choices: First Simulation : \\(\\beta=0.25,\\; F_D=1.2,\\; \\Omega=\\tfrac{2}{3},\\; \\text{use\\_small\\_angle = True}\\) . These moderate values produce a stable periodic orbit. Second Simulation : \\(\\beta=0.2,\\; F_D=1.5,\\; \\Omega=\\tfrac{2}{3},\\; \\text{use\\_small\\_angle=False}\\) . Lower damping and higher driving force are designed to push the system into more complex or chaotic motion. Observations in the Plots: Time Series : First Simulation : A smooth, sinusoidal-like wave indicating periodic motion. Second Simulation : Potentially more irregular or broader swings if chaos emerges. Phase Portrait \\((\\theta\\) vs. \\(\\dot{\\theta}\\) ): First Simulation : A single closed loop consistent with a periodic orbit. Second Simulation : May fill an area or produce more complicated loops, indicative of chaos or quasiperiodicity (depending on parameters). Poincar\u00e9 Section : First Simulation : A small set of discrete points reflects the regular (periodic) solution. Second Simulation : If truly chaotic, you\u2019d see a scattered cloud of points. However, it may still appear periodic if the parameters don\u2019t sufficiently drive chaos. Key Takeaways: The first (small-angle) simulation demonstrates how a forced damped pendulum can settle into a stable periodic orbit with moderate damping and driving. The second (full nonlinear) simulation attempts to highlight more extreme dynamics by reducing damping and increasing the driving force, thereby increasing the likelihood of chaos . If you still observe a periodic solution in the second simulation, you can further adjust parameters (e.g., reduce \\(\\beta\\) or raise \\(F_D\\) ) or extend the simulation time to reveal chaotic behavior.","title":"Comparison of the Two Simulations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#7-conclusion","text":"This investigation of the forced damped pendulum has: Derived the governing equations and provided an approximate solution for small oscillations. Analyzed how damping, driving amplitude, and driving frequency affect the system\u2019s dynamics. Illustrated the transition from periodic to chaotic behavior using time series , phase portraits , and Poincar\u00e9 sections . Demonstrated a computational simulation in Python that visualizes these dynamics. Overall, this study reinforces key concepts in nonlinear dynamics and provides a foundation for further exploration, including adjusting parameters to observe chaotic regimes or incorporating more realistic effects such as nonlinear damping.","title":"7. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Derivation of Kepler's Third Law Kepler's Third Law states: [ T^2 \\propto r^3 ] Where: (T) is the orbital period, (r) is the orbital radius. Derivation: For a body in circular orbit around a central mass (M), the gravitational force provides the necessary centripetal force: [ \\frac{GMm}{r^2} = \\frac{mv^2}{r} ] Where: (G) the gravitational constant ((6.674 \\times 10^{-11} \\ \\text{m}^3/\\text{kg} \\cdot {s}^2)), (m) is the mass of the orbiting body, (v) is the orbital speed. The orbital speed can be expressed in terms of the orbital period (T): [ v = \\frac{2\\pi r}{T} ] Substituting this into the centripetal force equation gives: [ \\frac{GMm}{r^2} = \\frac{m(2\\pi r)^2}{r} ] Simplifying leads to: [ \\fracGM}{r^2} = \\frac{4\\pi^2 m}{T^2} ] Rearranging gives: [ T^2 = \\frac{4\\pi^2 r^3}{GM} ] This shows that the square of the orbital period is proportional to the cube of the orbital radius. Implications for Astronomy Calculating Planetary Masses: By observing the orbital period and radius of a satellite or planet, we can calculate the mass of the central body using the rearranged formula: [ M = \\frac{4\\pi^2 r^3}{G T^2} ] Understanding Orbital Dynamics: Kepler's Third Law helps us understand the dynamics of planetary systems, including the relationships between different planets and their distances from the Sun. Real-World Examples Moon's Orbit Around Earth: The average distance from the Earth to the Moon is about (3.84 \\times 10^8) meters, and the orbital period is approximately 27.3 days. Using Kepler's Third Law, can verify the relationship. Planets in the Solar System: The relationship holds for all planets, with the outer planets having longer periods and larger radii. Computational Model We will implement a Python script to simulate circular orbits and verify Kepler's Third Law. The script will calculate the orbital period for radii and plot the results. Python Code import numpy as np import matplotlib.pyplot as plt Constants G = 6.674 * 10 -11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989 * 10 30 # Mass of the Sun (kg) def calculate_orbital_period(radius): \"\"\" Calculate the orbital period for a given radius using Kepler's Third Law. Parameters: ----------- radius : float The orbital radius (in meters). Returns: -------- float The orbital period (in seconds). \"\"\" T_squared = (4 * np.pi**2 * radius**3) / (G * M_sun) # Added = for assignment T = np.sqrt(T_squared) # Period in seconds # Added = for assignment return T Define a range of orbital radii (in meters) radii = np.linspace(1e11, 1.5e12, 100) # From 100 million km to 1.5 billion km Calculate the corresponding orbital periods periods = np.array([calculate_orbital_period(r) for r in radii]) periods from seconds to days for better interpretation periods_days = periods / (24 * 3600) # Convert seconds to days Plotting the results plt.figure(figsize=(12, 8)) # Added comma in figsize 1. Orbital Period vs. Orbital Radius plt.subplot(2, 2, 1) plt.plot(radii / 1e9, periods_days, label='Orbital Period', color='blue') # Convert radius to billion meters plt.xlabel('Orbital Radius (billion meters)') plt.ylabel('Orbital Period (days)') plt.title('Orbital Period vs. Orbital Radius') plt.grid() plt.legend() plt.tight_layout() 2. T^2 vs. r^3 to verify Kepler's Third Law T_squared = periods 2 r_cubed = radii 3 # Corrected variable name to radii plt.subplot(2, 2, 2) plt.plot(r_cubed / 1e36, T_squared / 1e12, label='T^2 vs. r^3', color='orange') # Convert to trillion m^3 and trillion s^2 # Added plt. plt.xlabel('Orbital Radius Cubed (trillion m^3)') # Corrected spelling for Cubed plt.ylabel('Orbital Period Squared (trillion s^2)') plt.title('Verification of Kepler\\'s Third Law') plt.grid() plt.legend() plt.tight_layout() 3. Gravitational Force vs. Centripetal Force gravitational_forces = G * M_sun / radii 2 centripetal_forces = (M_sun * (2 * np.pi * radii / periods) 2) / radii plt.subplot(2, 2, 3) plt.plot(radii / 1e9, gravitational_forces, label='Gravitational Force', color='green') # Continued the line plt.plot(radii / 1e9, centripetal_forces, label='Centripetal Force', color='red') # Continued the line plt.xlabel('Orbital Radius (billion meters)') plt.ylabel('Force (N)') plt.title('Gravitational Force vs. Centripetal Force') plt.legend() plt.grid() plt.tight_layout() 4. Orbital Speed vs. Orbital Radius orbital_speeds = (2 * np.pi * radii) / periods plt.subplot(2, 2, 4) plt.plot(radii / 1e9, orbital_speeds, label='Orbital Speed', color='purple') plt.xlabel('Orbital Radius (billion meters)') plt.ylabel('Orbital Speed (m/s)') plt.title('Orbital Speed vs. Orbital Radius') plt.grid() plt.legend() plt.tight_layout() plt.show() Additional Analysis: Calculate the mass of the Sun using Kepler's Third Law def calculate_mass(radius, period): \"\"\" Calculate the mass of the central body using Kepler's Third Law. Parameters: ----------- radius : float The orbital radius (in meters). period : float The orbital period (in seconds). Returns: -------- float The mass of the central body (in kg). \"\"\" T_squared = period**2 mass = (4 * np.pi**2 * radius**3) / (G * T_squared) return mass Calculate the mass of the Sun using the average radius of Earth's orbit earth_radius = 1.496 * 10**11 # Average distance from Earth to Sun (in meters) earth_period = 365.25 * 24 * 3600 # Orbital period of Earth (in seconds) mass_sun = calculate_mass(earth_radius, earth_period) print(f\"Calculated mass of the Sun: {mass_sun:.2e} kg\")","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Derivation of Kepler's Third Law Kepler's Third Law states: [ T^2 \\propto r^3 ] Where: (T) is the orbital period, (r) is the orbital radius. Derivation: For a body in circular orbit around a central mass (M), the gravitational force provides the necessary centripetal force: [ \\frac{GMm}{r^2} = \\frac{mv^2}{r} ] Where: (G) the gravitational constant ((6.674 \\times 10^{-11} \\ \\text{m}^3/\\text{kg} \\cdot {s}^2)), (m) is the mass of the orbiting body, (v) is the orbital speed. The orbital speed can be expressed in terms of the orbital period (T): [ v = \\frac{2\\pi r}{T} ] Substituting this into the centripetal force equation gives: [ \\frac{GMm}{r^2} = \\frac{m(2\\pi r)^2}{r} ] Simplifying leads to: [ \\fracGM}{r^2} = \\frac{4\\pi^2 m}{T^2} ] Rearranging gives: [ T^2 = \\frac{4\\pi^2 r^3}{GM} ] This shows that the square of the orbital period is proportional to the cube of the orbital radius. Implications for Astronomy Calculating Planetary Masses: By observing the orbital period and radius of a satellite or planet, we can calculate the mass of the central body using the rearranged formula: [ M = \\frac{4\\pi^2 r^3}{G T^2} ] Understanding Orbital Dynamics: Kepler's Third Law helps us understand the dynamics of planetary systems, including the relationships between different planets and their distances from the Sun. Real-World Examples Moon's Orbit Around Earth: The average distance from the Earth to the Moon is about (3.84 \\times 10^8) meters, and the orbital period is approximately 27.3 days. Using Kepler's Third Law, can verify the relationship. Planets in the Solar System: The relationship holds for all planets, with the outer planets having longer periods and larger radii. Computational Model We will implement a Python script to simulate circular orbits and verify Kepler's Third Law. The script will calculate the orbital period for radii and plot the results. Python Code import numpy as np import matplotlib.pyplot as plt","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"G = 6.674 * 10 -11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989 * 10 30 # Mass of the Sun (kg) def calculate_orbital_period(radius): \"\"\" Calculate the orbital period for a given radius using Kepler's Third Law. Parameters: ----------- radius : float The orbital radius (in meters). Returns: -------- float The orbital period (in seconds). \"\"\" T_squared = (4 * np.pi**2 * radius**3) / (G * M_sun) # Added = for assignment T = np.sqrt(T_squared) # Period in seconds # Added = for assignment return T","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#define-a-range-of-orbital-radii-in-meters","text":"radii = np.linspace(1e11, 1.5e12, 100) # From 100 million km to 1.5 billion km","title":"Define a range of orbital radii (in meters)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculate-the-corresponding-orbital-periods","text":"periods = np.array([calculate_orbital_period(r) for r in radii])","title":"Calculate the corresponding orbital periods"},{"location":"1%20Physics/2%20Gravity/Problem_1/#periods-from-seconds-to-days-for-better-interpretation","text":"periods_days = periods / (24 * 3600) # Convert seconds to days","title":"periods from seconds to days for better interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plotting-the-results","text":"plt.figure(figsize=(12, 8)) # Added comma in figsize","title":"Plotting the results"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-orbital-period-vs-orbital-radius","text":"plt.subplot(2, 2, 1) plt.plot(radii / 1e9, periods_days, label='Orbital Period', color='blue') # Convert radius to billion meters plt.xlabel('Orbital Radius (billion meters)') plt.ylabel('Orbital Period (days)') plt.title('Orbital Period vs. Orbital Radius') plt.grid() plt.legend() plt.tight_layout()","title":"1. Orbital Period vs. Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-t2-vs-r3-to-verify-keplers-third-law","text":"T_squared = periods 2 r_cubed = radii 3 # Corrected variable name to radii plt.subplot(2, 2, 2) plt.plot(r_cubed / 1e36, T_squared / 1e12, label='T^2 vs. r^3', color='orange') # Convert to trillion m^3 and trillion s^2 # Added plt. plt.xlabel('Orbital Radius Cubed (trillion m^3)') # Corrected spelling for Cubed plt.ylabel('Orbital Period Squared (trillion s^2)') plt.title('Verification of Kepler\\'s Third Law') plt.grid() plt.legend() plt.tight_layout()","title":"2. T^2 vs. r^3 to verify Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-gravitational-force-vs-centripetal-force","text":"gravitational_forces = G * M_sun / radii 2 centripetal_forces = (M_sun * (2 * np.pi * radii / periods) 2) / radii plt.subplot(2, 2, 3) plt.plot(radii / 1e9, gravitational_forces, label='Gravitational Force', color='green') # Continued the line plt.plot(radii / 1e9, centripetal_forces, label='Centripetal Force', color='red') # Continued the line plt.xlabel('Orbital Radius (billion meters)') plt.ylabel('Force (N)') plt.title('Gravitational Force vs. Centripetal Force') plt.legend() plt.grid() plt.tight_layout()","title":"3. Gravitational Force vs. Centripetal Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-orbital-speed-vs-orbital-radius","text":"orbital_speeds = (2 * np.pi * radii) / periods plt.subplot(2, 2, 4) plt.plot(radii / 1e9, orbital_speeds, label='Orbital Speed', color='purple') plt.xlabel('Orbital Radius (billion meters)') plt.ylabel('Orbital Speed (m/s)') plt.title('Orbital Speed vs. Orbital Radius') plt.grid() plt.legend() plt.tight_layout() plt.show()","title":"4. Orbital Speed vs. Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#additional-analysis-calculate-the-mass-of-the-sun-using-keplers-third-law","text":"def calculate_mass(radius, period): \"\"\" Calculate the mass of the central body using Kepler's Third Law. Parameters: ----------- radius : float The orbital radius (in meters). period : float The orbital period (in seconds). Returns: -------- float The mass of the central body (in kg). \"\"\" T_squared = period**2 mass = (4 * np.pi**2 * radius**3) / (G * T_squared) return mass","title":"Additional Analysis: Calculate the mass of the Sun using Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculate-the-mass-of-the-sun-using-the-average-radius-of-earths-orbit","text":"earth_radius = 1.496 * 10**11 # Average distance from Earth to Sun (in meters) earth_period = 365.25 * 24 * 3600 # Orbital period of Earth (in seconds) mass_sun = calculate_mass(earth_radius, earth_period) print(f\"Calculated mass of the Sun: {mass_sun:.2e} kg\")","title":"Calculate the mass of the Sun using the average radius of Earth's orbit"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}